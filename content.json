{"meta":{"title":"静思轩","subtitle":"别说你没天赋，你的努力程度还没到拼天赋地步","description":null,"author":"Oliver","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-05-18T02:51:15.000Z","updated":"2019-05-18T02:51:15.706Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"软件开发/系统架构/消息中间件/README","date":"2019-05-24T15:16:53.162Z","updated":"2019-05-04T08:13:32.208Z","comments":true,"path":"passages/软件开发/系统架构/消息中间件/README/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/消息中间件/README/","excerpt":"","text":"消息中间件: RocketMQ, Kafka异步处理、缓解服务器压力，解藕系统 RocketMQ RabbitMQ Kafka","categories":[],"tags":[]},{"title":"","slug":"软件开发/系统架构/数据存储/README","date":"2019-05-24T15:16:52.708Z","updated":"2019-05-04T08:13:32.193Z","comments":true,"path":"passages/软件开发/系统架构/数据存储/README/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/数据存储/README/","excerpt":"","text":"数据存储关系式数据库 Create、Query、Delete、Update操作外。还需要能自行建立索引 数据库的平行扩展 如何进行性能调试。以及了解常见查询操作的性能级别，常见的查询性能瓶颈点 mysql，对它基本的参数优化，慢查询日志分析，主从复制的配置 Hadoop Hive分布式大数据存储nfs,fastdfs,tfs,Hadoop了解他们的优缺点，适用场景 。 MongoDB 分片、转存及恢复策略 分表分库规则和路由 负载均衡 读写分离 分布式事务 跨接点排序分页支持 分布式缓存技术memcached,redis Redis 主从复制原理以及无磁盘复制分析 Redis 中AOF和RDB持久化策略 数据结构 持久 复制 CAS 单线程 把硬盘上的内容放到内存里来提速，算法一致性hash","categories":[],"tags":[]},{"title":"","slug":"软件开发/系统架构/搜索引擎/README","date":"2019-05-24T15:16:52.687Z","updated":"2019-05-04T08:13:32.189Z","comments":true,"path":"passages/软件开发/系统架构/搜索引擎/README/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/搜索引擎/README/","excerpt":"","text":"搜索引擎相关技术知识: ElasticSearch, Logstash, Kibana","categories":[],"tags":[]},{"title":"","slug":"软件开发/系统架构/分布式流式计算/README","date":"2019-05-24T15:16:52.636Z","updated":"2019-05-04T08:13:32.129Z","comments":true,"path":"passages/软件开发/系统架构/分布式流式计算/README/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/分布式流式计算/README/","excerpt":"","text":"Spark Storm分布式实时存储与流式计算","categories":[],"tags":[]},{"title":"","slug":"软件开发/系统架构/分布式架构/README","date":"2019-05-24T15:16:52.545Z","updated":"2019-05-04T08:13:32.120Z","comments":true,"path":"passages/软件开发/系统架构/分布式架构/README/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/分布式架构/README/","excerpt":"","text":"高并发+高可用+微服务分布式互联网架构实战 Nginx Redis Transaction事务、pipeline以及优化和Sentinel高可用集群 Nginx分离zuul+Redis实现token网关登录认证 系统集群、负载均衡、反向代理、动静分离，网站静态化 。","categories":[],"tags":[]},{"title":"","slug":"软件开发/系统架构/README","date":"2019-05-24T15:16:52.366Z","updated":"2019-05-04T08:13:32.118Z","comments":true,"path":"passages/软件开发/系统架构/README/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/README/","excerpt":"","text":"系统框架框架SpringSpring Framework IOC原理 单例/原型模式，工厂模式 AOP、装饰器模式 其他常用模式，适配器、观察者、策略，模板方法 Spring JDBC. 声明式事物/事物嵌套原理 Spring BootSpring Boot + Spring MVC 一致性高级一致性算法 一致性hash paxos zab nwr raft gossip 传统一致性 Consistency Isolation Atomic Duration 分布一致性理论CAP，BASE 协议 两段式提交协议 三段式提交协议 TCC柔性事物 最终一致性 查询模式 补偿模式 异步确保模式 消息确保模式 校对模式 超时模式 快速失败 补偿模式 分布式架构设计 负载均衡 水平伸缩 集群 分片： key-hash, 一致性hash 异步 消峰 分表分库 分布式事务 消息幂等性设计幂等性原理，实现方式，重试机制， 分布式架构通信 分布式架构通信原理 通信协议序列化和反序列化：Thrift, ProtoBuf, Hession, WebService 服务治理zookeeper和选举机制微服务原理，分布式服务治理，服务注册与发现 配置中心配置中心原理/优点/配置变更 网关设计网关模式/原理 声明式服务调用Feign+Hystrix+客户端路由+服务降级 异步驱动设计，消息服务: JMS, RocketMQ, Kafka异步处理、缓解服务器压力，解藕系统 消息系统概念，模型，Queue, Topic JMS RabbitMQ Kafka： 持久，复制，Partition， Stream 分布式架构JVM监控与JMXSpring集成JMX,实现MBean，使用JConsole 流量控制设计限流设计/熔断设计/服务降级/Nginx反向代理+limit限速 边缘计算模式什么是边缘计算，使用它实现秒杀业务 消息中间件: RocketMQ, Kafka异步处理、缓解服务器压力，解藕系统 RocketMQ Kafka 搜索引擎相关技术知识: ElasticSearch, Logstash, Kibana高并发+高可用+微服务分布式互联网架构实战 Nginx Redis Transaction事务、pipeline以及优化和Sentinel高可用集群 Nginx分离zuul+Redis实现token网关登录认证 系统集群、负载均衡、反向代理、动静分离，网站静态化 。 Spark Storm分布式实时存储与流式计算","categories":[],"tags":[]},{"title":"","slug":"软件开发/机器学习AI/README","date":"2019-05-24T15:16:51.726Z","updated":"2019-05-04T08:13:31.978Z","comments":true,"path":"passages/软件开发/机器学习AI/README/","link":"","permalink":"http://yoursite.com/passages/软件开发/机器学习AI/README/","excerpt":"","text":"分布式数据挖掘、机器学习、人工智能PythonTensorFlow","categories":[],"tags":[]},{"title":"","slug":"软件开发/服务器/README","date":"2019-05-24T15:16:51.705Z","updated":"2019-05-04T08:13:31.978Z","comments":true,"path":"passages/软件开发/服务器/README/","link":"","permalink":"http://yoursite.com/passages/软件开发/服务器/README/","excerpt":"","text":"Server如果一开始就将静态文件与主站内容混杂在一起，未来就是个灾难，具体参考CDN的应用方式 ApachenginxTomcat, Jetty","categories":[],"tags":[]},{"title":"","slug":"金融/投资/FinancialWord","date":"2019-05-24T15:12:32.608Z","updated":"2019-05-24T15:11:24.532Z","comments":true,"path":"passages/金融/投资/FinancialWord/","link":"","permalink":"http://yoursite.com/passages/金融/投资/FinancialWord/","excerpt":"","text":"title: FinancialWorddate: 2019-05-24 22:06:47categories: 金融 投资 A.M.T.Alternative Minimum Tax is a calculation designed to ensure that individuals and corporations pay their &apos;fair share&apos; of federal income taxes. Interest on private activity municipal securities is subject to A.M.T. Accrued InterestBased on the amount of interest earned, but not paid, as of the pricing date. Amount of interest accumulated, but not yet paid, between semiannual payment dates. Adjustable Rate Municipal Preferred SecuritiesDividend rate is reset either every seven (7) or twenty-eight (28) days. Ask your Financial Advisor for current rates. Adjustable rate preferredsPerpetual securities with a variable, rather than fixed,quarterly dividend that floats between an upper and lower range, or collar. Adjusted Cost BasisThe original cost of securities less the amortized premium (or plus the accretion on an original issue discount bond). Mortgage-Backed Securities or Market Discount Bonds are not adjusted. Average Effective MaturityFor a single bond, it is a measure of maturity that takes into account the possibility that a bond might be called back to the issuer. For a portfolio of bonds, average effective maturity is the weighted average of the maturities of the underlying bonds. The measure is computed by weighing each bond&apos;s maturity by its market value with respect to the portfolio and the likelihood of any of the bonds being called. Average After State Tax Yield (ATY)The weighted average yield after state income taxes are paid on out of state bonds. It reflects both the tax free yield of an in state bond and the after tax yield of an out of state bond. Average CouponThe weighted average of all the coupons in the portfolio. Zero-Coupon Bonds are included in this calculation. Average Yield to MaturityWeighted average yield that assumes all bonds will go to maturity. It also assumes that all callable bonds will not be called. Average Yield-To-Worst (Purchase Yield)The weighted average yield based on the purchase price of the bond. It assumes the bonds are purchased at the lower of either the yield to call or the yield to maturity. Average Yield-To-Worst in YearsThe weighted average of years based on the purchase price of the bonds. It assumes the bonds are purchased at the lower of either the yield to the call or the yield to maturity. BondsBonds are affected by a number of risks, including fluctuations in interest rates, credit risk and prepayment risk. In general, interest rate risk occurs when prevailing interest rates rise, causing bond prices to fall. Credit risk, which is the possibility that the issuer of a security will be unable to make interest payments and repay the principal on its debt. Similarly, a decline in an issuer&apos;s credit rating, or credit worthiness, can cause a bond&apos;s price to decline. High yield bonds are subject to additional risks such as increased risk of default and greater volatility because of the lower credit quality of the issues. Finally, bonds can be subject to prepayment risk. When interest rates fall, an issuer may choose to borrow money at a lower interest rate, while paying off its previously issued bonds. As a consequence, underlying bonds will lose the interest payments from the investment and will be forced to reinvest in a market where prevailing interest rates are lower than when the initial investment was made. Bond Equivalent Yield (BEY)Also referred to as a Corporate Bond Equivalent Yield (CBE), BEY is an adjustment to the mortgage yield to reflect assumed semi-annual payment of cash flows (rather than monthly). Converting monthly Mortgage-Backed Securities (MBS) cash flows to a semi-annual equivalent allows a more meaningful comparison of MBS values to corporate and government bonds. The conversion primarily reflects the benefit to the MBS holder of reinvesting MBS cash flows monthly rather than semi-annually, as is the case with other fixed-income securities. Bond equivalent yield calculations are currently not provided in the FIHNW report. Cost BasisThe price originally paid for the bonds. Convertible BondA corporate bond that can be exchanged, at the option of the holder, for a specific number of shares of the company&apos;s stock. Because a convertible bond is a bond with a stock option built into it, it will usually offer a lower than prevailing rate of return. It is subject to market risk, interest rate risk and default risk. ConvexityA measure of the curvature in the relationship between bond prices and bond yields that demonstrates how the duration of a bond changes as the interest rate changes. Convexity is used as a risk-management tool, and helps to measure and manage the amount of market risk to which a portfolio of bonds is exposed. Corp/Muni BondsBonds can be called prior to maturity which may reduce yield. Ordinary call information is above. Other call features may exist. Bond prices may fluctuate reflecting market interest rates and the issuer&apos;s credit status. Current YieldCoupon divided by the price. As an example a bond with a 5.00% coupon offered at $105 would have a current yield of 4.76%; 5.00/105=4.76%. Double-Barrelled BondA municipal bond secured by a defined revenue source as well as the full faith and credit of an issuer that has taxing power. It has both general obligation and revenue pledges. Default RiskPossibility that a bond issuer will fail to pay principal or interest when due. Defaults can also occur for failure to meet nonpayment obligations, such as reporting requirements, or when a material problem occurs for the issuer, such as a bankruptcy. Effective DurationEffective Duration measures the approximate percentage volatility of a bond&apos;s value for a 1% (100 bp) change in interest rates. Estimated Accrued InterestBased on the amount of interest earned, but not paid, as of the date the report was priced. Estimated Principal CostDollar value of proposed bonds excluding accrued interest. Escrow-to-Maturity (ETM)Municipal securities for which proceeds have been deposited into an escrow account to pay principal and interest on the securities. Face AmountThe nominal value or dollar value of a bond stated by the issuer. It is the amount paid to the holder at maturity (generally $1,000). Also known as &apos;par value&apos; or simply &apos;par&apos;. FactorA decimal value that reflects the proportion of outstanding principal balance of a Mortgage-Backed Security. The factor may change each month in relation to its original principal value. Floating-Rate BondSecurities with a coupon interest rate that is adjusted periodically based upon market conditions. General Obligation BondA municipal bond backed by the credit and &quot;taxing power&quot; of the issuing jurisdiction rather than the revenue from a given project. Investment GradeBonds considered suitable for preservation of invested capital; ordinarily, those rated Baa3 or better by Moody&apos;s Investors Service, or BBB- or better by Standard &amp; Poor&apos;s Corporation High-Yield BondA bond with unfavorable credit characteristics that is typically non-rated or rated below investment grade. A high-yield bond trades at yields substantially higher than bonds with more favorable credit characteristics and often suffers from lack of liquidity and marketability and carries more risk in exchange for the higher yield. International/Global InvestingInternational investing may not be for everyone. There may be additional risk associated with international investing, including foreign, economic, political, monetary and/or legal factors, changing currency exchange rates, foreign taxes, and differences in financial and accounting standards. The possibility that adverse political events, financial problems, or natural disasters in a country or region will cause investments in that country or region to lose value. The risks of investing in emerging or developing markets can be substantially greater than the risks of investing in developed markets. Mortgage-Backed SecuritiesMortgage-backed securities (&quot;MBS&quot;), which include collateralized mortgage obligations (&quot;CMOs&quot;), also referred to as real estate mortgage investment conduits (&quot;REMICs&quot;), may not be suitable for all investors. There is the possibility of early return of principal due to mortgage prepayments, which can reduce expected yield and result in reinvestment risk. Conversely, return of principal may be slower than initial prepayment speed assumptions, extending the average life of the security up to its listed maturity date (also referred to as extension risk). Additionally, the underlying collateral supporting non-Agency MBS may default on principal and interest payments. In certain cases, this could cause the income stream of the security to decline and result in loss of principal. Further, an insufficient level of credit support may result in a downgrade of a mortgage bond&apos;s credit rating and lead to a higher probability of principal loss and increased price volatility. Investments in subordinated MBS involve greater credit risk of default than the senior classes of the same issue. Default risk may be pronounced in cases where the MBS security is secured by, or evidencing an interest in, a relatively small or less diverse pool of underlying mortgage loans. MBS are also sensitive to interest rate changes which can negatively impact the market value of the security. During times of heightened volatility, MBS can experience greater levels of illiquidity and larger price movements. Price volatility may also occur from other factors including, but not limited to, prepayments, future prepayment expectations, credit concerns, underlying collateral performance and technical changes in the market. Please read offering documents and/or prospectus information carefully for the risks associated with the particular MBS security you are purchasing. Municipal Equivalent Yield (MEY)The MEY factor will help you determine whether out-of-state municipals are advantageous on a yield basis. In other words, the MEY factors will show how much you need to earn on an out-of-state municipal bond in order to account for the income taxes paid at the state level. Market ValueThe value of the portfolio, excluding accrued interest, at the pricing date. Missing DataIf purchase price is unknown, the High Net Worth Report will show the issue price (often $100.00). If settlement date is unknown, High Net Worth will use the dated date as a settlement date. In addition, when a bond has 0.001 in the coupon field it indicates that the security has a coupon greater the 0% but less than 1% and may not reflect the actual coupon. Please contact your Financial Advisor if you have any questions about the actual coupon or to provide your Financial Advisor with accurate purchase dates and prices. Net Unrealized Gain(Loss)The market value less the cost basis. Par AmountThe face amount of a security, payable to the holder at maturity. PSA&apos;Prepayment speed assumption&apos; measures the rate of principal prepayments, which in effect influences the average life of a bond, pre-payment window, and bond equivalent yield. Par AmountThe face amount of a security, payable to the holder at maturity. Preferred securitiescan be called prior to maturity, which may reduce yield if purchased at a premium. Preferred securities may be subject to other call features or corporate restrictions that may have an effect similar to a call. Prices may fluctuate reflecting market interest rates and the issuer&apos;s credit status. Finally, bonds can be subject to prepayment risk. When interest rates fall, an issuer may choose to borrow money at a lower interest rate, while paying off its previously issued bonds. As a consequence, underlying bonds will lose the interest payments from the investment and will be forced to reinvest in a market where prevailing interest rates are lower than when the initial investment was made. Redemption ValueDollar amount coming due based on par amount or call price. Remaining PrincipalThe amount of principal remaining to be paid under the Mortgage-Backed Security as of a given point of time. The remaining principal is calculated by applying the factor to the original face. Revenue BondA municipal bond supported by the revenue from a specific project, such as a toll bridge, highway or local stadium. Revenue bonds are municipal bonds that finance income-producing projects and are secured by a specified revenue source. Redemption ValueDollar amount coming due based on par value or call price. Scheduled After-Tax Annual IncomeNet income after federal and state taxes are applied. This calculation assumes that the investor itemizes deductions on his federal tax return. Currently, the report does not calculate the after-tax yield on various agency securities. Scheduled Annual IncomeThe total annual income that will be generated by the portfolio. Taxable Equivalent Yield (TEY)The TEY calculates the yield needed in a fully taxable investment that would be equivalent to the tax-free yield of a municipal bond. A formula that converts the lower yield of a tax-exempt security into the higher yield of a taxable security. Calculating the TEY of a tax-free municipal bond allows for an &quot;apple to apple&quot; comparison to taxable bonds. The TEY can be used to illustrate to investors the impact of both Federal and State income taxes on their taxable investments. If the municipal bond is out of the clients home state then we use the after state tax yield to calculate TEY. Underlying RatingIn the case of a security for which credit enhancement has been obtained, the rating assigned by a rating agency to such security without regard to credit enhancement or assigned to other securities of the same issuer having the same features and security structure but without the credit enhancement. Municipal BondsMunicipal bonds are debt obligations offered by a municipality and they generally are either revenue or general obligation bonds. As with all bonds, these are subject to the same risks, and are subject to the creditworthiness of the municipality offering them or to the revenue project for which the bonds were offered. An Investment in Municipal Bonds may be subject to state and local taxes and you may also be subject to the Federal Alternative Minimum Tax (AMT). Official offerings may be made only by the final Official Statement. If sold prior to maturity you may receive more or less than your original investment. Yield To WorstThe lowest potential yield that can be received on a bond without the issuer actually defaulting. The yield to worst is calculated by making worst-case scenario assumptions on the issue Scheduled Annual After-Tax IncomeNet Income after federal and state income taxes are applied (assumes federal income tax deductions are itemized). The after-tax yield on U.S. agency securities are not calculated. Scheduled Annual IncomeThe total annual income that is scheduled to be generated by the portfolio. Total Portfolio ValueThe market value of the securities plus the accrued interest plus the money market holdings. Total ReturnThe return on an investment, including income from interest, as well as appreciation or depreciation in the price of the security, over a given time period. Underlying RatingIn the case of a security which has been credit enhanced, the rating assignment by a rating agency to such security without regard to the credit enhancement. Weighted Average After-Tax Market YieldYield after federal and state taxes are applied (assumes federal income tax deductions are itemized), weighted by market value/par value amount. The after-tax yield on U.S. agency securities are not calculated. Weighted Average Call/Maturity in YearsAverage of bonds to either the call date (in the case of callable bonds) or to maturity (in case of non-callable bonds), weighted by market value/par amount. Weighted Average CouponAverage of the coupons in the portfolio (including Zero-Coupon Bonds), weighted by market value/par amount. Weighted Average Life (WAL)The average number of years that each dollar of unpaid principal remains outstanding. Weighted Average Maturity In YearsAverage maturity of the portfolio excluding Mortgage-Backed, Preferred, and Floating-Rate Securities, weighted by market value/par amount. Weighted Average Pre-Tax Market YieldThe average of either the yield-to-maturity or the yield-to-call (whichever is applicable), weighted by market value/par amount. It is calculated before any federal or state taxes (if applicable) are paid. Weighted Average Purchase YieldThe average yield weighted by the purchase price of the bond. Weighted Average Yield to Call/MaturityAverage yield to the call (in the case of callable bonds) or to maturity (in the case of non-callable bonds), weighted by market value/par amount. Weighted Average Yield to MaturityAverage yield weighted by market value/par amount assuming all bonds go to maturity. Zero Coupon BondsZero coupon bonds may experience greater price volatility than interest-bearing fixed income securities because of their comparatively longer duration. Taxable zero coupon bonds are treated as having original issue discount (OID) for tax purposes. Although interest is not received until maturity, the zero coupon bond is assumed to pay a pre-determined interest rate that will be treated as current income for tax purposes if held in a taxable account. Please consult your tax advisor regarding the consequences of owning zero coupon bonds, as well as the applicable rules that apply to such bonds. Agency securities issued by U.S. Federal agencies and privately run corporationsknown as government-sponsored enterprises (GSEs) to provide funding for a specific public purpose. Agency transaction when a broker-dealer purchases or sells a bond outside its owninventory or on an exchange. Alternative minimum tax (AMT) targets wealthy investors; applied to the interestgenerated by some municipal bonds by adding tax-preference items back to adjusted gross income. Anticipation notes short-term securities issued by municipalities to bridge financinggaps until revenue is received. Most mature in less than one year, and are commonly issued as: tax anticipation notes (TANs), revenue anticipation notes (RANs), tax and revenue anticipation notes (TRANs), and bond anticipation notes (BANs). Ask see Offer. Asset allocation the process of segmenting a portfolio into different types ofinvestments. Asset-backed securities structured like mortgage bonds, except they’re backed byreceivables from assets other than real estate—such as credit card loans, airplane leases and auto loans. Baby bonds debt preferreds created by broker-dealers from their own inventory by splitting large blocks of $1,000 par bonds into $25 increments. Banker’s acceptance (BA) one- to six-month money market instrument sold at a discount;typically used by importers and exporters. Barbell portfolio strategy whereby bond holdings are concentrated among the shortestand longest maturities with nothing purchased in between. Basis point (bp) represents 1/100th of a percent (100 basis points equals one percent). Bearer bonds: these were physical certificates with actual coupons that bond investors would clip and mail to the issuer’s trustee in exchange for earned interest. Distribution of these bonds was suspended in 1982; today all bonds are issued in electronic (book entry) form. Bid price at which a bond is sold; the bid is always lower than the offer.Bond: a security that pays a specified rate of interest for a limited amount of time and returns principal on a defined date. Bond equivalent yield (BEY) used in order to accurately compare Treasury bills tothe annualized yield of a coupon-bearing security; typically quoted with the discount rate. Bond swap selling one bond with the intent of using the proceeds to purchaseanother. Book entry form electronic record of ownership reflected on a bank or brokeragestatement. Interest payments are distributed directly by mail or deposited into investment accounts. Broker-dealers investment firms that broker (sell) and deal (issue) bonds.Bullet securities (bullets): bonds devoid of any early redemption features. Bullet strategy see Maturity matching. Busted convert when the stock price is well below a convertible bond’s conversionprice; the option becomes worthless and the security’s price only reflects the intrinsic value of the bond. Call early redemption feature of a bond. Call protection a certain number of years during which the issuer does not have theright to call a bond. Call risk holder of a callable bond runs the risk of the bond being redeemed prior to maturity. Call schedule the series of early redemption dates for a callable bond. Callable bond feature that grants the issuer the right to retire a bond prior to itsmaturity, beginning on a specific date. Capital gain when a security is sold above its purchase price; considered a shortterm gain if sold within 12 months of purchase and taxed at nominal income tax rate; beyond 12 months is long-term and taxed at a maximum 15 percent rate. Capital loss when a security is sold below the purchase price. Capital preservation investment goal that seeks to minimize principal risk. Capital structure ranks debt and equity according to the claim they have on a company’s assets. Cash management bill short-term security auctioned by the U.S. Treasury to supplementthe financing provided by T-bills. Certificate of deposit (CD) time deposit that has the qualities of a bond but is not anSEC-registered offering; typically insured by the Federal Deposit Insurance Corporation (FDIC) for up to $100,000 (principal and interest combined). Closed-end fund actively managed bond fund with a fixed number of shares thattrades with a bid/ask spread on a stock exchange or in the over-the-counter market. Collateralized mortgage obligation (CMO) a group of pass-through securities carved into different classes (tranches); on average, CMOs contain 60 to 100 differenttranches. Commercial paper (CP) short-term debt issued by large corporations; matures in270 days or less. Competitive bid indicates desired purchase amount and yield at U.S. Treasuryauction. Compound interest: computed on the original principal as well as accumulated earned interest. Confirmation receipt sent to investors outlining details of a transaction whenever asecurity is bought or sold. Consumer Price Index (CPI) the most widely watched consumer inflation barometer,expressed as a percentage of year-over-year growth. Contrarian investor one who makes investment decisions that disagree with consensus.Conversion parity: when a convertible bond’s price is equal to the current market value of the common stock to be received if converted. Conversion price the price a convertible security may be exchanged for commonstock. Conversion ratio a convertible bond’s par value divided by its conversion price.Convertible security (convert): a bond or preferred with an option that allows for an exchange of the security for common stock of the same issuer at a specified price. Corporate bonds (corporates) securities issued by the private sector which are usedfor a variety of purposes, from working capital, to building factories or acquiring other companies. Cost basis the net purchase price of a security. Covenants legal protections provided to investors as contained in the indenture. Coupon a bond’s stated annual interest rate. Credit rating quantifies risk by providing a forward-looking analysis of an issuer’sability to make timely interest payments and return principal at maturity. Credit rating agencies independent companies paid by bond issuers to evaluatetheir financial profiles and provide rankings; sanctioned and closely monitored by the SEC, the three major agencies are Moody’s Investors Service (Moody’s), Standard &amp; Poors (S&amp;P) and Fitch Ratings. Cumulative dividend if preferred dividends are suspended, then missed paymentsaccumulate; the cumulative dividend must be repaid to investors if dividends are resumed. Currency risk the potential of another currency to appreciate or depreciate in valuewhen converted back to one’s home currency. Current yield a bond’s annual rate of return determined by multiplying the couponby par value, dividing it by the purchase price and multiplying by 100; this yield does not incorporate future interest payments or the difference between purchase price and redemption value. Curtailment when homeowners pay more than the monthly amount that’s due, it’sapplied directly to mortgage principal. Cushion bonds see Premium bonds. CUSIP (Committee on Uniform Securities Identification Procedures) a unique ninedigit (alphanumeric) number assigned to each bond. Death put see Survivors option. Debenture bond backed by an issuer’s general credit standing rather than by specific assets. Debt market more commonly known as the bond market. Default when an issuer fails to meet its financial obligations; usually followed by bankruptcy. Deflation when consumer prices decline over a long period of time; opposite ofinflation. Diluting shareholder equity when companies increase stock issuance, the percentageof the company that is owned by current shareholders is reduced. Discount when a bond’s price trades below its $1,000 par value. Discount notes (discos) zero coupon agency securities issued at a discount to parwith up to one-year of maturity. Distressed market: where professional “vulture” investors place bets among troubled or defaulted issuers. Dividend Received Deduction (DRD) preferreds 70% of the dividend generated by these securities is a tax break to certain corporate investors that hold them for at least 46 days. Diversification a strategy that seeks to improve the overall rate of return and substantially reduce risk if a portfolio is populated with a number of uncorrelated investments. Dollar cost average a fixed amount invested at periodic intervals; usually appliedto mutual fund investing; also known as the constant dollar plan.Downgrade: when a credit agency lowers the rating of an issuer, typically when its financial condition deteriorates. Duration a measure of the sensitivity of a bond’s price to interest rate fluctuations; represents the percentage change in a bond’s price given a 1% rise or fall in interest rates. Dutch (single-price) auction a Treasury auction whereby all investors receive the same yield for their bids. Easing if the Federal Open Market Committee (FOMC) concludes that the economy needs stimulus, the funds rate is lowered; also known as “accommodative” monetary policy. Emerging market bonds issued by companies and governments from evolving market-based economies; issuers are typically located in Latin America, Eastern Europe and Southeast Asia. Equity market more commonly known as the stock market. Event risk risk related to potential events that would affect the credit quality of a bond, such as a takeover, political or economic upheavals. Expense ratio derived from annual expense fees charged in order to cover a fund’soverhead; calculated by dividing total expenses by total assets in the fund. Extension risk when rates rise, mortgage bond prepayments slow and more principal remains in the loan pool for a longer period of time; consequently, average life lengthens. Face value see Par value. Fallen angel an issuer downgraded from investment-grade to high-yield.Federal funds rate (fed funds rate): the interest rate that banks charge each other for overnight loans to meet reserve requirements; its target is determined eight times a year by the Federal Open Market Committee (FOMC). Flight to quality when risk aversion heightens due to political, economic or marketrisk, strong inflows to the safest investments (such as Treasuries) occur. Future value what money today would be worth at some point in the future, assuming a specified rate of return. General Obligation (GO) bond issued by municipalities that have the ability to taxconstituents; state governments dominate this type of issuance. Global bonds often refers to bonds simultaneously issued in different currencies;typically denominated in U.S. dollar, UK sterling and/or euro currencies. Government-sponsored enterprises (GSEs) U.S. federally-designated companies affiliated with, but separate from, the U.S. government; major issuers of agency and mortgage bonds. High-grade bonds see Investment-grade bonds. High-yield (junk) bonds speculative issuers rated below investment-grade by thecredit agencies. Bonds are ranked from “Ba1” to “C” by Moody’s and from “BB+” to “D” by S&amp;P and Fitch. Illiquidity see Liquidity. Indenture a formal, legally binding contract that bond issuers are required to publish; comprehensively describes specific terms and conditions of a bond offering and contains provisions meant to protect both parties. Indication of interest investor submits desired purchase amount to broker-dealer fornew bond offering. Inflation when the cost of a product or service rises and quality remains the same; also, when spending increases relative to supply—think of it as too much money chasing too few goods. Insured bonds municipal bonds (and sometimes taxable issuers) backed by insurance which guarantees that interest and principal will be paid should the issuer default; automatically receive Triple-A ratings by credit agencies. Interest expense interest paid to bondholders that provide corporations with a pretaxdeduction. Interest-on-interest reinvesting interest payments and earning interest on that newprincipal. Interest rate risk the effect of fluctuating interest rates on bond prices. Intermediate-term bonds: bonds with 5- to 12-years until maturity. Inverted yield curve when short-term rates are higher than intermediate and longtermrates; usually occurs when the Federal Reserve tightens the funds rate in order to slow down a fast-growing economy and creeping inflation pressures. Investment-grade (high-grade) bonds comprises issuers that are deemed to be in good financial health and are unlikely to have trouble meeting their debt obligations. Bonds are ranked from Triple-A (highest) to Triple-B (lowest). Jumbo CDs certificates of deposit sold in multiples of $100,000. Junk bonds see high-yield bonds. Laddered portfolio strategy investors purchase an equal number of bonds to mature in sequence over a chosen period of time. Leverage an issuer’s overall debt level relative to its current cash flow or total capital; non–investment-grade companies are considerably leveraged. Liquidity the market’s demand for (and supply of) a particular security. When a bond is said to have good liquidity, it can be readily converted into cash near the price that it was last bought or sold. Opposite illiquidity. Load an upfront or back-end sales charge on a mutual fund. Lockout the period prior to the first principal payment of certain collateralizedmortgage obligations; monthly cash flow consists of interest only. Long-term bonds bonds with maturities that exceed twelve years.Maturity matching (Bullet strategy): purchasing bonds in a targeted maturity to ensure that a specific amount of money is available on a specific date. Managed accounts usually require a minimum investment of $100,000 to $250,000,which is either turned over to a professional money manager or allocated among several different portfolio managers to match a strategy aligned with stated investment objectives. Markups and Markdowns analogous to stock commissions, they’re the cost of doingbusiness every time a principal transaction occurs. The net bid or offer incorporates this charge. Markups occur when a bond is purchased, and markdowns occur when a bond is sold. Maturity a bond’s predetermined lifespan at issuance. Maturity date when a bond’s final interest payment and principal are distributed,effectively terminating the obligation of the borrower (issuer) to the lender (investor). Medium-term note (MTN) senior unsecured debt with a survivor option feature thatdiffers from typical corporate bonds due to its ability to generate quarterly or monthly payments; also structured as 2- to 5-year bullets and as 10- and 15-year callable securities. Money market funds mutual funds invested in short-term securities, such asTreasury bills, CDs, banker’s acceptance, and commercial paper; provide a higher rate of return than savings accounts, can offer check-writing privileges and are readily available as cash. Money market securities short-term instruments that mature in one year or less,such as Treasury bills, CDs, banker’s acceptance, and commercial paper. Mortgage-backed securities (MBS) bonds secured by real estate; most mortgagebonds are backed by residential mortgages, although some are commercial-backed securities. Mortgage pool created when a group of mortgage loans with similar interest rateand maturity characteristics are packaged together. Municipal bonds issued by state and local governments to finance projects thatserve the public interest; popular with individual investors due to their tax-free interest income. Negative convexity a feature typically associated with mortgage bonds wherebyprices tend to decline more than other bonds when interest rates rise, and appreciate less when rates decline. Negative slope see Inverted yield curve. Net asset value (NAV) a fund’s total value less expenses then divided by the numberof outstanding shares. The current NAV is determined at the end of each business day. No-load funds funds that do not have an upfront or back-end sales charge.Nominal yield: a bond’s coupon rate; also the prevailing interest rate without incorporating inflation. Noncompetitive bid investors submit this in a Treasury auction, which specifieshow many bonds desired to purchase; all noncompetitive requests are filled. Noncumulative dividends allow issuers to resume regular payments without compensatinginvestors for lost dividends. Nongovernmental purpose bonds tax-exempt securities used to fund initiatives that more narrowly serve the public interest or are associated with the private sector. Odd lot in the bond market, anything less than a round lot (at least one million dollarspar value). Offer (Ask) the price at which an investor may purchase a bond; always higher than the bid. On-the-run Treasury the most recently auctioned benchmark Treasury securities;older securities are considered off-the-run. Open-end mutual funds actively managed bond funds that issue an unlimited numberof shares; not traded on an exchange but instead bought and sold by the fund company itself. Original issue discount (OID) when a new issue is purchased at a discount and heldto maturity, investors can recognize the gain as ordinary income instead of capital gain. Outstanding securities secondary market bonds that have been issued but have notyet matured or been called. Over-the-counter (OTC) a “virtual” market where the bulk of the bond market’sdaily trading volume is transacted. Bond traders buy and sell directly with each other, not through a specialist on an organized exchange. Par value also known as face value; the dollar amount received at maturity and the value used to calculate interest; bonds are customarily issued with a $1,000 par value. Pass-through securities (pass-throughs) conduits whereby mortgage payments are collected in a pool and distributed to bond investors through a trust that is created at issuance. Patriot Bonds see Series EE Savings Bonds. Phantom income interest generated by zero coupon bonds; accrued interest from most zero bonds is taxed as if you had actually received it that year. Planned Amortization Class (PAC) bonds type of mortgage bond that has cash flow allocated to each tranche based on a schedule with preset limits for prepayments so average life and yield are relatively stable. Poison put featured in high yield issues, it allows bonds to be redeemed at a slight premium if there’s a “change of control,” such as a company buyout. Portfolio managers mutual fund and closed-end funds are actively managed bythese investment professionals. Positive slope yields increase as maturities lengthen. A positive slope is considered“normal” because uncertainty naturally accelerates as money is invested for longer periods of time. Premium when a bond’s price trades above its $1,000 par value. Premium (cushion) bonds: these securities trade above par value; higher couponrates “cushion” the downward pressure on bond prices. Prepayments (prepays) unscheduled mortgage bond principal payments; sincemost homeowners do not adhere to a specific payment schedule, monthly cash flow generated by mortgage bonds varies over time. Prepayment risk associated with the rise in prepays due to higher refinancing activity,causing the amount of principal returned to the investor to be larger than expected. Prepayment speeds traders determine the pace that principal is returned to investorsusing historical data and then utilize it to price mortgage-backed securities. Pre-refunded bonds (pre-re’s) callable municipal bonds that have been refinanced; issuers then distribute refunding bonds at lower interest rates and purchase Treasuries with the proceeds. Price transparency when the price and cost of a transaction are fully disclosed.Primary dealers: a select group of 22 investment firms and banks that are key participants in the Treasury auction process. Primary market where new bonds are issued; also known as “syndicate.” Principal transaction: when an investment firm buys and sells for its own account. Private sector comprises domestic and multinational corporations that issue bondsas an alternative to bank loans and stock offerings. Prospectus issuers are required to publish this document that outlines the key provisions of a new offering. It summarizes crucial information from the indenture and is distributed to prospective buyers; includes use of proceeds, description of the issuer, and risk factors. Preferred securities (preferreds) securities with characteristics that uniquely straddle the debt and equity markets; were issued as nonvoting shares of stock, but today they’re more commonly issued as debt; typically have a $25 par value, fixed quarterly payments, at least 30 years to maturity and five years of call protection. Preferred stock perpetual security that declares dividends instead of paying interest;senior to common stock—but subordinate to bonds. Present value the amount that a sum of money in the future is worth today, assuming a specified rate of return. Private activity bonds issued by municipalities but are associated with projects thatare not government-run; may be taxable, depending on the extent to which they benefit public interests. Private label pass-throughs pass-throughs that are created by financial institutions and are usually rated Triple-A or Double-A; not created by government agencies. Private placements mostly high-yield bonds sold directly to qualified institutional buyers (QIBs) rather than through a public offering; subject to an SEC regulation known as Rule 144A. Public purpose bonds are issued directly by state or local authorities for projectstypically financed by governments; including construction of public schools, sanitation facilities, water treatment plants and highway improvements. Public purpose bonds are exempt from federal, state and local taxes. Public Securities Association (PSA) standard (also known as prepayment speed assumption) assumes new mortgage loans are less likely to be prepaid than olderones; used to determine mortgage bond prices. Pro-rata sinker stipulates an equal percentage of bonds to be redeemed will bespread among all investors, instead of by lottery like other sinkers. Public sector comprises federal debt issues known as Treasuries, and state and local government issues known as municipals. Put bond provides investors with the option to put a bond back to the issuer on specific dates. If a putable bond is trading below par on its put date, it may be redeemed at par. QuoteA quote is the last price at which a security or commodity traded, meaning the most recent price on which a buyer and seller agreed and at which some amount of the asset was transacted. The bid or ask quotes are the most current prices and quantities at which the shares can be bought or sold. The bid quote shows the price and quantity at which a current buyer is willing to purchase the shares, while the ask shows what a current participant is willing to sell the shares for Rate shock after interest rates have substantially declined, investors tend to lookwhere rates have been instead of where they are going; often leads to common mistake known as “reaching for yield.” Reaching for yield common mistake made by bond investors whereby risk factorsare ignored due to the desire to maximize yield. Real interest rate nominal yield minus the inflation rate, which represents the netincrease of spending power above and beyond the eroding effects of inflation. Real estate investment trust (REIT) preferred: preferred stock issued by companies that manage property or real estate loans. Real estate mortgage investment conduit (REMIC) see collateralized mortgage obligation. Recovery value the amount a bond is worth after interest payments have been haltedand the issuer defaults. Refinancing (prepayment) wave when rates drop dramatically in a short period of time, many homeowners tend to refinance concurrently. Refunding announcement provides investors with details about the amount of Treasury supply to expect in the upcoming quarter. Regular way an investment that settles in three business days. Reinvestment risk when a bond is called, investors are usually faced with the lessattractive option of reinvesting the proceeds at a lower rate. Reopening the Treasury department issues new debt by adding to older issuesinstead of holding an auction. Repurchase agreements (repos) money market instruments where an investor arranges to sell securities, but agrees to buy them back (usually overnight) at a specific price. Revenue bonds bonds that are backed by revenue and fees collected by the facilitythat’s being funded. Debt service for these bonds is directly supported by the income generated by the project. Request For Quote - RFQA request for quote (RFQ) is a type of procurement solicitation in which a company asks outside vendors to offer a quote for the completion of a specific task or project. An RFQ is similar to a request for proposal (RFP) and provides comprehensive information to the bidder concerning the project’s requirements. An RFQ frequently requires the bidder to itemize costs for each phase of the project to allow the soliciting company to compare several bids An RFQ is usually sent to several potential vendors, asking for bidder pricing. It may contain information that the bid must include for consideration, payment terms, the factors that decide which bid the company chooses and a bid submission deadline. An RFQ focuses mostly on pricing. If the minimum criteria are met, the vendor with the lowest bid is generally given the contract. Risk profile classifying an investor according to the ability to withstand marketvolatility and overall risk; typically: conservative, moderate, aggressive and speculative. Round lot in the bond market, not less than one million dollars in par value.Rule of 72: a method of determining the years required to double your money at a given yield; calculated by dividing 72 by the yield-to-maturity. Savings bonds bonds issued with the same “full faith and credit” government guarantee as Treasuries, but are non-marketable securities and are not traded in the secondary market. The three types of savings bonds are: Series EE, Series HH/H and Series I. SEC mutual fund cost calculator a quick and easy way to estimate and compare bond fund expenses. Can be found at www.sec.gov. Secondary market where outstanding bonds are bought and sold.Separate Trading of Registered Interest and Principal of Securities (STRIPS): zero coupon Treasury bond that is purchased at a deep discount to face value; created by broker-dealers and are not auctioned. Sequential bonds has separate tranches with principal that pays off sequentially; theaverage life of each preceding tranche becomes shorter than the last. Serial bonds large new bond issues that feature several different maturities.Series EE savings bond: interest is pegged to Treasuries and sold at 50% of face value. (See Savings bonds.) Series HH/Hstructured just like traditional interest-paying bonds; scheduled to bediscontinued in 2004. (See Savings bonds.) Series I savings bond an inflation-indexed savings bond whose value is pegged tothe Consumer Price Index for Urban Consumers (or CPI-U); sold at face value. (See Savings bonds.) Settlement date the day money is due for an investment. SEC yield a standard calculation that mutual funds must disclose to investors inorder to ensure that the investment may be fairly assessed compared to its peers. Short coupon when the first interest payment is not a full six months because thesemiannual coupon payment dates are dictated by maturity, not the issuance date. Short-term bonds bonds with 1- to 5-year maturities. Simple interest straight payment of interest that is not compounded. Sinking fund securities (sinkers) securities with early redemption features that designate a specific number of bonds to be redeemed on a periodic basis before finalmaturity; bonds selected for redemption are usually determined by lottery. Sovereign risk encompasses uncertainties associated with investing in anothercountry. Split rating when rating agencies assign different ratings to the same issue; rarely exceeds more than one or two notches. Spread difference between the bid and the offer price is the bid/offer spread; the difference between two bond yields is know as the yield spread. Step-up note (step-up): Fannie Mae, Freddie Mac, and some corporations issue these securities with maturities that typically do not exceed 15 years, are callable, and have coupon rates that increase according to a preset schedule over time. Support bonds bonds that absorb prepayments from PAC tranches and compensatethose securities for any shortfall in principal payments. Supranational bonds U.S. dollar–denominated international securities formed topromote economic development and are backed by the federal governments of at least two countries. Survivor’s option (death put) most MTNs retain this feature which allows heirs to redeem bonds at par should the registered owner of the bond die, even if it’s tradingat a steep discount. Syndicate a group of investment firms organized by the underwriter to help market a new bond issue to prospective buyers. Taxable equivalent yield (TEY) a calculation investors use to level the playing field when comparing taxable bond yields to tax-exempt (municipal) yields. Tax-exempt money market funds funds that invest in short-term Treasury andmunicipal debt. There are two types: federally-tax exempt, and state funds that provide state and local exemptions. Term bonds bond issues offered with only one maturity date. 30-day wash sale: this rule prohibits purchasing a “substantially identical” securitythirty days before or after the date of sale. Throwaway bid a below-market bid for a bond usually due to its illiquidity. Tightening when the Federal Reserve raises the fed funds rate to slow economicactivity; also known as tight monetary policy. Total return accurately measures what you really earned on a bond; calculated byadding the sale price to the interest generated (including any interest-on-interest), subtract that from the purchase price, and divide the whole thing by the purchase price. Trade flat securities bought and sold without accrued interest, like preferred stock. Treasury auctions regularly scheduled sales of Treasury securities.Treasury bills (T-bills): direct obligations of the U.S. government with maturities of four weeks, three months and six months. These are zero coupons sold at a discount to face value. Treasury bonds direct obligations of the U.S. government issued with maturitiesover 10 years, up to 30 years. Auctions of these securities are currently suspended. Treasury inflation protected securities (TIPS) issued with 10- and 30-year maturities, these inflation-indexed bonds are designed to benefit from rising inflation. Principal is adjusted daily by a factor tied to the performance of the Consumer Price Index-Urban Consumers (CPI-U). Treasury notes direct obligations of the U.S. government issued with maturities oftwo to 10 years; they pay interest semiannually at a fixed rate of interest. Trust preferred subordinated debt placed into a trust, which then issues $25 parsecurities (some trade in the corporate market at $1,000 face value). Quarterly interest is generated by debt securities held in the trust. Treasury securities bonds that are direct obligations of the U.S. government. Treasury yield curve plots the yield-to-maturity of all on-the-run Treasury securities—from 3- and 6-month bills, to 2-, 3-, 5-, and 10-year notes, plus the 30-year bond. Trustee bank appointed by a bond issuer to administer interest payments toinvestors. 12b1 fees what funds charge to pay for promotional and general marketing expenses. Underwriter an investment bank that arranges a bond sale on behalf of an issuer;advises issuer on the timing and terms of the offering, such as the amount of bonds to issue and the coupon rate. Unit investment trusts (UITs)a fixed group of bonds held in a trust that is notactively managed. Since there is no active secondary market for UITs, shares must be sold directly back to the issuer. Upgrade rating action that occurs when an issuer’s financial security strengthens. Weighted average life the estimated number of years when half a mortgage pool’sprincipal will be returned to the investor. Whole loan non-agency CMO that is created by financial institutions in the private sector—such as investment banks—and is the sole obligation of those issuers. Window estimated time frame between the first and last principal payments of a CMO tranche. Yankee securities non-U.S. incorporated companies that issue dollar-denominateddebt in the United States; these issuers tend to be quasi-government monopolies or privatized companies. Yield-to-call (YTC) the same calculation as YTM, except it targets a call date insteadof the maturity date. YTC incorporates the future stream of reinvested coupon payments, the price paid for the bond, as well as the price received at each early redemption date. Yield-to-maturity (YTM) the percentage rate of return assuming a bond is held untilmaturity and interest payments are reinvested at the same nominal yield. YTM integrates any difference between par value and the actual price paid. Yield-to-worst (YTW) the lowest yield received: it’s the lower of a bond’s YTM andYTC. This is the most conservative way to view a bond’s potential return and should always be assessed when purchasing any callable security. Zero coupon bonds (accrual bonds) bonds that do not make cash interest payments to investors. Instead of receiving a payment every six months, earned interest accrues to the face value of the bond until it matures at $1,000 par value. Zeros are issued at a deep discount to par.","categories":[],"tags":[]},{"title":"Intellij","slug":"软件开发/Intellij","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:18:31.883Z","comments":true,"path":"passages/软件开发/Intellij/","link":"","permalink":"http://yoursite.com/passages/软件开发/Intellij/","excerpt":"","text":"自动代码 fori/sout/psvm+Tab： 即可生成循环、System.out、main方法等boilerplate样板代码 for(User user : users): 输入user.for+Tab Date birthday = user.getBirthday()： 输入user.getBirthday().var+Tab即可 Ctrl+Alt+O 优化导入的类和包 Alt+Insert 生成代码(如get,set方法,构造函数等) 或者右键（Generate） fori/sout/psvm + Tab Ctrl+Alt+T 生成try catch 或者 Alt+enter CTRL+ALT+T 把选中的代码放在 TRY{} IF{} ELSE{} 里 Ctrl + O 重写方法 Ctrl + I 实现方法 Ctr+shift+U 大小写转化 ALT+回车 导入包,自动修正 ALT+/ 代码提示 CTRL+J 自动代码 Ctrl+Shift+J，整合两行为一行 CTRL+空格 代码提示 CTRL+SHIFT+SPACE 自动补全代码 CTRL+ALT+L 格式化代码 CTRL+ALT+I 自动缩进 CTRL+ALT+O 优化导入的类和包 ALT+INSERT 生成代码(如GET,SET方法,构造函数等) CTRL+E 最近更改的代码 CTRL+ALT+SPACE 类名或接口名提示 CTRL+P 方法参数提示 CTRL+Q，可以看到当前方法的声明 Shift+F6 重构-重命名 (包、类、方法、变量、甚至注释等) Ctrl+Alt+V 提取变量 查询快捷键 Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 CTRL+ALT+ left/right 前后导航编辑过的地方 ALT+7 靠左窗口显示当前文件的结构 Ctrl+F12 浮动显示当前文件的结构 ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 CTRL+ALT+F7 找到你的函数或者变量或者类的所有引用到的地方 Ctrl+Shift+Alt+N 查找类中的方法或变量 双击SHIFT 在项目的所有目录查找文件 Ctrl+N 查找类 Ctrl+Shift+N 查找文件 CTRL+G 定位行 CTRL+F 在当前窗口查找文本 CTRL+SHIFT+F 在指定窗口查找文本 CTRL+R 在 当前窗口替换文本 CTRL+SHIFT+R 在指定窗口替换文本 ALT+SHIFT+C 查找修改的文件 CTRL+E 最近打开的文件 F3 向下查找关键字出现位置 SHIFT+F3 向上一个关键字出现位置 选中文本，按Alt+F3 ，高亮相同文本，F3逐个往下查找相同文本 F4 查找变量来源 CTRL+SHIFT+O 弹出显示查找内容 Ctrl+W 选中代码，连续按会有其他效果 F2 或Shift+F2 高亮错误或警告快速定位 Ctrl+Up/Down 光标跳转到第一行或最后一行下 Ctrl+B 快速打开光标处的类或方法 CTRL+ALT+B 找所有的子类 CTRL+SHIFT+B 找变量的类 Ctrl+Shift+上下键 上下移动代码 Ctrl+Alt+ left/right 返回至上次浏览的位置 Ctrl+X 删除行 Ctrl+D 复制行 Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/…/ ） Ctrl+H 显示类结构图 Ctrl+Q 显示注释文档 Alt+F1 查找代码所在位置 Alt+1 快速打开或隐藏工程面板 Alt+ left/right 切换代码视图 ALT+ ↑/↓ 在方法间快速移动定位 CTRL+ALT+ left/right 前后导航编辑过的地方 Ctrl＋Shift＋Backspace可以跳转到上次编辑的地 Alt+6 查找TODO 其他快捷键 SHIFT+ENTER 另起一行 CTRL+Z 倒退(撤销) CTRL+SHIFT+Z 向前(取消撤销) CTRL+ALT+F12 资源管理器打开文件夹 ALT+F1 查找文件所在目录位置 SHIFT+ALT+INSERT 竖编辑模式 CTRL+F4 关闭当前窗口 Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） 调试快捷键其实常用的 就是F8 F7 F9 最值得一提的 就是Drop Frame 可以让运行过的代码从头再来 alt+F8 debug时选中查看值 Alt+Shift+F9，选择 Debug Alt+Shift+F10，选择 Run Ctrl+Shift+F9，编译 Ctrl+Shift+F8，查看断点 F7，步入 Shift+F7，智能步入 Alt+Shift+F7，强制步入 F8，步过 Shift+F8，步出 Alt+Shift+F8，强制步过 Alt+F9，运行至光标处 Ctrl+Alt+F9，强制运行至光标处 F9，恢复程序 Alt+F10，定位到断点 重构 Ctrl+Alt+Shift+T，弹出重构菜单 Shift+F6，重命名 F6，移动 F5，复制 Alt+Delete，安全删除 Ctrl+Alt+N，内联","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"}],"tags":[]},{"title":"algorism","slug":"软件开发/algorism","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:18:41.179Z","comments":true,"path":"passages/软件开发/algorism/","link":"","permalink":"http://yoursite.com/passages/软件开发/algorism/","excerpt":"","text":"二叉查找树二叉查找树也称为有序二叉查找树,满足二叉查找树的一般性质,是指一棵空树具有如下性质: 任意节点左子树不为空,则左子树的值均小于根节点的值. 任意节点右子树不为空,则右子树的值均大于于根节点的值. 任意节点的左右子树也分别是二叉查找树. 某些情况,二叉查找树会退化成一个有n个节点的线性链 AVL树AVL树是带有平衡条件的二叉查找树,一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡,左右子树树高不超过1,和红黑树相比,它是严格的平衡二叉树,平衡条件必须满足(所有节点的左右子树高度差不超过1).不管我们是执行插入还是删除操作,只要不满足上面的条件,就要通过旋转来保持平衡,而旋转是非常耗时的,由此我们可以知道AVL树适合用于插入删除次数比较少，但查找多的情况。 B+树B+树是B-树的变体，也是一种多路搜索树： 1.其定义基本与B-树同，除了： 2.非叶子结点的子树指针与关键字个数相同； 3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树 （B-树是开区间）； 5.为所有叶子结点增加一个链指针； 6.所有关键字都在叶子结点出现； B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点； B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中； B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中； B/B+树是为了磁盘或其它存储设备而设计的一种平衡多路查找树(相对于二叉,B树每个内节点有多个分支),与红黑树相比,在相同的的节点的情况下,一颗B/B+树的高度远远小于红黑树的高度(在下面B/B+树的性能分析中会提到).B/B+树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成,而CPU的速度非常快,所以B树的操作效率取决于访问磁盘的次数,关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少 B+树是应文件系统所需而产生的一种B树的变形树(文件的目录一级一级索引,只有最底层的叶子节点(文件)保存数据.),非叶子节点只保存索引,不保存实际的数据,数据都保存在叶子节点中 红黑树红黑树（Red-Black Tree）是二叉搜索树（Binary Search Tree）的一种改进。我们知道二叉搜索树在最坏的情况下可能会变成一个链表（当所有节点按从小到大的顺序依次插入后）。而红黑树在每一次插入或删除节点之后都会花O（log N）的时间来对树的结构作修改，以保持树的平衡。也就是说，红黑树的查找方法与二叉搜索树完全一样；插入和删除节点的的方法前半部分节与二叉搜索树完全一样，而后半部分添加了一些修改树的结构的操作。 红黑树确保没有一条路径会比其它路径长出两倍.它是一种弱平衡二叉树(由于是若平衡,可以推出,相同的节点情况下,AVL树的高度低于红黑树),相对于要求严格的AVL树来说,它的旋转次数变少,所以对于搜索,插入,删除操作多的情况下,我们就用红黑树 红黑树的每个节点上的属性除了有一个key、3个指针：parent、lchild、rchild以外，还多了一个属性：color。它只能是两种颜色：红或黑。而红黑树除了具有二叉搜索树的所有性质之外，还具有以下4点性质： 根节点是黑色的。 空节点是黑色的（红黑树中，根节点的parent以及所有叶节点lchild、rchild都不指向NULL，而是指向一个定义好的空节点）。 红色节点的父、左子、右子节点都是黑色。 在任何一棵子树中，每一条从根节点向下走到空节点的路径上包含的黑色节点数量都相同 查找二分查找1234567891011121314151617181920212223242526272829303132import java.util.Scanner;/* * 顺序查找 */public class SequelSearch &#123;public static void main(String[] arg) &#123; int[] a=&#123;4,6,2,8,1,9,0,3&#125;; Scanner input=new Scanner(System.in); System.out.println(\"请输入你要查找的数：\"); //存放控制台输入的语句 int num=input.nextInt(); //调用searc()方法，将返回值保存在result中 int result=search(a, num); if(result==-1)&#123; System.out.println(\"你输入的数不存在与数组中。\"); &#125; else System.out.println(\"你输入的数字存在，在数组中的位置是第：\"+(result+1)+\"个\");&#125;public static int search(int[] a, int num) &#123; for(int i = 0; i &lt; a.length; i++) &#123; if(a[i] == num)&#123;//如果数据存在 return i;//返回数据所在的下标，也就是位置 &#125; &#125; return -1;//不存在的话返回-1&#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.Scanner;/* * 二分查找 */public class BinarySearch &#123; public static void main(String[] args) &#123; int[] arr=&#123;5,3,6,1,9,8,2,4,7&#125;; //先打印输出原始数组数据 System.out.println(\"原始数组数据如下：\"); for (int n : arr) &#123; System.out.print(n+\" \"); &#125; System.out.println(); //首先对数组进行排序，这里用冒泡排序 for(int i=0;i&lt;arr.length-1;i++)&#123; for(int j=0;j&lt;arr.length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; int temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125; //遍历输出排序好的数组 System.out.println(\"经过冒泡排序后的数组：\"); for(int n:arr)&#123; System.out.print(n+\" \"); &#125; System.out.println();//换行 Scanner input=new Scanner(System.in); System.out.println(\"请输入你要查找的数：\"); int num=input.nextInt(); int result=binarySearch(arr, num); if(result==-1)&#123; System.out.println(\"你要查找的数不存在……\"); &#125; else&#123; System.out.println(\"你要查找的数存在，在数组中的位置是：\"+result); &#125; &#125; //二分查找算法 public static int binarySearch(int[] arr,int num)&#123; int low=0; int upper=arr.length-1; while(low&lt;=upper)&#123; int mid=(upper+low)/2; if(arr[mid]&lt;num)&#123; low=mid+1; &#125; else if(arr[mid]&gt;num)&#123; upper=mid-1; &#125; else return mid; &#125; return -1; &#125;&#125; 排序选择初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕 123456789101112131415public void selectSort(int[]a)&#123; int len=a.length; for(int i=0;i&lt;len;i++)&#123;//循环次数 int value=a[i]; int position=i; for(int j=i+1;j&lt;len;j++)&#123;//找到最小的值和位置 if(a[j]&lt;value)&#123; value=a[j]; position=j; &#125; &#125; a[position]=a[i];//进行交换 a[i]=value; &#125; &#125; 冒泡它重复地走访过要排序的元素，依次比较相邻两个元素，如果他们的顺序错误就把他们调换过来，直到没有元素再需要交换，排序完成。这个算法的名字由来是因为越小(或越大)的元素会经由交换慢慢“浮”到数列的顶端 123456789101112public void bubbleSort(int []a)&#123; int len=a.length; for(int i=0;i&lt;len;i++)&#123; for(int j=0;j&lt;len-i-1;j++)&#123;//注意第二重循环的条件 if(a[j]&gt;a[j+1])&#123; int temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; &#125; &#125; &#125; &#125; 插入对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入 插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择 12345678910111213public void insertSort(int [] a)&#123; int len=a.length;//单独把数组长度拿出来，提高效率 int insertNum;//要插入的数 for(int i=1;i&lt;len;i++)&#123;//因为第一次不用，所以从1开始 insertNum=a[i]; int j=i-1;//序列元素个数 while(j&gt;=0&amp;&amp;a[j]&gt;insertNum)&#123;//从后往前循环，将大于insertNum的数向后移动 a[j+1]=a[j];//元素向后移动 j--; &#125; a[j+1]=insertNum;//找到位置，插入当前元素 &#125; &#125; 希尔排序针对直接插入排序的下效率问题，有人对次进行了改进与升级，这就是现在的希尔排序。希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位 1234567891011121314151617181920public void sheelSort(int [] a)&#123; int len=a.length;//单独把数组长度拿出来，提高效率 while(len!=0)&#123; len=len/2; for(int i=0;i&lt;len;i++)&#123;//分组 for(int j=i+len;j&lt;a.length;j+=len)&#123;//元素从第二个开始 int k=j-len;//k为有序序列最后一位的位数 int temp=a[j];//要插入的元素 /*for(;k&gt;=0&amp;&amp;temp&lt;a[k];k-=len)&#123; a[k+len]=a[k]; &#125;*/ while(k&gt;=0&amp;&amp;temp&lt;a[k])&#123;//从后往前遍历 a[k+len]=a[k]; k-=len;//向后移动len位 &#125; a[k+len]=temp; &#125; &#125; &#125; &#125; 快速在平均状况下，排序n个元素要O(nlogn)次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他O(nlogn)算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列 1234567891011121314151617181920212223242526272829public void quickSort(int[]a,int start,int end)&#123; if(start&lt;end)&#123; int baseNum=a[start];//选基准值 int midNum;//记录中间值 int i=start; int j=end; do&#123; while((a[i]&lt;baseNum)&amp;&amp;i&lt;end)&#123; i++; &#125; while((a[j]&gt;baseNum)&amp;&amp;j&gt;start)&#123; j--; &#125; if(i&lt;=j)&#123; midNum=a[i]; a[i]=a[j]; a[j]=midNum; i++; j--; &#125; &#125;while(i&lt;=j); if(start&lt;j)&#123; quickSort(a,start,j); &#125; if(end&gt;i)&#123; quickSort(a,i,end); &#125; &#125; &#125; 归并归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn) 归并排序的实现分为递归实现与非递归(迭代)实现。递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题 1234567891011121314151617181920212223242526272829303132333435363738public void mergeSort(int[] a, int left, int right) &#123; int t = 1;// 每组元素个数 int size = right - left + 1; while (t &lt; size) &#123; int s = t;// 本次循环每组元素个数 t = 2 * s; int i = left; while (i + (t - 1) &lt; size) &#123; merge(a, i, i + (s - 1), i + (t - 1)); i += t; &#125; if (i + (s - 1) &lt; right) merge(a, i, i + (s - 1), right); &#125; &#125; private static void merge(int[] data, int p, int q, int r) &#123; int[] B = new int[data.length]; int s = p; int t = q + 1; int k = p; while (s &lt;= q &amp;&amp; t &lt;= r) &#123; if (data[s] &lt;= data[t]) &#123; B[k] = data[s]; s++; &#125; else &#123; B[k] = data[t]; t++; &#125; k++; &#125; if (s == q + 1) B[k++] = data[t++]; else B[k++] = data[s++]; for (int i = p; i &lt;= r; i++) data[i] = B[i]; &#125; 堆堆排序是指利用堆这种数据结构所设计的一种选择排序算法。堆是一种近似完全二叉树的结构（通常堆是通过一维数组来实现的），并满足性质：以最大堆（也叫大根堆、大顶堆）为例，其中父结点的值总是大于它的孩子节点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void heapSort(int[] a)&#123; int len=a.length; //循环建堆 for(int i=0;i&lt;len-1;i++)&#123; //建堆 buildMaxHeap(a,len-1-i); //交换堆顶和最后一个元素 swap(a,0,len-1-i); &#125; &#125; //交换方法 private void swap(int[] data, int i, int j) &#123; int tmp=data[i]; data[i]=data[j]; data[j]=tmp; &#125; //对data数组从0到lastIndex建大顶堆 private void buildMaxHeap(int[] data, int lastIndex) &#123; //从lastIndex处节点（最后一个节点）的父节点开始 for(int i=(lastIndex-1)/2;i&gt;=0;i--)&#123; //k保存正在判断的节点 int k=i; //如果当前k节点的子节点存在 while(k*2+1&lt;=lastIndex)&#123; //k节点的左子节点的索引 int biggerIndex=2*k+1; //如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在 if(biggerIndex&lt;lastIndex)&#123; //若果右子节点的值较大 if(data[biggerIndex]&lt;data[biggerIndex+1])&#123; //biggerIndex总是记录较大子节点的索引 biggerIndex++; &#125; &#125; //如果k节点的值小于其较大的子节点的值 if(data[k]&lt;data[biggerIndex])&#123; //交换他们 swap(data,k,biggerIndex); //将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值 k=biggerIndex; &#125;else&#123; break; &#125; &#125; &#125; &#125; 桶排序基数用于大量数，很长的数进行排序时。 将所有的数的个位数取出，按照个位数进行排序，构成一个序列。 将新构成的所有的数的十位数取出，按照十位数进行排序，构成一个序列。 123456789101112131415161718192021222324252627282930313233343536373839404142public void baseSort(int[] a) &#123; //首先确定排序的趟数; int max = a[0]; for (int i = 1; i &lt; a.length; i++) &#123; if (a[i] &gt; max) &#123; max = a[i]; &#125; &#125; int time = 0; //判断位数; while (max &gt; 0) &#123; max /= 10; time++; &#125; //建立10个队列; List&lt;ArrayList&lt;Integer&gt;&gt; queue = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; ArrayList&lt;Integer&gt; queue1 = new ArrayList&lt;Integer&gt;(); queue.add(queue1); &#125; //进行time次分配和收集; for (int i = 0; i &lt; time; i++) &#123; //分配数组元素; for (int j = 0; j &lt; a.length; j++) &#123; //得到数字的第time+1位数; int x = a[j] % (int) Math.pow(10, i + 1) / (int) Math.pow(10, i); ArrayList&lt;Integer&gt; queue2 = queue.get(x); queue2.add(a[j]); queue.set(x, queue2); &#125; int count = 0;//元素计数器; //收集队列元素; for (int k = 0; k &lt; 10; k++) &#123; while (queue.get(k).size() &gt; 0) &#123; ArrayList&lt;Integer&gt; queue3 = queue.get(k); a[count] = queue3.get(0); queue3.remove(0); count++; &#125; &#125; &#125; &#125; 8.总结：一、稳定性: 稳定：冒泡排序、插入排序、归并排序和基数排序 不稳定：选择排序、快速排序、希尔排序、堆排序 二、平均时间复杂度 O(n^2):直接插入排序，简单选择排序，冒泡排序。 在数据规模较小时（9W内），直接插入排序，简单选择排序差不多。当数据较大时，冒泡排序算法的时间代价最高。性能为O(n^2)的算法基本上是相邻元素进行比较，基本上都是稳定的。 O(nlogn):快速排序，归并排序，希尔排序，堆排序。 其中，快排是最好的， 其次是归并和希尔，堆排序在数据量很大时效果明显。 三、排序算法的选择 1.数据规模较小 （1）待排序列基本序的情况下，可以选择直接插入排序； （2）对稳定性不作要求宜用简单选择排序，对稳定性有要求宜用插入或冒泡 2.数据规模不是很大 （1）完全可以用内存空间，序列杂乱无序，对稳定性没有要求，快速排序，此时要付出log（N）的额外空间。 （2）序列本身可能有序，对稳定性有要求，空间允许下，宜用归并排序 3.数据规模很大 （1）对稳定性有求，则可考虑归并排序。 （2）对稳定性没要求，宜用堆排序 4.序列初始基本有序（正序），宜用直接插入，冒泡 高级算法贪婪回溯减枝递归将原问题分解为若干个规模较小但类似于原问题的子问题（Divide），「递归」的求解这些子问题（Conquer），然后再合并这些子问题的解来建立原问题的解。 因为在求解大问题时，需要递归的求小问题，因此一般用「递归」的方法实现，即自顶向下。 动态规划动态规划其实和分治策略是类似的，也是将一个原问题分解为若干个规模较小的子问题，递归的求解这些子问题，然后合并子问题的解得到原问题的解。区别在于这些子问题会有重叠，一个子问题在求解后，可能会再次求解，于是我们想到将这些子问题的解存储起来，当下次再次求解这个子问题时，直接拿过来就是。其实就是说，动态规划所解决的问题是分治策略所解决问题的一个子集，只是这个子集更适合用动态规划来解决从而得到更小的运行时间。即用动态规划能解决的问题分治策略肯定能解决，只是运行时间长了。因此，分治策略一般用来解决子问题相互对立的问题，称为标准分治，而动态规划用来解决子问题重叠的问题。 与「分治策略」「动态规划」概念接近的还有「贪心算法」「回溯算法」 将「动态规划」的概念关键点抽离出来描述就是这样的：1.动态规划法试图只解决每个子问题一次2.一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"}],"tags":[]},{"title":"Tech图谱","slug":"软件开发/Tech图谱","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:18:27.733Z","comments":true,"path":"passages/软件开发/Tech图谱/","link":"","permalink":"http://yoursite.com/passages/软件开发/Tech图谱/","excerpt":"","text":"[TOC] 软件开发语言PythonJava集合对象 java各种集合对象的实现原理 熟练使用各种数据结构和算法，数组、哈希、链表、排序树, 要么是时间换空间要么是空间换时间 NIO + Netty高并发编程 io nio 网络编程的BIO、伪异步IO模式、NIO、AIO编程模型讲解 通信框架Netty实战部署以及Netty服务讲解 Netty的TCP粘包拆包、序列化以及自定义协议 Netty实战数据通信以及集群心跳检测服务 序列化系统之间通过网络传输，或者存储到文件时，肯定只有一种格式，就是字符串。要将复杂的数据结构与字符串之间进行转换，就需要用到序列化。 JSON和XML，JSON和XML只能用于传递数据 protobuf、thrift， protobuf与thrift还可以用来做RPC协议 线程、锁基础知识 java多线程同步异步 池技术，对象池，连接池，线程池 深入剖析volatile、AQS、synchronized、Lock、AtomicX关键字 深入剖析java concurrent 包 阻塞队列、ConcurrentMap 深入剖析java concurrent包 闭锁、栅栏、交换机、信号量 深入剖析java concurrent 包 执行器服务、线程池、Jvm调优 JVM jvm虚拟机原理、调优 “直接内存”的特点 java反射技术，java字节码技术; 通信协议 熟悉http协议，尤其是http头，session和cookie的生命周期以及它们之间的关联。 熟悉tcp协议，创建连接三次握手和断开连接四次握手的整个过程 RPC方式 RESTFul， 对性能等参数有个量化的了解 安全设计 比如MySQL和PostgreSQL的协议都有安全的设计。 加密/签名技术：常见如truecrypt、openssl、gnu pg、sha1、md5、scrypt等，了解各种加密/签名技术的安全性，字长等， OAuth：与其他网站联合认证的方式，有多种，分别了解。 用户认证：一开始就应该花大精力设计好用户认证系统，包括不要明文存储密码，包括严格限制Cookie和Session的使用，包括用户认证信息的缓存等。如果需要设计一个长期运行的大系统，强烈建议使用签名来保证Cookie的不可伪造，同时常见信息直接存储Cookie，这样可以避免每次Request都访问数据库。 Web开发HTTP、Servlet HTTP协议，Servlet模型组件 Servlet编程模型，多线程，线程池，ThreadLocal Stateless设计 API设计设计Restfull API 序列化/JSON序列化原理以及定制序列化 框架SpringSpring Framework IOC原理 单例/原型模式，工厂模式 AOP、装饰器模式 其他常用模式，适配器、观察者、策略，模板方法 Spring JDBC. 声明式事物/事物嵌套原理 Spring BootSpring Boot + Spring MVC 分布式架构设计服务治理微服务原理，分布式服务治理，服务注册与发现 配置中心配置中心原理/优点/配置变更 网管设计网关模式/原理 声明式服务调用Feign+Hystrix+客户端路由+服务降级 异步驱动设计，消息服务: JMS, RocketMQ, Kafka异步处理、缓解服务器压力，解藕系统 消息系统概念，模型，Queue, Topic JMS RocketMQ Kafka 消息幂等性设计幂等性原理，实现方式，重试机制， 分布式架构JVM监控与JMXSpring集成JMX,实现MBean，使用JConsole 流量控制设计限流设计/熔断设计/服务降级/Nginx反向代理+limit限速 边缘计算模式什么是边缘计算，使用它实现秒杀业务 消息中间件: RocketMQ, Kafka异步处理、缓解服务器压力，解藕系统 RocketMQ Kafka 搜索引擎相关技术知识: ElasticSearch, Logstash, Kibana高并发+高可用+微服务分布式互联网架构实战 Nginx Redis Transaction事务、pipeline以及优化和Sentinel高可用集群 Nginx分离zuul+Redis实现token网关登录认证 系统集群、负载均衡、反向代理、动静分离，网站静态化 。 Spark Storm分布式实时存储与流式计算数据存储关系式数据库 Create、Query、Delete、Update操作外。还需要能自行建立索引 数据库的平行扩展 如何进行性能调试。以及了解常见查询操作的性能级别，常见的查询性能瓶颈点 mysql，对它基本的参数优化，慢查询日志分析，主从复制的配置 配置Spring多数据源，通过Annotation+AOP实现一键切换 MySql分页，以及常见调优原理 分布式事务，补偿式设计 Hadoop Hive 分布式大数据存储nfs, fastdfs, tfs, Hadoop 了解他们的优缺点，适用场景 。 MongoDB分布式缓存技术memcached,redis把硬盘上的内容放到内存里来提速，算法一致性hash 机器学习、人工智能PythonTensorFlowServer如果一开始就将静态文件与主站内容混杂在一起，未来就是个灾难，具体参考CDN的应用方式 ApachenginxTomcat, Jetty源代码阅读zookeeper、spring cloud、redis、kafka、elasticsearch 业务要求，性能要求，具备可扩展性（scalability），可拓展性（extendability），前后兼容性等 博客/论坛：博客和论坛有很多，并且各个网站也都很常用，了解下其原理，最好自己写个练习下。 微博：Twitter/weibo等，涉及到大量的联表查询，需要用多种办法来优化查询性能。 云计算：云计算的几个常见平台的服务提供方式，如Google和Amazon的，如果精力够用最好了解下OpenStack等搭建私有云的方式，总的来说，这是未来的大方向。 视频播放：在网页上播放视频的技术，包括基于Flash和HTML5的，各种浏览器对视频的兼容性等，了解通过ffmpeg将一个视频转换为标准mp4(HTML5可以播放的)的方式和参数 CDN：了解应用CDN的方式，包括拆分静态文件的域名，静态文件版本化，Cookie拆分等相关技术 大型网站系统与Java中间件实践个人评价：这本书比上面两本要深一点，主要是关于一些中间件的设计。这里的并不是简单的教你怎么使用一些中间件，而是根据实际问题来演变怎么设计一个合适的中间件，适合有一定相关工作经验的人翻阅。可以买来看看，写的很不错4 大型网站技术架构核心原理与案例分析个人评价：如果要学习分布式，这本书基本把分布式的知识讲了个边（概论），书本篇幅不大，但是内容特别精炼，比如网站架构演变，高可用，高性能，伸缩性等等。此书的作者和下面所要陈述的两本书的作者也都是阿里系的。个人觉得学习分布式或者说大型网站架构可以先看看这本书来个全局统筹，然后再看《大型分布式网站架构设计与实践》，最后又实践经验了再看《大型网站系统与Java中间件实践》。 评分：5分 深入理解Java虚拟机个人评价：此书也甚为经典，博主看了不下5遍。此书的作者是国内的，在市场上面滥竽充数横行的今天，算得上是上上品。书中对JVM进行了详细深刻的说明，是学习JVM原理必备书籍。必须强烈推荐。 评分：5分 Java并发编程的艺术个人评价：此书是阿里人也的书，一共有三个作者，第一作者是方腾飞，也是并发编程网的创始人，如果在网上搜索并发编程的相关知识，或多或少的会链接到他的网站上去。此书开篇就很有深度，比如偏向锁、自旋锁、轻量级锁等。前面6章都很不错，理解的非常深入，很底层，后面开始有点撑版面的，尤其是Atomic这一章出现了严重的错误，有点凤头鸡尾的感觉。但是总体上来看还是很不错的，非常推荐买来看看。 评分：4分 Java并发编程实战个人评价：国外人写的书，这是翻译版，原书《Java Concurrency in Practice》,堪称并发中的经典书籍。翻译的也很好，书本内容偏理论，基本知识点都能够概括。当然这本书还是需要有一点的并发基础的人适合看的，零基础的看起来会有点吃力。此书可以看好多遍，没看一遍都会有新的认识。 评分：5分。","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"}],"tags":[]},{"title":"git","slug":"软件开发/git","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:18:35.571Z","comments":true,"path":"passages/软件开发/git/","link":"","permalink":"http://yoursite.com/passages/软件开发/git/","excerpt":"","text":"GitConnect Github1.创建SSH Key。 ssh-keygen -t rsa -C “oliversegal@163.com“ cat /home/oliver/.ssh/id_rsa.pub 2.接下来到GitHub上，打开“Account settings”–“SSH Keys”页面，然后点击“Add SSH Key”，填上Title（随意写），在Key文本框里粘贴 id_rsa.pub文件里的全部内容 3.验证是否成功，在git bash里输入下面的命令 `$ ssh -T git@github.com` 4.下面开始设置username和email，因为github每次commit都会记录他们 12$ git config --global user.name \"oliver\"//你的GitHub登陆名$ git config --global user.email \"oliversegal@163.com\"//你的GitHub注册邮箱 git init在本地新建一个repo,进入一个项目目录,执行git init,会初始化一个repo,并在当前文件夹下创建一个.git文件夹. git clone 获取一个url对应的远程Git repo, 创建一个local copy. 一般的格式是git clone [url]. clone下来的repo会以url最后一个斜线后面的名称命名,创建一个文件夹,如果想要指定特定的名称,可以git clone [url] newname指定. git clone git@github.com:oliversegal6/CloudCore.git git status查询repo的状态. git status -s: -s表示short, -s的输出标记会有两列,第一列是对staging区域而言,第二列是对working目录而言. git logshow commit history of a branch. git log --oneline --number: 每条log只显示一行,显示number条. git log --oneline --graph:可以图形化地表示出分支合并历史. git log branchname可以显示特定分支的log. git log --oneline branch1 ^branch2,可以查看在分支1,却不在分支2中的提交.^表示排除这个分支(Window下可能要给^branch2加上引号). git log --decorate会显示出tag信息. git log --author=[author name] 可以指定作者的提交历史. git log --since --before --until --after 根据提交时间筛选log. --no-merges可以将merge的commits排除在外. git log --grep 根据commit信息过滤log: git log --grep=keywords 默认情况下, git log --grep --author是OR的关系,即满足一条即被返回,如果你想让它们是AND的关系,可以加上--all-match的option. git log -S: filter by introduced diff. 比如: git log -SmethodName (注意S和后面的词之间没有等号分隔). git log -p: show patch introduced at each commit. 每一个提交都是一个快照(snapshot),Git会把每次提交的diff计算出来,作为一个patch显示给你看. 另一种方法是git show [SHA]. git log --stat: show diffstat of changes introduced at each commit. 同样是用来看改动的相对信息的,--stat比-p的输出更简单一些. git add在提交之前,Git有一个暂存区(staging area),可以放入新添加的文件或者加入新的改动. commit时提交的改动是上一次加入到staging area中的改动,而不是我们disk上的改动. git add . 会递归地添加当前工作目录中的所有文件. git diff不加参数的git diff: show diff of unstaged changes. 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容. 若要看已经暂存起来的文件和上次提交时的快照之间的差异,可以用: git diff --cached 命令. show diff of staged changes. (Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的). git diff HEAD show diff of all staged or unstated changes. 也即比较woking directory和上次提交之间所有的改动. 如果想看自从某个版本之后都改动了什么,可以用: git diff [version tag] 跟log命令一样,diff也可以加上--stat参数来简化输出. git diff [branchA] [branchB]可以用来比较两个分支. 它实际上会返回一个由A到B的patch,不是我们想要的结果. 一般我们想要的结果是两个分支分开以后各自的改动都是什么,是由命令: git diff [branchA]…[branchB]给出的. 实际上它是:git diff $(git merge-base [branchA] [branchB]) [branchB]的结果. git commit提交已经被add进来的改动. git commit -m “the commit message&quot; git commit -a 会先把所有已经track的文件的改动add进来,然后提交(有点像svn的一次提交,不用先暂存). 对于没有track的文件,还是需要git add一下. git commit --amend 增补提交. 会使用与当前提交节点相同的父节点进行一次新的提交,旧的提交将会被取消. git resetundo changes and commits. 这里的HEAD关键字指的是当前分支最末梢最新的一个提交.也就是版本库中该分支上的最新版本. git reset HEAD: unstage files from index and reset pointer to HEAD 这个命令用来把不小心add进去的文件从staged状态取出来,可以单独针对某一个文件操作: git reset HEAD - - filename, 这个- - 也可以不加. git reset --soft move HEAD to specific commit reference, index and staging are untouched. git reset --hard unstage files AND undo any changes in the working directory since last commit. 使用git reset —hard HEAD进行reset,即上次提交之后,所有staged的改动和工作目录的改动都会消失,还原到上次提交的状态. 这里的HEAD可以被写成任何一次提交的SHA-1. 不带soft和hard参数的git reset,实际上带的是默认参数mixed. 总结: git reset --mixed id,是将git的HEAD变了(也就是提交记录变了),但文件并没有改变，(也就是working tree并没有改变). 取消了commit和add的内容. git reset --soft id. 实际上，是git reset –mixed id 后,又做了一次git add.即取消了commit的内容. git reset --hard id.是将git的HEAD变了,文件也变了. 按改动范围排序如下: soft (commit) &lt; mixed (commit + add) &lt; hard (commit + add + local working) git revert反转撤销提交.只要把出错的提交(commit)的名字(reference)作为参数传给命令就可以了. git revert HEAD: 撤销最近的一个提交. git revert会创建一个反向的新提交,可以通过参数-n来告诉Git先不要提交. git rmgit rm file: 从staging区移除文件,同时也移除出工作目录. git rm --cached: 从staging区移除文件,但留在工作目录中. git rm --cached从功能上等同于git reset HEAD,清除了缓存区,但不动工作目录树. git cleangit clean是从工作目录中移除没有track的文件. 通常的参数是git clean -df: -d表示同时移除目录,-f表示force,因为在git的配置文件中, clean.requireForce=true,如果不加-f,clean将会拒绝执行. git mvgit rm - - cached orig; mv orig new; git add new git stash把当前的改动压入一个栈. git stash将会把当前目录和index中的所有改动(但不包括未track的文件)压入一个栈,然后留给你一个clean的工作状态,即处于上一次最新提交处. git stash list会显示这个栈的list. git stash apply:取出stash中的上一个项目(stash@{0}),并且应用于当前的工作目录. 也可以指定别的项目,比如git stash apply stash@{1}. 如果你在应用stash中项目的同时想要删除它,可以用git stash pop 删除stash中的项目: git stash drop: 删除上一个,也可指定参数删除指定的一个项目. git stash clear: 删除所有项目. git branchgit branch可以用来列出分支,创建分支和删除分支. git branch -v可以看见每一个分支的最后一次提交. git branch: 列出本地所有分支,当前分支会被星号标示出. git branch (branchname): 创建一个新的分支(当你用这种方式创建分支的时候,分支是基于你的上一次提交建立的). git branch -d (branchname): 删除一个分支. 删除remote的分支: git push (remote-name) :(branch-name): delete a remote branch. 这个是因为完整的命令形式是: git push remote-name local-branch:remote-branch 而这里local-branch的部分为空,就意味着删除了remote-branch git checkout git checkout (branchname) 切换到一个分支. git checkout -b (branchname): 创建并切换到新的分支. 这个命令是将git branch newbranch和git checkout newbranch合在一起的结果. checkout还有另一个作用:替换本地改动: git checkout – 此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件.已添加到暂存区的改动以及新文件都不会受到影响. 注意:git checkout filename会删除该文件中所有没有暂存和提交的改动,这个操作是不可逆的. git merge把一个分支merge进当前的分支. git merge [alias]/[branch] 把远程分支merge到当前分支. 如果出现冲突,需要手动修改,可以用git mergetool. 解决冲突的时候可以用到git diff,解决完之后用git add添加,即表示冲突已经被resolved. git tagtag a point in history as import. 会在一个提交上建立永久性的书签,通常是发布一个release版本或者ship了什么东西之后加tag. 比如: git tag v1.0 git tag -a v1.0, -a参数会允许你添加一些信息,即make an annotated tag. 当你运行git tag -a命令的时候,Git会打开一个编辑器让你输入tag信息. 我们可以利用commit SHA来给一个过去的提交打tag: git tag -a v0.9 XXXX push的时候是不包含tag的,如果想包含,可以在push时加上--tags参数. fetch的时候,branch HEAD可以reach的tags是自动被fetch下来的, tags that aren’t reachable from branch heads will be skipped.如果想确保所有的tags都被包含进来,需要加上--tags选项. git remotelist, add and delete remote repository aliases. 因为不需要每次都用完整的url,所以Git为每一个remote repo的url都建立一个别名,然后用git remote来管理这个list. git remote: 列出remote aliases. 如果你clone一个project,Git会自动将原来的url添加进来,别名就叫做:origin. git remote -v:可以看见每一个别名对应的实际url. git remote add [alias] [url]: 添加一个新的remote repo. git remote rm [alias]: 删除一个存在的remote alias. git remote rename [old-alias] [new-alias]: 重命名. git remote set-url [alias] [url]:更新url. 可以加上—push和fetch参数,为同一个别名set不同的存取地址. git fetchdownload new branches and data from a remote repository. 可以git fetch [alias]取某一个远程repo,也可以git fetch --all取到全部repo fetch将会取到所有你本地没有的数据,所有取下来的分支可以被叫做remote branches,它们和本地分支一样(可以看diff,log等,也可以merge到其他分支),但是Git不允许你checkout到它们. git pullfetch from a remote repo and try to merge into the current branch. pull == fetch + merge FETCH_HEAD git pull会首先执行git fetch,然后执行git merge,把取来的分支的head merge到当前分支.这个merge操作会产生一个新的commit. 如果使用--rebase参数,它会执行git rebase来取代原来的git merge. git rebase--rebase不会产生合并的提交,它会将本地的所有提交临时保存为补丁(patch),放在”.git/rebase”目录中,然后将当前分支更新到最新的分支尖端,最后把保存的补丁应用到分支上. rebase的过程中,也许会出现冲突,Git会停止rebase并让你解决冲突,在解决完冲突之后,用git add去更新这些内容,然后无需执行commit,只需要: git rebase --continue就会继续打余下的补丁. git rebase --abort将会终止rebase,当前分支将会回到rebase之前的状态. git pushpush your new branches and data to a remote repository. git push [alias] [branch] 将会把当前分支merge到alias上的[branch]分支.如果分支已经存在,将会更新,如果不存在,将会添加这个分支. 如果有多个人向同一个remote repo push代码, Git会首先在你试图push的分支上运行git log,检查它的历史中是否能看到server上的branch现在的tip,如果本地历史中不能看到server的tip,说明本地的代码不是最新的,Git会拒绝你的push,让你先fetch,merge,之后再push,这样就保证了所有人的改动都会被考虑进来. git refloggit reflog是对reflog进行管理的命令,reflog是git用来记录引用变化的一种机制,比如记录分支的变化或者是HEAD引用的变化. 当git reflog不指定引用的时候,默认列出HEAD的reflog. HEAD@{0}代表HEAD当前的值,HEAD@{3}代表HEAD在3次变化之前的值. git会将变化记录到HEAD对应的reflog文件中,其路径为.git/logs/HEAD, 分支的reflog文件都放在.git/logs/refs目录下的子目录中.","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"}],"tags":[]},{"title":"总结","slug":"软件开发/总结","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:18:24.106Z","comments":true,"path":"passages/软件开发/总结/","link":"","permalink":"http://yoursite.com/passages/软件开发/总结/","excerpt":"","text":"总结Java 基础，架构，经验，管理，思考总结，技术体系化的掌握 java 基础JVMIO/NIO/AIO多线程集群环境下的并发控制 程序线程间通信 线程并发控制 线程间协调 幂等控制分布式设计Session问题MicroService服务拆分分布式存储垂直，水平拆分读写分离分布式缓存redis 消息中间件kafka 搜索引擎solr 性能调优sofa开源框架mongodb的坑kafka, jms区别大中台共享服务平台体系的优点主要有如下几点： 1、服务可重用。通过松耦合的服务带来业务的复用，不必为不同的前端业务开发各自对应的相同或者类似的服务。例如淘宝和天猫不必各自开都开发一个评价服务。 2、服务被滋养。作者在书中提出了一个观点：服务最不需要“稳定”。一个服务如果一味追求不变，那就是固步自封，就会逼着其他系统去建同样的“轮子”。服务需要被滋养，不停的滋养，只有滋养才能最初仅提供单薄业务功能的服务逐渐成长为企业最为宝贵的IT资产，而服务所需的滋养正是来自新的业务不断的接入。 3、服务助创新。大家都知道创新不是一件容易的事情，因为有些本质上的创新按照传统的开发模式是需要从分析、设计、开发，每一个环节都从0开始的，这样一来就会导致投入成本大，开发周期长，可能等你开发完了，商机已经被别人抢占了，公司领导可能考虑到上述因素就把你这个想法PASS掉了。而共享服务平台中的诸多服务是经过清晰的沉淀，可以通过重新编排、组合，快速的响应市场，达成创新，武侠小说里不常说天下武功，唯快不破嘛。 4、服务敢试错。说到试错，其实试错和创新有着千丝万缕的关系，有时甚至可以划等号，部分试错是会变成创新的。共享服务平台由于具备快速编排、组合服务的能力，可以以较小的成本投入来构建出一个新的前端业务，即使失败了，公司损失也很小。这在传统模式构建的系统中是几乎不可能达成的。 5、服务造BD。如今BIG DATE（大数据）成为近年来互联网和IT行业最为炙手可热的名词，很多企业甚至将互联网转型的期望完全寄托到大数据上，企业纷纷上马大数据项目。但多数项目在落地实施时却很难，主要有两个问题：一是数据分布广、数据模型和标准不统一。需要进行数据层的打通、权限的控制、格式的转换、以及数据的清洗和转换等一系列复杂的工作；二是缺少“数据科学家”。也就是说人件，项目只有强大的软件和硬件支持是远远不够的。更重要的是要有能基于对业务的理解提出对大数据平台需求的专家。此类专家需要懂数据采集、懂数学算法、懂分析、懂预测、懂市场应用…这样的专家对任何企业来说都是难寻的，就算你的公司财大气粗，可以把某某公司的专家挖过来，但他来到另外一个行业，另外一个公司，遇见另外一个全新的系统，由于对你公司的业务和技术熟悉程度较低，还是很难短时间带来效益。而共享服务体系能很好的帮助企业培育出懂业务的专家，这些人员在自身拥有不错的技术功底的前提下，加上对业务熟悉度的不断提升，使之才有希望成为能发挥大数据平台价值的“数据科学专家”。 架构： 保险事业部是将“大中台小前台”架构应用的最好的事业部：大中台小前台详细介绍见：https://blog.csdn.net/qq_37961793/article/details/78962001 系统主要分为以下几层：业务对接层（各种业务的业务系统，也就是小前台），业务对接层的系统分如下几类：场景连接类：对接合作业务的，如飞猪的航旅险，淘宝的订单险运费险等自营类目类：自营的健康险、车险，类似京东平台自营机构直营类：各种类目的保险都有直接机构直接发的产品，类似京东商家直营 核心中台，中台又分为业务平台层和核心层：业务平台层有如下几个系统：承保平台、批改平台、理赔平台、续期续保平台核心层有一些核心服务供业务平台系统使用。核心层主要承载领域建模，业务平台层承载业务流程建模。 现在招人的组就是核心中台组，负责建设中台通用能力，挑战是相当大所以成长空间也巨大，是非常好的坑，目前10个人，预计招到16个；与之相对的就是小前台的几个业务系统开发组对应上面提到的健康险、车险、场景连接等，这些业务组的工作就是将每个业务定制的东西转换一下调中台的业务平台或核心能力，没什么挑战。 对接的业务因为是中台，所以所有的业务都会从经过中台。你如果进来具体做核心中台的哪块到时候再定，聊的时候你也可以自己选你感兴趣的。 各种技术岗位全算上整个技术部是130人左右。","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"}],"tags":[]},{"title":"项目问题","slug":"软件开发/项目问题","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:18:20.073Z","comments":true,"path":"passages/软件开发/项目问题/","link":"","permalink":"http://yoursite.com/passages/软件开发/项目问题/","excerpt":"","text":"项目问题HBase slow put – change max files.EMS slow ack – batch ack EMS messages.Handle large volume of messages – introduce KafkaPermGen Space OOM PermSize小了 ClassLoader使用不当 排查方法： -XX:+TraceClassLoading， btrace Direct buffer memory OOM -XX:MaxDirectMemorySize 只有ByteBuffer.allocateDirect这里有可能抛出 GC友好的代码 限制大小的集合对象； 避免Autobox； 慎用ThreadLocal； 限制提交请求的大小，尤其是批量处理； 限制数据库返回的数据数量； 合理选择数据结构 StackOverflowError线程请求的栈深度大于虚拟机所允许的深度，如递归调用 通过-Xss或-XX:ThreadStackSize设置每个线程栈的大小，默认大小512k （32-bit vm），1024k（64-bit vm）-Xss影响主线程-XX:ThreadStackSize不影响主线程，pd product OutOfMemoryError虚拟机栈动态扩展时无法申请到足够的内存，此种情况相对而言很少出现 数据库不使用索引检查index, 重建静态分析表，没用就使用Hint Kafka消息丢失使用ack机制来保证 log 写错误导致磁盘满多线程CountDownLatch等待子线程结束 高并发引起系统缓慢性能测试，导致数据库读取频繁，把静态数据加载入redis 大量数据高并发处理缓存溢出高频数据变换 合并数据设置时间阈值 批量推送 时间限流 缓存击穿大量请求未缓存数据导致，大量查询落到数据库上，导致性能下降，系统后续请求阻塞，从而拖垮整个系统。多线程高并发请求也可能导致缓存击穿。解决方法： 缓存预加热 缓存不存在数据，值为null filter 隔水舱线程隔离同一application对于独立的功能使用分离的线程池，单个比较慢的功能把线程耗尽，防止线程耗尽 降级限流通过限流和降级来防止大并发导致性能下降，宕机风险。 Cache 2000万数据并发 1000数据库 2200万服务器 20台 大数据高并发 多模块在同一进程 进程隔离，把模块划分到不同进程 线程池隔离，把不同功能划分的不同线程池。 加入缓存，改善性能 缓存击穿解决， 大量并发导致第三方系统崩溃（时间阈值和限流解决）。 高可用隔离超时与重试限流服务降级异步调用幂等设计 集群2台server，80线程计算，限流，timeout，缓存","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"}],"tags":[]},{"title":"nginx","slug":"软件开发/服务器/nginx","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:39:37.344Z","comments":true,"path":"passages/软件开发/服务器/nginx/","link":"","permalink":"http://yoursite.com/passages/软件开发/服务器/nginx/","excerpt":"","text":"server { listen 6200; server_name localhost; location / { root /home/oliver/allbetter; # 这是angular生成的dist文件夹存放的位置 index index.html; access_log /home/oliver/allbetter/proxy.access.log main; try_files $uri $uri/ /index.html; # 注意此句，一定要加上。否则配置的子路由等无法使用 } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } 启动服务：nginx -t nginx -c /etc/nginx/nginx.conf停止服务：nginx -s stop重新加载：nginx -s reload(配置文件被修改后需要执行它) /var/log/nginx/access.log","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"服务器","slug":"软件开发/服务器","permalink":"http://yoursite.com/categories/软件开发/服务器/"}],"tags":[]},{"title":"机器学习AI","slug":"软件开发/机器学习AI/机器学习AI","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:14:04.718Z","comments":true,"path":"passages/软件开发/机器学习AI/机器学习AI/","link":"","permalink":"http://yoursite.com/passages/软件开发/机器学习AI/机器学习AI/","excerpt":"","text":"机器学习，深度学习，AI理论机器学习人工特征，样本提取 基本理论 评价指标 准确，召回，F-score(balance 准确，召回) ROC &amp; AUC（样本不均衡时需要使用） fitting-problem 交叉验证 不是所有数据都拿来训练模型，需要用一部分数据用来做交叉验证，从而来保证模型在新数据下的稳定性。 模型集成 把多模型的结果进行整合 正则化 尽量减少参数，简化模型，而不是更多参数，更复杂的模型。 多分类 结果 准确，召回，F-score 类别，使用场景梯度下降是迭代法的一种,可以用于求解最小二乘问题(线性和非线性都可以), 它是神经网络模型训练最常用的优化算法。在求解机器学习算法的模型参数，即无约束优化问题时，梯度下降（Gradient Descent）是最常采用的方法之一，另一种常用的方法是最小二乘法 有监督学习： 监督学习是使用已知正确答案的示例来训练网络的。 分类：线性、决策树、SVM、KNN ；集成回归：随机森林、Adaboost、GradientBoosting、Bagging、ExtraTrees。回归与分类的区别在于：回归所预测的目标量的取值是连续的（例如房屋的价格）；而分类所预测的目标变量的取值是离散的（例如判断邮件是否为垃圾邮件） 回归：线性、逻辑回归、决策树、SVM、KNN，朴素贝叶斯；集成分类：随机森林、Adaboost、GradientBoosting、Bagging、ExtraTrees 排序 无监督学习： 无监督学习适用于你具有数据集但无标签的情况。无监督学习采用输入集，并尝试查找数据中的模式 聚类：k-means,高斯混合模型， 降维：数据维度高，稀疏性高，需要提取特征降维 压缩感知 半监督学习： 半监督学习在训练阶段结合了大量未标记的数据和少量标签数据。与使用所有标签数据的模型相比，使用训练集的训练模型在训练时可以更为准确，而且训练成本更低 迁移学习： 增强学习： 强化学习是针对你再次没有标注数据集的情况而言的，但你还是有办法来区分是否越来越接近目标 具体算法线性回归，逻辑回归Logistic Regression和Linear Regression的原理是相似的，按照我自己的理解，可以简单的描述为这样的过程： 找一个合适的预测函数（Andrew Ng的公开课中称为hypothesis），一般表示为h函数，该函数就是我们需要找的分类函数，它用来预测输入数据的判断结果。这个过程时非常关键的，需要对数据有一定的了解或分析，知道或者猜测预测函数的“大概”形式，比如是线性函数还是非线性函数。 构造一个Cost函数（损失函数），该函数表示预测的输出（h）与训练数据类别（y）之间的偏差，可以是二者之间的差（h-y）或者是其他的形式。综合考虑所有训练数据的“损失”，将Cost求和或者求平均，记为J(θ)函数，表示所有训练数据预测值与实际类别的偏差。 显然，J(θ)函数的值越小表示预测函数越准确（即h函数越准确），所以这一步需要做的是找到J(θ)函数的最小值。找函数的最小值有不同的方法，Logistic Regression实现时有的是梯度下降法（Gradient Descent）。 梯度下降是迭代法的一种,可以用于求解最小二乘问题(线性和非线性都可以), 它是神经网络模型训练最常用的优化算法。在求解机器学习算法的模型参数，即无约束优化问题时，梯度下降（Gradient Descent）是最常采用的方法之一，另一种常用的方法是最小二乘法. SGD, BGD, MBGD Deep Learning自动特征提取 CNN卷积神经网络 convolution, padding,stride, pooling, activation function ResNet AlexNet 纵览 RNN 常用神经网络： 回归 RNN回归 分类 CNN分类 RNN分类 自编码分类 模型步骤： 导入模块并创建数据 建立模型 定义优化器 激活模型 训练模型 检验模型 可视化结果 相关工具PythonnumpyNumPy是Python语言的一个扩充程序库。支持高级大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。Numpy内部解除了Python的PIL(全局解释器锁),运算效率极好,是大量机器学习框架的基础库 PandasPandas是基于Numpy开发出的,专门用于数据分析的开源Python库 Matplotlab是Python 2D绘图领域的基础套件，它让使用者将数据图形化，并提供多样化的输出格式 sklearn常用的机器学习方法进行了封装，在进行机器学习任务时，只需要简单的调用sklearn里的模块就可以实现大多数机器学习任务。机器学习任务通常包括分类（Classification）和回归（Regression），常用的分类器包括SVM、KNN、贝叶斯、线性回归、逻辑回归、决策树、随机森林、xgboost、GBDT、boosting、神经网络NN。 常见的降维方法包括TF-IDF、主题模型LDA、主成分分析PCA等等 流程可以理解如下： 数据加载和预处理 定义分类器（回归器等等），譬如svc = svm.svc() 用训练集对模型进行训练，只需调用fit方法，svc.fit(X_train, y_train) 用训练好的模型进行预测：y_pred=svc.predict(X_test) 对模型进行性能评估：svc.score(X_test, y_test) TensorFlowTensorFlow可被用于语音识别或图像识别等多项机器学习和深度学习领域, TensorFlow支持CNN、RNN和LSTM算法，这都是目前在Image，Speech和NLP最流行的深度神经网络模型。 kerasKeras是一个高层神经网络API，Keras由纯Python编写而成并基Tensorflow、Theano以及CNTK后端。Keras 为支持快速实验而生，能够把你的idea迅速转换为结果，如果你有如下需求，请选择Keras： 简易和快速的原型设计（keras具有高度模块化，极简，和可扩充特性） 支持CNN和RNN，或二者的结合 无缝CPU和GPU切换 crf++用于NLP技术领域，其在NLP技术领域中主要用于文本标注，并有多种应用场景，例如： 分词（标注字的词位信息，由字构词） 词性标注（标注分词的词性，例如：名词，动词，助词） 命名实体识别（识别人名，地名，机构名，商品名等具有一定内在规律的实体名词） corenlpcoreNLP是斯坦福大学开发的一套关于自然语言处理的工具(toolbox)，使用简单功能强大，有;命名实体识别、词性标注、词语词干化、语句语法树的构造还有指代关系等功","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"机器学习","slug":"软件开发/机器学习","permalink":"http://yoursite.com/categories/软件开发/机器学习/"}],"tags":[]},{"title":"Docker","slug":"软件开发/系统架构/DesignPattern","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:16:13.145Z","comments":true,"path":"passages/软件开发/系统架构/DesignPattern/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/DesignPattern/","excerpt":"","text":"设计模式学习笔记 from : http://www.cnblogs.com/maowang1991/archive/2013/04/15/3023236.html 设计模式的分类12345五种创建者模式 ： 单例模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式七种结构型模式 ： 适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式十一种行为模式 ： 策略模式，模板方法模式，观察者模式，迭代子模式，责任链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式并发型模式 ： Future模式,Master_worker模式,Guarded Suspension模式,不变模式,生产者消费者模式 线程池模式 : HS/HA半同步/半异步模式，L/F领导者跟随者模式 设计模式六大原则123456开闭原则 ： 对扩展开放，修改关闭里氏代换原则 ： 任何基类出现的地方，子类一定可以出现依赖倒置原则 ： 依赖抽象，不依赖具体接口隔离原则 ： 使用多个隔离的接口，而不是单个接口包括所有方法迪米特法则 ： 实体尽量少和其他实体发生相互作用 合成复用原则 ： 尽量使用合成聚合而不是继承 23种设计模式五种创建者模式123456789101. 单例模式 ： JVM中只创建一个实例存在，反复使用,严格单例需要控制线程安全，反序列化创建对象2. 工厂方法模式 普通工厂模式 ： 建立一个工厂类，对实现同一接口的类进行实例创建，多个实例共用一个工厂方法 多个工厂方法模式 ： 对普通工厂改进，每一类实例的创建对应一个工厂方法 静态工厂方法模式 ： 对多个工厂方法模式改进，将方法设置为静态的，不再需要创建工厂实例3. 抽象工厂模式 ： 抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，只需增加新的工厂类，不需要修改原有代码4. 建造者模式 ： 建造者是创建复合对象，工厂模式创建单个产品5. 原型模式 ： 对一个已有对象的复制产生一个和原对象类似的新对象，通过clone 浅复制 ： 基本数据类型的变量会被重新创建，引用类型还是指向原对象 (Object.clone就是浅拷贝) 深复制 ： 基本数据类型和引用类型被重新创建 (写入读出二进制流产生新对象) 七种结构型模式123456789101. 适配器模式 类的适配器模式 ： 接口Targetable拥有和A相同的方法，并有新的适配方法，类Adapter继承A实现Targetable 对象的适配器模式 ： 和类适配器不同的是，持有A的实例而不是继承A 接口的适配器模式 ： 解决有时候并不想实现接口中的所有的方法，让抽象类B实现接口C，其他的实现类只需要继承B2. 装饰器模式 ： 给一个对象动态增加新的功能，装饰对象B实现被装饰对象A相同的接口，并且B持有A的实例，用户更关注被装饰后的功能3. 代理模式 ： 类Proxy实现被代理的类A相同的接口，并持有A的实例，实现类似装饰器模式，但用户更关注被代理的对象功能 (可参考JDK proxy)4. 外观模式 ： 解决类与类之间的依赖关系，将其他的类组合在一起5. 桥接模式 ： 把事物和具体实现分开，使得二者可以独立变化 (参考JDBC的不同数据库驱动加载)6. 组合模式 ： 多个对象组合在一起进行操作,整体和个体的设计(参考二叉树，目录)7. 享元模式 ： 实现对象的共享(参考数据库连接池的实现，commons-pool开源实现) 十一种行为模式1234567891011121314151. 父类和子类 策略模式 : 多个子类实现同一个接口，用户按自己的选择选用不同的实现，如排序接口，具体实现快排，堆排等 模板方法模式 ： 抽象类定义主方法，子类继承抽象类，选择实现父类的方法，通过调用父类实现对子类的调用2. 两个类之间 观察者模式 : 观察者先订阅，被观察者变化时通知列表内的观察者 迭代子模式 : 用于遍历聚集中的对象，如集合,Iterator持有遍历对象实例，对其进行顺序访问 责任链模式 : 一个实例对象调用自己的实例去处理一个任务，然后递归，始终会有一个对象去处理这个任务，这个查找链不限于链表和树等 命令模式 ： 实现和请求分开，如controller和service层的分离3. 类的状态 备忘录模式 : 原始类A创建备忘类B保存在C中，B保存A的属性，C只能新增不能修改 状态模式 ： 类A有不同状态Status，不同的状态同一方法对应不同的行为4. 通过中间类 访问者模式 ： 分离对象数据结构和行为的方法，解决为现有类A新增功能，不能修改A的代码的情况,缺点是不适用数据结构易于变化的场景 中介者模式 ： 为降低类的耦合性，只需保持其它类和中间类的关系，不需要类之间相互持有实例对象 解释器模式 ： 类似编译器，正则表达式实现，使用场景受限 并发型模式123456789101. 主动对象模式 Active Object : 自带处理线程，其他请求进入缓冲区等待异步执行，调用和执行分离2. 阻碍模式 Balking Pattern : 设置一个共享变量，当线程进入一个方法，判断该值是否为真，如果为真说明已经在执行了，返回结束，否则设为真并执行3. 双重检查锁定 Double Checked Locking ： 参考单例模式实例的初始化双检查4. 守卫模式 Guarded ： 判断共享变量是否为真，当为假wait,等待条件为真时notify5. 领导者/追随者模式 Leaders/Followers : 每个线程共享一个事件源，并在三个状态切换leader、follower和processor;leader接受事件，状态变成processor，选举一个新的leader，事件处理完状态变成follower；不需要线程的上下文切换6. 监测对象模式 Monitor object : 互斥执行和协作。使用ｓｙｎｃｈｒｏｎｉｚｅｄ和wait/notify/notifyAll7. 读写锁 Read-write lock ： 读写锁分离，增加吞吐量 8. 调度模式 Scheduler ： 定期处理(Timer)9. 线程池模式 Thread pool ： 线程被当作资源管理分配10. 线程特定存储 Thread-specific storage : 将变量保存在ＴｈｒｅａｄLocal中，避免重复创建或从其他地方获取 Java 3种并发实现1231. Thread : 直接使用Thread/Runnable/Future2. Executors和Services ： 线程池技术来控制应用程序的并发，线程数通常和业务相关于cpu不相关，需要上下文切换实现并发，任务从开始到结束时间是不稳定的，执行过程中需要抢占cpu3. ForkJoin框架和并行流 ： cpu数来控制并行，并发数量不会大于cpu的并发数 Java并发策略123451. Future模式: 提高响应速度2. Master_worker模式: 子任务分配，提高响应速度 3. Guarded Suspension模式 : 队列缓冲，非立即处理，避免因为请求太多而崩溃4. 不变模式: 类似String/Double...不需要同步，线程安全5. 生产者消费者模式 : 缓解两者间的性能差","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"}],"tags":[]},{"title":"机器学习","slug":"软件开发/机器学习AI/机器学习","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:14:01.104Z","comments":true,"path":"passages/软件开发/机器学习AI/机器学习/","link":"","permalink":"http://yoursite.com/passages/软件开发/机器学习AI/机器学习/","excerpt":"","text":"##Install Crf++https://sourceforge.net/projects/crfpp/files/latest/download installtar zxvf CRF++-0.58.tar.gzcd CRF++-0.58./configuremakesudo make install install python interface进入子目录python中，cd python python setup.py buildpython setup.py install docker下安装pythondocker search pythondocker pull python:2.7 启动python镜像容器 第一次运行下载下来的python进行修改docker run -t -i python:2.7.15 /bin/bash 首次后使用自己的image进行修改docker run -t -i oliver/python:2.7.15a /bin/bash 安装对应库 12345$ pip install crf++ sudo pip install sklearnsudo pip install tensorflowsudo pip install kerassudo pip install corenlp 退出你刚才配置好的docker镜像exit 使用以下命令可以看到刚才退出的docker镜像docker ps -a 用以下命令，根据某个”容器ID”来创建一个新的”镜像”：docker commit -a=”oliver” 5925d286d2d9 oliver/python:2.7.15a 该容器ID是”57c312bbaad1”，所创建的镜像名是”javaweb”注意：”57c312bbaad1” 这个ID是使用 docker ps 命令来查看的提交了新的镜像可以把这个镜像储存tar包docker save -o ~/python.tar oliver/pythondocker save -o 保存的目录 镜像名","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"机器学习","slug":"软件开发/机器学习","permalink":"http://yoursite.com/categories/软件开发/机器学习/"}],"tags":[]},{"title":"幂等防重设计","slug":"软件开发/系统架构/幂等防重设计","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:16:19.641Z","comments":true,"path":"passages/软件开发/系统架构/幂等防重设计/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/幂等防重设计/","excerpt":"","text":"在一个典型的订单交易系统中，防重和幂等设计是重要而又非常基本的概念。防重是指重复多次提交同样的交易指令或者订单请求到后台，系统必须能够去重，防止重复执行；而幂等，则是在多个同样的交易指令或请求同时或者先后到达后台，即使重复执行，系统也必须始终提供与一致的状态，而不能有其他的副作用 幂等要表达的含义是：只要调用接口成功，外部对接口的多次调用得到的结果是相同的。即执行多次和一次的效果是一样的 订单系统，可能因为某个中间节点阻塞超时，触发了重发机制，最终导致多个相同ID的交易请求同时到达系统后台。由于老订单系统只提供了简单的串行防重，并没有充分考虑高并发幂等，结果将同一个用户的交易请求执行了多次，导致该用户的前后端的资产份额不一致，最终不得不人工介入解决。 常见的幂等实现方案，有这么几种，可以供大家探讨： 1、最简单的，需要通过唯一的业务单号来保证幂等。也就是说相同的业务单号，认为是同一笔业务。使用这个唯一的业务单号来确保，后面多次的相同的业务单号的处理逻辑和执行效果是一致的。以支付为例，在不考虑并发的情况下，实现幂等很简单：①先查询一下订单是否已经支付过，②如果已经支付过，则返回支付成功；如果没有支付，进行支付流程，修改订单状态为‘已支付’。 2、上述的保证幂等方案是分成两步的，第②步依赖第①步的查询结果，无法保证原子性的。在高并发下就会出现下面的情况：第二次请求在第一次请求第②步订单状态还没有修改为‘已支付状态’的情况下到来。既然得出了这个结论，余下的问题也就变得简单：把查询和变更状态操作加锁，将并行操作改为串行操作。 3、但是，在某些场景，你可能又想提供无锁的高并发幂等，那么你可以选择为业务单号加上唯一的索引或者组合索引，在并发的场景中，只有第一笔插入的交易请求能够成功，后续的请求哪怕是慢1ms或者更短时间，都会触发数据库的唯一索引异常而失败，那么你可以捕获这个异常。 4、又或者你想把幂等放在服务的最前端，减少实际服务处理的资源浪费，在请求一到达时就提前去重，不让他有执行的机会，那么你可以考虑引入一个redis或类似的组件，将业务请求单号缓存在这个分布式锁的组件内。那么，每当订单发起交易请求，交易系统会去Redis缓存中查询是否存在该订单号的Key，如果不存在，则向Redis增加Key为订单号。查询订单是否已经执行，如果没有则转发到交易系统，执行完成后删除该订单号的Key。当然，Redis是提供分布式节点下的原子事务操作的。","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"}],"tags":[]},{"title":"BondsGuide","slug":"金融/投资/BondsGuide","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:11:33.134Z","comments":true,"path":"passages/金融/投资/BondsGuide/","link":"","permalink":"http://yoursite.com/passages/金融/投资/BondsGuide/","excerpt":"","text":"What’s Bond[TOC] Why Bond A balanced portfolio of stocks and bonds can help most investors accomplish long-term investment goals more effectively than a pure equity strategy. Bonds provide solutions for two of the three most basic investment requirements: income and capital preservation A bond is a security that pay a special rate of interest for a limited amount of time and returns principle on a defined time. A balanced portfolio of stocks and bonds can help most of you accomplish long-term investment goals more effectively than a pure equity strategy. Stock and bonds represent the two largest components of the three main asset classes recommended by most investment firms(the other would be cash). Three basic investment requirements Capital Preservation Income Growth Who Issues Bond Investment banks are hired to structure bond offerings, advise issuers on the timing and terms of sale, and arrange distribution to investors. Bond issuers are required to publish a prospectus—a document that outlines the key provisions of each offering. The public sector comprises federal government issues, known as Treasuries, and state and local government issues, known as municipals. Bond proceeds fill financing gaps and help smooth out the receipt of tax revenue. The private sector comprises corporations that issue bonds as an alternative to bank loans and stock offerings. Bond offerings provide companies with an efficient way to raise capital and does not dilute shareholder equity. Public SectorIt is dominated by two types of securities—federally issued bonds known as Treasuries, and state and local issues known as municipals. Private SectorBonds provide an alternative to stock issuance and bank loans for domestic and multinational corporations. Why issue bond rather than stock or loan: interest paid to bondholders provides a pretax deduction—known as interest expense—to corporations. This is similar to the tax break you receive when mortgage interest is deducted from your annual income—it lowers your overall tax bill When companies increase stock issuance, it reduces the percentage of the company that is owned by current shareholders. the law of supply and demand suggests that if demand remains unchanged, more issuance could cause prices to decline How are Bond Bought and SoldMost bonds are bought and sold over the phone through a broker-dealer. Unlike stocks, bonds are largely transacted over-the-counter and are not listed on a centralized exchange Why buy Bonds rather than StocksBonds provide investors with an effective way to preserve capital and generate income.Stocks are more appropriate for growth objectives. Price Bonds have a bid price and an offer (also called ask) price. You sell a bond at the bid and buy a bond at the offer. The bid is always lower than the offer, and the difference is called the bid/offer spread. When a bond’s price trades above its $1,000 par value, it is said to be trading at a premium. When it trades below par, it is said to be trading at a discount Bonds are typically quoted as a percentage of par value, rather than in dollars. For example, $1,020 would simply be 102 Bonds trade with accrued interest, which is the amount of interest accumulated, but not paid, between semiannual payment dates. All bonds have two price levels, or quotes, known as the bid and the offer (also called the ask). Traders purchase (or bid) for bonds at the bid price and sell them at the offer price. Since no trader is going to sell a bond below cost, the bid will always be lower than the offerIf a bond is bid at $990 and is offered at $1,010, the bid/offer is $990/$1,010. The difference between the bid and offer is called the bid/offer spread, which in other businesses is called the margin Accrued Interestit’s the interest that accumulates (or accrues) each day between payment dates Accrued interest = Annual interest × (number of days ÷ 360) MATURITYMost bond maturities range between 2 and 30 years, although there are some 40-year and even some 100-year bonds outstanding. Securities that mature in less than one year are considered money market instruments, 1- to 5-year bonds are short-term, 5- to 12-year issues are intermediateterm, and bonds maturing in more than 12 years are considered longtermLarge new bond issues usually feature several different maturities known as serial bonds, only one maturity are known as term bonds. Callables: grant the issuer the right to retire a bond beginning on a specific date. Put Bonds: enable you to get into the driver’s seat since you’re able to request, or “put,” the bonds back to the issuer. COUPON A bond’s stated annual interest rate is known as its coupon. Although the coupon represents an annual rate, interest is usually paid semiannually. Bonds that do not make interest payments are known as zero coupon bonds. Reinvesting interest payments generates interest-on-interest, which illustrates the power of compounding The amount that a sum of money in the future is worth today is known as present value. Future value, on the other hand, is what your money today would be worth at some point in the future Zero Coupon BondsZeros are issued at a deep discount to par because the money you receive at maturity includes the principal and the total interest you’ve earned. Since zeros don’t make coupon payments, they shield investors from reinvestment risk Present value the amount that a sum of money in the future is worth today Future value on the other hand, is what your money today would be worth at some point in the future Yield Yield-to-maturity calculates the percentage rate of return assuming interest payments are reinvested at the same coupon rate and the bond is held to maturity. Yield-to-call is used for bonds with early redemptions, and yield-to-worst is the lower of the two, or the lowest yield you could expect to receivewhat’s the real value of YTM? It allows you to quantify and compare different bonds by putting them on the same playing field When a bond is trading at par, YTM is equal to its current yield and coupon. When a bond is trading at a discount, YTM is greater than the coupon. When a bond is trading at a premium, YTM is lower than the coupon. Current Yield: Current yield is an investment’s annual income (interest or dividends) divided by the current price of the securit YTM: is the percentage rate of return assuming a bond is held until maturity and interest payments are reinvested at the same nominal yield. YTC: incorporates the future stream of reinvested coupon payments, the price paid for the bond, and the price you would receive at each early redemption date YTW: pick the lower of a bond’s YTM and YTC CREDIT QUALITY Credit rating agencies provide us with the most effective way to objectively gauge bond issuer risk. Moody’s Investors Service (Moody’s), Standard &amp; Poor’s (S&amp;P), and Fitch Ratings (Fitch) are the three leading agencies that evaluate credit quality and then assign ratings to bond issuers. WHY BAD NEWS IS GOOD NEWS Lower inflation facilitates lower interest rates and lifts bond prices. Inflation occurs when spending has increased relative to supply—think of it as too much money chasing too few goods. The most widely watched inflation barometer is the Consumer Price Index, or CPI. Since a bond’s coupon rate does not change, inflation erodes the future value of its fixed-income stream Strong economic growth typically generates higher interest rates and depresses bond prices—so what’s bad for the economy (slower growth) is usually good for bond investors. Bond Prices and Interest Rates When interest rates decline, bond prices rise When interest rates rise, bond prices decline Suppose you bought a 10-year bond two years ago at par with a 5 percent coupon. Today, the same company issues another 10-year bond with identical characteristics. Interest rates, however, have declined, so the new bond is issued with a 4 percentcoupon. Who’s happier—issuer or investor? The answer might seem obvious, but it’s also instructive. Although the issuer lowered its borrowing costs by 1 percent, it’s obvious that investors would prefer 5 percent to 4 percent. Since demand for the older bond would rise, it’ll trade at a premium—say, at 102 MEASURING VOLATILITY Duration is a measure of the sensitivity of a bond’s price to interest rate fluctuations. Although duration is a complicated concept, the most important part to remember is fairly straightforward—it represents the percentage change in a bond’s price given a 1 percent rise or fall in interest rates. Interest rate risk To measure the potential volatility caused by moves in interest rates, bond investors use duration. EVALUATING LIQUIDITY Liquidity refers to the market’s demand for (and supply of) a particular security. When a bond is said to have good liquidity, it can be readily converted into cash near the price at which it was last bought or sold. Illiquid securities offer higher yields but are not appropriate for investors who plan to sell their holdings prior to maturity TREASURY SECURITIES U.S. Treasury securities (Treasuries) are auctioned by the federal government and are widely considered the safest investments in the world. The three most common types of Treasury securities are bills (under 1 year to maturity), notes (2 to 10 years), and bonds (over 10 years to 30 years) Treasury yields represent the benchmarks to which all other bonds are compared. The 10-year note is the market’s bellwether. The current yields of the most recently auctioned securities are depicted by the Treasury yield curve. These include the 3- and 6-month bills, the 2-, 3-, 5-, and 10-year notes, and the recently suspended 30-year bond. Treasury billscolloquially known as T-bills, or bills, are zero coupon securities sold at a discount to face value. Bills mature in one year or less and are auctioned every week throughout the year. Although one-year bill auctions were suspended in 2001, three other maturities are still issued: 4 weeks, 3 months (13 weeks), and 6 months (26 weeks). The 3-month T-bill yield is commonly used by investment professionals to represent the risk-free rate of return. Unlike other Treasuries, T-bills are always quoted by yield, not price. Since bills pay interest only at maturity, their simple yield (or discount rate) represents the difference between the purchase price and final redemption value. Simple yield, however, reflects less than one year of total return. As a result, T-bills should be evaluated by their bond equivalent yield (BEY) in order to be accurately compared to the annualized compounded yield of a coupon-bearing security BEY = 365 discount rate / (360 - (days to maturity discount rate)) Treasury notesproduce semiannual interest and are auctioned in 2-year, 3-year, 5-year and 10-year maturities Treasury bondshave maturities beyond 10 years and pay semiannual interest STRIPSSeparate Trading of Registered Interest and Principal of Securities, Another zero-coupon security AGENCY SECURITIES Agency securities are issued by federal agencies and privately run corporations known as government-sponsored enterprises (GSEs) to provide funding for a specific public purpose Agencies are Triple-A rated because the./y’re either explicitly or implicitly guaranteed by the U.S. government Fannie Mae and Freddie Mac dominate agency issuance. Both are GSEs that facilitate home ownership in the United States Because of the frequency of issuance, low risk of default, and excellent liquidity, bond investors often use agencies as substitutes for Treasuries. MORTGAGE-BACKED SECURITIES Mortgage-backed securities (MBSs) are bonds secured by real estate. For our purposes, mortgage bonds are backed by residential mortgages The MBS market is comprised of pass-throughs and collateralized mortgage obligations (CMOs). Mortgage bond payments are received monthly and comprise interest and principal Mortgage investors are vulnerable to both prepayment risk, which repays principal quicker than expected, and extension risk, which returns it slower The two most common types of mortgage bonds purchased by individual investors are pass-throughs and Collateralized Mortgage Obligations Pass-throughs are merely conduits—mortgage payments are collected in a pool and distributed (or passed-through, get it?) to bond investors through a trust that’s created at issuance. CMOs(collateralized mortgage obligations) are just a group of passthrough securities.Although there are nearly 40 different types of CMOs, most individual investors focus on two types: sequential bonds and planned amortization class (PAC) bonds. Asset-Backed Securities: like many CMOs, they’re not typically offered to individual investors. CORPORATE BONDS The corporate bond market is normally segregated into four industry sectors: finance, industrials, transportation, and utilities The capital structure ranks bonds according to the claim they have on a company’s assets Since all corporate issuers carry some degree of risk, credit ratings are critical. These are divided into two categories: investment-grade (or high-grade) and high-yield (or junk) bonds Credit ratings are not stagnant. Upgrades occur when financial security strengthens, while downgrades occur when it deteriorates. These ratings changes impact investors and issuers alike Investment-Grade Bonds Investment-grade (also known as high-grade) bonds comprise issuers that are deemed to be in good financial health and are unlikely to have trouble meeting their debt obligations. Bonds are ranked from Triple-A (highest) to Triple-B (lowest). High-Yield Bonds Companies that do not receive investment-grade ratings are considered high-yield. The ratings agencies rank these bonds from Ba1 to C (Moody’s) MUNICIPAL BONDS State and local governments issue municipal bonds to finance projects that serve the public interest. General obligation (GOs) and revenue bonds are the two main types. Municipals are popular with individual investors since they can provide tax-free interest income Municipalities are assigned credit ratings just like corporate issuers. They may also purchase insurance to ensure that a new bond issue receives a Triple-A rating Since municipals are tax-advantaged, they have lower nominal yields than their taxable fixed-income counterparts. Taxable equivalent yields should be calculated to fairly compare municipal and taxable yields Municipal bonds are especially popular with U.S. investors because the federal government does not tax interest generated by the majority of these bonds. Additionally, most state and local municipalities allow investors to enjoy tax-free income from the securities issued by their home states.Bonds issued by U.S. territories—such as Puerto Rico, Guam, and the U.S. Virgin Islands—are tax-exempt for residents of all states, municipal securities are the only type of bond that have the potential to generate fully tax-free incomeFor that reason, individuals purchase more municipals than any other bonds Categories of Municipal Bonds Public purpose bonds are issued directly by state or local authorities for the types of projects you’d expect governments to finance. This includes construction of public schools, sanitation facilities, water treatment plants, and highways. These bonds are exempt from federal, state and local taxes Nongovernmental purpose bonds are also fully tax-exempt securities. These bonds are used to fund initiatives that more narrowly serve the public interest or are associated with the private sector, for example, transportation authorities, private hospitals, and universities Private activity bonds are issued by municipalities but are associated with projects that are not government-run. These issues may be taxable, depending on the extent to which they benefit the public interest and typically include bonds that finance student loans, airports, industrial developments, or other special projects Two most common types of Muni Securities General Obligation (GO) bonds State governments dominate this type of issuance, followed by cities with large public infrastructures. GOs typically have better credit quality and experience higher demand than revenue bonds since issuers can raise taxes or tap myriad revenue streams to meet interest payments if necessary. Revenue bonds are backed by revenue and fees collected by the facility that’s being funded. A revenue bond is not as secure since debt service is directly supported by income generated by a specific project. Municipalities also issue taxable bonds, though it only represents a small part of the municipal market. Taxables are issued when the federal government is unwilling to sanction certain projects that do not broadly serve the public interest. These bonds include corporate-backed municipaldebt related to pollution control or waste disposal. These also are issued when a municipality exceeds its tax-exempt issuance limit for certain types of bonds. Taxable munis offer yields comparable to similarly rated corporate securities. Taxable Equivalent Yield TEY is to adjust a muni yield in order to fairly compare it to a taxable security TEY = Muni YTM/(1 - Your marginal income tax rate) INTERNATIONAL BONDS Most fixed-income securities issued by foreign entities are structured similarly to U.S. debt. However, bonds issued in Europe pay interest annually, rather than semiannually. You could participate in the international market through U.S. dollar-denominated or local currency debt. U.S. dollar–denominated securities issued by non–U.S. entities are known asYankee bonds International bonds expose investors to myriad country-based uncertainties, collectively known as sovereign risk, and to currency risk PREFERRED SECURITIES Preferred securities may be issued as equity or debt A preferred has a $25 par value compared to the $1,000 face value of a bond. That’s one of the reasons they’re so popular with individual investors Preferreds usually feature quarterly payments, rather than the semiannual income streams provided by bonds Corporations that issue bonds also commonly issue preferreds. However, preferreds have several notable differences from bonds. The most prominent are their $25 par value, in contrast to the $1,000 par value ofbonds. It’s one of the reasons they’re popular with individual investors— like a low-priced common stock, the $25 price tag just makes them more affordable. Additionally, these securities typically feature a fixed quarterly, rather than semiannual, income stream. Best of all, most preferreds CONVERTIBLE SECURITIES Convertible securities are hybrid equity and debt instruments that can be converted from a corporate bond or a preferred security into common stock Although convertibles provide semiannual income, their yield is lower than other fixed-income securities in exchange for capital appreciation potential Strict guidelines dictate convertibility U.S. SAVINGS BONDS Savings bonds are issued by the U.S. Treasury Department. There are three types: Series EE, Series I (an inflation-indexed bond), and Series HH/H. Although U.S. savings bonds provide the same degree of safety as Treasuries, an active secondary market does not exist. U.S. savings bonds are exempt from state and local taxes, and investors may defer paying federal income tax on interest for 30 years or until the bonds are redeemed. ##CERTIFICATES OF DEPOSIT Certificates of deposit (CDs) are time deposits created by banks Although CDs have similar characteristics to bonds, CDs are not fixed-income securities since they are not SEC-registered public debt offerings CDs are insured up to $100,000 (interest and principal combined) by the Federal Deposit Insurance Corporation Although banks originate CDs, investors may also purchase them from broker-dealers ##FUNDS AND UNIT INVESTMENT TRUSTS Three types of bond funds are available: mutual funds, closed-end funds, and unit investment trusts (UITs) Mutual funds and closed-end funds are actively managed bond portfolios, while UITs comprise a fixed group of bonds held in a trust Mutual funds and closed-end funds are perpetual, while UITs mature. Each provides a monthly income stream Although no fund should be chosen by cost alone, it behooves investors to thoroughly review expenses prior to any investment. ##MONEY MARKET FUNDS Money market mutual funds provide individuals with access to higher-yielding cash-equivalent instruments. These funds provide a higher rate of return than savings accounts, usually offer check-writing privileges, and are readily available as cash. Money market funds invest in short-term securities, such as Treasury bills, CDs, banker’s acceptances, and commercial paper","categories":[{"name":"金融","slug":"金融","permalink":"http://yoursite.com/categories/金融/"},{"name":"投资","slug":"金融/投资","permalink":"http://yoursite.com/categories/金融/投资/"}],"tags":[]},{"title":"性能测试","slug":"软件开发/系统架构/性能测试","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:16:22.701Z","comments":true,"path":"passages/软件开发/系统架构/性能测试/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/性能测试/","excerpt":"","text":"系统吞度量要素一个系统的吞度量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。单个reqeust 对CPU消耗越高，外部系统接口、IO影响速度越慢，系统吞吐能力越低，反之越高。 系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间 QPS（TPS）：每秒钟request/事务 数量 并发数： 系统同时处理的request/事务数 响应时间： 一般取平均响应时间 QPS（TPS）= 并发数/平均响应时间 或者 并发数 = QPS*平均响应时间 1234一个典型的上班签到系统，早上8点上班，7点半到8点的30分钟的时间里用户会登录签到系统进行签到。公司员工为1000人，平均每个员上登录签到系统的时长为5分钟。可以用下面的方法计算。QPS = 1000/(30*60) 事务/秒平均响应时间为 = 5*60 秒并发数= QPS*平均响应时间 = 1000/(30*60) *(5*60)=166.7 一个系统吞吐量通常由QPS（TPS）、并发数两个因素决定，每套系统这两个值都有一个相对极限值，在应用场景访问压力下，只要某一项达到系统最高值，系统的吞吐量就上不去了，如果压力继续增大，系统的吞吐量反而会下降，原因是系统超负荷工作，上下文切换、内存等等其它消耗导致系统性能下降。 软件性能的关注点对一个软件做性能测试时需要关注那些性能呢？ 我们想想在软件设计、部署、使用、维护中一共有哪些角色的参与，然后再考虑这些角色各自关注的性能点是什么，作为一个软件性能测试工程师，我们又该关注什么？ 首先，开发软件的目的是为了让用户使用，我们先站在用户的角度分析一下，用户需要关注哪些性能。 对于用户来说，当点击一个按钮、链接或发出一条指令开始，到系统把结果已用户感知的形式展现出来为止，这个过程所消耗的时间是用户对这个软件性能的直观印象。也就是我们所说的响应时间，当相应时间较小时，用户体验是很好的，当然用户体验的响应时间包括个人主观因素和客观响应时间，在设计软件时，我们就需要考虑到如何更好地结合这两部分达到用户最佳的体验。如：用户在大数据量查询时，我们可以将先提取出来的数据展示给用户，在用户看的过程中继续进行数据检索，这时用户并不知道我们后台在做什么。 用户关注的是用户操作的相应时间。其次，我们站在管理员的角度考虑需要关注的性能点。 1、 相应时间2、 服务器资源使用情况是否合理3、 应用服务器和数据库资源使用是否合理4、 系统能否实现扩展5、 系统最多支持多少用户访问、系统最大业务处理量是多少6、 系统性能可能存在的瓶颈在哪里7、 更换那些设备可以提高性能8、 系统能否支持7×24小时的业务访问 再次，站在开发（设计）人员角度去考虑。1、 架构设计是否合理2、 数据库设计是否合理3、 代码是否存在性能方面的问题4、 系统中是否有不合理的内存使用方式5、 系统中是否存在不合理的线程同步方式6、 系统中是否存在不合理的资源竞争 软件性能的几个主要术语 响应时间：对请求作出响应所需要的时间 网络传输时间：N1+N2+N3+N4 应用服务器处理时间：A1+A3 数据库服务器处理时间：A2 响应时间=N1+N2+N3+N4+A1+A3+A2 并发用户数的计算公式 系统用户数：系统额定的用户数量，如一个OA系统，可能使用该系统的用户总数是5000个，那么这个数量，就是系统用户数。 同时在线用户数：在一定的时间范围内，最大的同时在线用户数量。同时在线用户数=每秒请求数RPS（吞吐量）+并发连接数+平均用户思考时间 平均并发用户数的计算：C=nL / T 其中C是平均的并发用户数，n是平均每天访问用户数（login session），L是一天内用户从登录到退出的平均时间（login session的平均时间），T是考察时间长度（一天内多长时间有用户使用系统） 并发用户数峰值计算：C^约等于C + 3*根号C 其中C^是并发用户峰值，C是平均并发用户数，该公式遵循泊松分布理论。 吞吐量的计算公式 指单位时间内系统处理用户的请求数 从业务角度看，吞吐量可以用：请求数/秒、页面数/秒、人数/天或处理业务数/小时等单位来衡量 从网络角度看，吞吐量可以用：字节/秒来衡量 对于交互式应用来说，吞吐量指标反映的是服务器承受的压力，他能够说明系统的负载能力 以不同方式表达的吞吐量可以说明不同层次的问题，例如，以字节数/秒方式可以表示数要受网络基础设施、服务器架构、应用服务器制约等方面的瓶颈；已请求数/秒的方式表示主要是受应用服务器和应用代码的制约体现出的瓶颈。 当没有遇到性能瓶颈的时候，吞吐量与虚拟用户数之间存在一定的联系，可以采用以下公式计算：F=VU * R / 其中F为吞吐量，VU表示虚拟用户个数，R表示每个虚拟用户发出的请求数，T表示性能测试所用的时间 性能计数器 是描述服务器或操作系统性能的一些数据指标，如使用内存数、进程时间，在性能测试中发挥着“监控和分析”的作用，尤其是在分析统统可扩展性、进行新能瓶颈定位时有着非常关键的作用。 资源利用率：指系统各种资源的使用情况，如cpu占用率为68%，内存占用率为55%，一般使用“资源实际使用/总的资源可用量”形成资源利用率。 思考时间的计算公式 Think Time，从业务角度来看，这个时间指用户进行操作时每个请求之间的时间间隔，而在做新能测试时，为了模拟这样的时间间隔，引入了思考时间这个概念，来更加真实的模拟用户的操作。 在吞吐量这个公式中F=VU * R / T说明吞吐量F是VU数量、每个用户发出的请求数R和时间T的函数，而其中的R又可以用时间T和用户思考时间TS来计算：R = T / TS 下面给出一个计算思考时间的一般步骤： A. 首先计算出系统的并发用户数 C=nL / T F=R×C B. 统计出系统平均的吞吐量 F=VU R / T R×C = VU R / T C. 统计出平均每个用户发出的请求数量 R=uCT/VU D. 根据公式计算出思考时间 TS=T/R","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"}],"tags":[]},{"title":"一致性","slug":"软件开发/系统架构/一致性","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:16:16.348Z","comments":true,"path":"passages/软件开发/系统架构/一致性/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/一致性/","excerpt":"","text":"一致性高级一致性算法一致性hash一致性哈希算法(Consistent Hashing Algorithm)是一种分布式算法，常用于负载均衡一致性哈希将整个哈希值空间组织成一个虚拟的圆环一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性 paxos zab nwr raft gossip 传统一致性ACID原子性Atomic原子性任务是一个独立的操作单元，是一种要么全部是，要么全部不是的原子单位性的操作。 一致性Consistency一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。 一致性有下面特点： 如果一个操作触发辅助操作（级联，触发器），这些也必须成功，否则交易失败。如果系统是由多个节点组成，一致性规定所有的变化必须传播到所有节点（多主复制）。如果从站节点是异步更新，那么我们打破一致性规则，系统成为“最终一致性”。一个事务是数据状态的切换，因此，如果事务是并发多个，系统也必须如同串行事务一样操作。在现实中，事务系统遭遇并发请求时，这种串行化是有成本的， Amdahl法则描述如下：它是描述序列串行执行和并发之间的关系。 “一个程序在并行计算情况下使用多个处理器所能提升的速度是由这个程序中串行执行部分的时间决定的。” 大多数数据库管理系统选择（默认情况下）是放宽一致性，以达到更好的并发性。 隔离性Isolation事务是并发控制机制，他们交错使用时也能提供一致性。隔离让我们隐藏来自外部世界未提交的状态变化，一个失败的事务不应该破坏系统的状态。隔离是通过用悲观或乐观锁机制实现的。 耐久性Duration一个成功的事务将永久性地改变系统的状态，所以在它结束之前，所有导致状态的变化都记录在一个持久的事务日志中。如果我们的系统突然受到系统崩溃或断电，那么所有未完成已提交的事务可能会重演。 分布一致性分布式系统体系结构从其出现之初就伴随着诸多的难题和挑战： 1、通信异常 从集中式向分布式演变的过程中，必然引入网络因素，由于网络本身的不可靠性，因此 也引入了额外的问题。分布式系统需要在各个节点之间进行网络通信，因此每次网络通信都会伴随着网络不可用的风险，网络光纤、路由器或是DNS等硬件设备或 是系统不可用都会导致最终分布式系统无法顺利完成一次网络通信。另外，即使分布式系统各个节点之间的网络通信能够正常进行，其延时也会大于单机操作。通常 我们认为现代计算机体系结构中，单机内存访问的延时在纳秒数量级（通常是10ns），而正常的一次网络通信的延迟在0.1~1ms左右（相当于内存访问延 时的105倍），如此巨大的延时差别，也会影响到消息的收发过程，因此消息丢失和消息延迟变得非常普遍 2、网络分区 当网络由于发生异常情况，导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式系统的所有节点中，只有部分节点之间能够正常通信，而另一些节点则不能—-我们将这个现象称为网络分区。当网络分区出现时，分布式系统会出现局部小集群，在极端情况下，这些局部小集群会独立完成原本需要整个分布式系统才能完成的功能，包括对数据的事物处理，这就对分布式一致性提出了非常大的挑战 3、三态 上面两点，我们已经了解到在分布式环境下，网络可能会出现各式各样的问题，因此分布式系统的每一次请求与响应，存在特有的三态概念，即成功、失败、超时。 在传统的单机系统中，应用程序在调用一个函数之后，能够得到一个非常明确的响应：成功或失败。而在分布式系统中，由于网络是不可靠的，虽然在绝大部分情况 下，网络通信也能够接受到成功或失败的响应，当时当网络出现异常的情况下，就可能会出现超时现象，通常有以下两种情况： （1）由于网络原因，该请求并没有被成功地发送到接收方，而是在发送过程中就发生了消息丢失现象 （2）该请求成功地被接收方接收后，进行了处理，但是在将响应反馈给发送方的过程中，发生了消息丢失现象 当出现这样的超时现象时，网络通信的发起方是无法确定当前请求是否被成功处理的 4、节点故障 节点故障则是分布式环境下另一个比较常见的问题，指的是组成分布式系统的服务器节点出现的宕机或”僵死”现象，通常根据经验来说，每个节点都有可能出现故障，并且每天都在发生 1、强一致性 这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大 2、弱一致性 这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不久承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态 3、最终一致性 最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型 理论CAP首先我们来了解一下什么是CAP理论，其核心是：一个分布式系统不可能同时很好的满足 一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。 一致性(Consistency) ：所有节点在同一时间具有相同的数据； 可用性(Availability) ：保证每个请求不管成功或者失败都有响应； 分区容错性(Partition tolerance) ：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。系统中任意信息的丢失或失败不会 影响系统的继续运作，即可靠性。 而MongoDB通过复制集和分片技术很好的满足了CP原则。 要保证数据强一致性，最简单的方法是令写操作在所有数据节点上都执行成功才能返回成功，也就是同步概念。而这时如果某个结点出现故障，那么写操作就成功不了了，需要一直等到这个节点恢复。也就是说，如果要保证强一致性，那么就无法提供7×24的高可用性。 而要保证可用性的话，就意味着节点在响应请求时，不用完全考虑整个集群中的数据是否一致。只需要以自己当前的状态进行请求响应。由于并不保证写操作在所有节点都写成功，这可能会导致各个节点的数据状态不一致。 CAP理论导致了最终一致性和强一致性两种选择。当然，事实上还有其它的选择，比如在Yahoo的PNUTS中，采用的就是松散的一致性和弱可用性结合的方法。但是我们讨论的NoSQL系统没有类似的实现，所以我们在后续不会对其进行讨论。 BASEBASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结， 是基于CAP定理逐步演化而来的。BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。接下来看一下BASE中的三要素： 1、基本可用 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性—-注意，这绝不等价于系统不可用。比如： （1）响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒 （2）系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面 2、软状态 软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时 3、最终一致性 最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。 总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统的事物ACID特性是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。 协议两段式提交协议（XA事务）提交事务阶段——投票阶段协调者发起事务请求到所有的参与者，参与者接收到事务请求后判断自身情况，如果不能执行事务，则反馈不能提交事务，返回NO，如果可以就执行事务，并将undo和redo信息记录事务日志中，反馈Yes 执行事务阶段协调者收到所有参与者反馈Yes就发布commit命令，否则如果超时未收到或者收到NO 那么发布回滚命令。 参与者收到commit的请求后正式提交事务操作，提交后释放资源。完成事务后向协调者发送ack消息 协调者收到所有参与者的ack后完成事务。 参与者收到rollback的请求查找undo记录，完成回滚后释放资源。完成事务后向协调者发送ack消息 协调者收到所有参与者的ack后中断事务。 优点：原理简单，实现方便缺点：同步阻塞，单点问题，脑裂问题，太过保守–超时机制，数据不一致—第二阶段部分事务提交。 三阶段提交协议第一阶段 cancommit 1、协调者向所有参与者发布包含事务内容的canCommit命令，等待参与者回应。 2、参与者认为自身能执行，则返回yes。否则返回NO 第二阶段 preCommit阶段 1、如果协调者收到的反馈都是yes，那么发出preCommit命令，进入prepared阶段，参与者收到preCommit命令后，执行事务操作。并写入undo和redo信息到事务日志中。然后想协调者反馈ack相应 2、如果协调者收到的返回时NO，那么发布abort命令。各参与者收到abort或者超时，都中断事务。 第三阶段， docommit阶段 如果协调者收到所有参与者的ack相应，那么会发出doCommit命令，所有参与者收到docommit命令就提交事务，然后释放资源。向协调者发出ack。协调者收到所有参与者的ack详细后完成事务。 如果协调者收到No反馈或者超时响应后，将对所有的参与者发出abort请求。各个参与者收到abort请求后会利用undo信息回滚事务。，然后释放资源，反馈ack。协调者收到所有ack消息后，中断事务。 需要注意的是，在第三阶段如果参与者没有收到docommit命令，那么超时后它会提交事务，毕竟第一阶段所有的参与者都响应了，默认他们都能正常工作。 优缺点： 优点：即第三阶段的超时提交。降低了参与者的阻塞范围，并且能够再出现单点故障后继续达成一致。 缺点：数据可能也会不一致。也存在2pc中的缺点 TCC柔性事物TCC是Try-Confirm-Cancel的简称: Try阶段： 完成所有业务检查（一致性），预留业务资源(准隔离性) 回顾上面航班预定案例的阶段1，机票就是业务资源，所有的资源提供者(航空公司)预留都成功，try阶段才算陈宫 Confirm阶段： 确认执行业务操作，不做任何业务检查， 只使用Try阶段预留的业务资源。回顾上面航班预定案例的阶段2，美团APP确认两个航空公司机票都预留成功，因此向两个航空公司分别发送确认购买的请求。 Cancel阶段： 取消Try阶段预留的业务资源。回顾上面航班预定案例的阶段2，如果某个业务方的业务资源没有预留成功，则取消所有业务资源预留请求。 TCC两阶段提交与XA两阶段提交的区别是：XA是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁。 XA事务中的两阶段提交内部过程是对开发者屏蔽的，回顾我们之前讲解JTA规范时，通过UserTransaction的commit方法来提交全局事务，这只是一次方法调用，其内部会委派给TransactionManager进行真正的两阶段提交，因此开发者从代码层面是感知不到这个过程的。而事务管理器在两阶段提交过程中，从prepare到commit/rollback过程中，资源实际上一直都是被加锁的。如果有其他人需要更新这两条记录，那么就必须等待锁释放。 TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁。 TCC中的两阶段提交并没有对开发者完全屏蔽，也就是说从代码层面，开发者是可以感受到两阶段提交的存在。如上述航班预定案例：在第一阶段，航空公司需要提供try接口(机票资源预留)。在第二阶段，航空公司提需要提供confirm/cancel接口(确认购买机票/取消预留)。开发者明显的感知到了两阶段提交过程的存在。try、confirm/cancel在执行过程中，一般都会开启各自的本地事务，来保证方法内部业务逻辑的ACID特性。其中： 1、try过程的本地事务，是保证资源预留的业务逻辑的正确性。 2、confirm/cancel执行的本地事务逻辑确认/取消预留资源，以保证最终一致性，也就是所谓的补偿型事务(Compensation-Based Transactions)。 由于是多个独立的本地事务，因此不会对资源一直加锁。 最终一致性 查询模式: 任何一个服务操作都需要提供一个查询接口，用来向外部输出操作执行的状态。服务操作的使用方可以通过查询接口，得知服务操作执行的状态，然后根据不同状态来做不同的处理操作 补偿模式： 补偿模式的上游服务依赖于下游服务的运行结果，而事件通知模式上游服务不依赖于下游服务的运行结果。首先介绍业务补偿模式，业务补偿模式是一种纯补偿模式，其设计理念为，业务在调用的时候正常提交，当一个服务失败的时候，所有其依赖的上游服务都进行业务补偿操作（回滚交易） 异步确保模式:异步确保模式是补偿模式的一个典型案例，经常应用到使用方对响应时间要求并不太高，我们通常把这类操作从主流程中摘除，通过异步的方式进行处理，处理后把结果通过通知系统通知给使用方，这个方案最大的好处能够对高并发流量进行消峰，例如：电商系统中的物流、配送，以及支付系统中的计费、入账等。将要执行的异步操作封装后持久入库，然后通过定时捞取未完成的任务进行补偿操作来实现异步确保模式，只要定时系统足够健壮，任何一个任务最终会被成功执行 消息确保模式：主服务完成后将结果通过事件（常常是消息队列）传递给从服务，从服务在接受到消息后进行消费，完成业务，从而达到主服务与从服务间的消息一致性 最大努力通知模式（定期校对）：业务服务在提交事务后，进行有限次数（设置最大次数限制）的消息发送，比如发送三次消息，若三次消息发送都失败，则不予继续发送。所以有可能导致消息的丢失 超时模式 快速失败 补偿模式","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"}],"tags":[]},{"title":"ETF","slug":"金融/投资/ETF","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:11:28.394Z","comments":true,"path":"passages/金融/投资/ETF/","link":"","permalink":"http://yoursite.com/passages/金融/投资/ETF/","excerpt":"","text":"1 、什么是交易型开放式指数基金 (ETF)?答 :” 交易型开放式指数证券投资基金 “(ExchangeTradedFund, 以下缩写 ETF), 简称 “ 交易型开放式指数基金 “, 又称 “ 交易所交易基金 “ 。ETF 是一种跟踪 “ 标的批数 “ 变化、且在证券交易所上市交易的基金。投资人可以如买卖股票那么简单地去买卖跟踪 “ 标的指数 “ 的 ETF, 并使其可以获得与该指数基本相同的报酬率。ETF 通常由基金管理公司管理 , 基金资产为一篮子股票组合 , 组合中的股票种类与某一特定指数 ( 如上证 50 指数 ) 包含的成份股票相同 , 股票数量比例与该指数的成份股构成比例一致。例如 , 上证 50 指数包含中国联通、浦发银行等 50 只股票 , 上证 50 指数 ETF 的投资组合也应该包含中国联通、浦发银行等 50 只股票 , 且投资比例同指数样本中各只股票的权重对应一致。换句话说 , 指数不变 ,ETF 的股票组合不变；指数调整 ,ETF 投资组合要作相应调整。 2 、指数基金与传统的证券投资基金的投资方法有什么不同 ? 指数投资有什么优点 ?答 : 传统的主动型股票投资基金主要依靠基金经理对股票的分析 , 来作出买卖决定。指数基金的方法则全然不同 , 基金经理不按个人意向来作出买卖决定 , 而是根据指数成份股的构成被动地决定所投资的股票 , 投资股票的比重也跟指数的成份股权重保持一致。近年来 , 指数投资深受投资者欢迎。指数投资不但能分散投资 , 减低风险 , 更可大大节省成本 , 主要包括管理费和基金的交易成本。指数基金的管理费一般较主动式基金的低 0.5% 至 1% ；至于交易成本方面 , 主要是由于指数基金一般比主动式基金的买卖活动少 , 因而交易成本较低 , 大约可以节省 0.5% 至 2% 不等。 3 、 ETF 通常跟踪什么样的标的指数 ?答 : 指数是用来衡量各市场或产业走势的指标。每只 ETF 均跟踪某一个特定指数 , 所跟踪的指数即为该只 ETF 的 “ 标的指数 “ 。 “ 标的指数 “ 的选取对 ETF 产品有非常重要的影响。一般 ,ETF 的 “ 标的指数 “ 要求具有知名度、市场代表性、良好的流动性和编制的稳定、客观与透明。上证 50 指数符合 ETF 产品的有关要求 , 适合作为上证所首只 ETF 产品的 “ 标的指数 “ 。 4 、 ETF 与标的指数有何关联 ?答 : 为了使 ETF 市价能够直观地反映所跟踪的标的指数 , 产品设计人有意在产品设计之初就将 ETF 的净值和股价指数联系起来 , 将 ETF 的单位净值定为其标的指数的某一百分比。这样一来 , 投资者通过观察指数的当前点位 , 就可直接了解投资 ETF 的损益 , 把握时机 , 进行交易。例如 : 上证 50 指数 ETF 的基金份额净值设计为上证 50 指数的千分之一。因此当上证 50 指数为 1234 点时 , 上证 50 指数 ETF 的基金份额净值应约为 1.234 元；当上证 50 指数上升或下跌 10 点 , 上证 50 指数 ETF 之单位净值应约上升或下跌 0.01 元。 5 、投资 ETF 与买卖标的指数成份股有何内在联系 ?答 : 投资人可通过买或卖 ETF 而达到买或卖指数一篮子成份股票的效果 , 这样单笔投资便可获得多元化投资效果 , 节省大量的时间及金钱。以上证 50 指数 ETF 为例 , 若每一单位上证 50 指数 ETF 为 1 元 , 则投资人在上海证券交易所买卖 1 个交易单位 (“1 手 “) 的 ETF 需花费 100 元。ETF 的基金管理人为了求得紧密追踪标的指数的表现 , 其基金持股组合的个股权重会与标的指数成份股在指数中的权重紧密保持一致。例如 , 上证 50 指数基本上是由上海证券交易所市场规模大、流动性好的最具代表性的 50 只股票组成 , 其中中国联通占上证 50 指数的比重约为 8.5%, 中国石化占上证 50 指数的比重约为 4.7% 等等。投资人只需花费 100 元购买 1 手上证 50 指数 ETF, 便如同同时投资了 50 只股票 , 其中约投资中国联通 8.5 元 , 中国石化 4.7 元等等 , 以此类推。因此 , 买入上证 50 指数 ETF 等于买入了一个报酬率涵盖 50 只股票而风险分散的投资组合。 6 、投资 ETF 与投资股票有何不同?答 : 在交易方式上 ,ETF 与股票完全相同 , 投资人只要有证券账户 , 就可以在盘中随时买卖 ETF, 交易价格依市价实时变动 , 相当方便并具有流动性。 ETF 比直投资股票的好处在于 :1 、和封闭型基金一样没有印花税。 2 、买入 ETF 就相当于买入一个指数投资组合。例如 , 对于首只以上证 50 指数为标的的 ETF, 其价格走势应会与上证 50 指数走势一致 , 所以买入上证 50 指数 ETF, 就等于买进 50 只绩优的股票 , 对中小投资人来说可达到分散风险的效果。 3 、在投资组合透明度方面 , 上证 50 指数由上海证券交易所编制 , 包括市值排名靠前的上市公司中的 50 家 , 指数成分可以说相当透明 , 投资人可直接投资一只 ETF 来取代投资这一篮子 50 只股票组合。 7 、 ETF 与一般开放式基金有何不同 ?答 :ETF 的中文名称为 “ 交易型开放式指数基金 “, 虽然从名称本身看来跟一般传统开放式共同基金差不多 , 但实际上在交易成本、基金管理方式与交易方式等方面有较大的差异。首先 ETF 的申购是指投资者用指定的一篮子指数成份股实物 ( 开放式基金用的是现金 ) 向基金管理公司换取固定数量的 ETF 基金份额；而赎回则是用固定数量的 ETF 基金份额向基金管理公司换取一篮子指数成份股 ( 而非现金 ) 。其次在交易成本方面。传统开放式基金每年需支付约 1.0%-1.5% 之间的管理费 , 较 ETF 的管理费 ( 约 0.3%-0.5%) 高出很多；另外 , 传统开放式基金申购时需要支付 1% 左右的手续费 , 赎回时需支付 0.5% 左右的手续费 , 而 ETF 则仅于交易时支付证券商最多 0.2% 的佣金 , 与开放式基金的交易成本相比相对便宜。再次在基金管理方式方面。 ETF 管理的方式属于 “ 被动式管理 “,ETF 管理人不会主动选股 , 指数的成份股就是 ETF 这只基金的选股 ,ETF 操作的重点不是在打败指数 , 而是在追踪指数。一只成功的 ETF 能够尽可能与标的指数走势一模一样 , 即能 “ 复制 “ 指数 , 使投资人安心地赚取指数的报酬率。传统股票型基金的管理方式则多属于 “ 主动式管理 “, 基金经理主要通过积极选股达到基金报酬率超越大盘指数的目的。另外在交易方式方面。 ETF 上市后 , 交易方式就如股票一样 , 价格会在盘中随时变动 , 投资人可在盘中下单买卖 , 十分方便；而传统开放式基金则是根据每日收盘后的基金份额净值作为当日的交易价格。 8 、投资 ETF 的风险与报酬是什么 ?答 : 投资的风险与报酬是投资人在决定投资之前所必须要了解的 , 也是最重要的两个问题。投资 ETF 的报酬主要有两点 :1 、买进与卖出 ETF 的价差报酬； 2 、持有 ETF 所获得的现金分红收入。投资 ETF 的风险可归纳为以下几点 :1 、市场风险 :ETF 的基金份额净值随其所持有的股票价格变动的风险； 2 、被动式投资风险 :ETF 并非以主动方式管理 , 基金管理人不会试图挑选个别股票 , 或在逆势中采取防御措施； 3 、追踪误差风险 : 由于 ETF 会向基金持有人收取基金管理费、基金托管费等费用 ,ETF 在日常投资操作中存在着一定交易费用 , 以及基金资产与追踪标的指数成份股之间存在少许差异 , 可能会造成 ETF 的基金份额净值与标的指数间存在些许落差的风险。 9 、 ETF 投资组合的透明度如何 ?答 :ETF 投资组合充分透明。 ETF 被动跟踪指数 , 每日公布投资组合 , 具有公开透明的优点 , 减少了基金管理人潜在的道德风险。 10 、投资 ETF 对中小投资人有什么好处 ?答 : 以上证 50 指数 ETF 为例 , 由于该 ETF 的价格走势应会与上证 50 指数走势一致 , 所以买卖一只 ETF, 就等于同时买进五十只绩优的股票。ETF 买卖交易流程就像投资股票一样简单 , 对中小投资人而言 , 亦兼具基金及股票的优点 , 为其提供了一个方便快捷、灵活及费用低廉的投资渠道 , 以一笔交易即可直接投资一篮子股票 , 充分分散风险。由于 ETF 走势与股市同步 , 投资人不需研究个股 , 只要判断涨跌趋势即可 , 所以 ETF 是最不费力的投资工具 , 每日买卖都很方便；在风险分散方面 , 也比投资单一股票要小得多 , 也不会发生 “ 赚了指数 , 赔了钱 “ 的情况。 11 、中小投资人买卖 ETF 要注意什么 ?答 : 由于 ETF 的套利机制使得 ETF 的买卖价格与 ETF 的基金份额净值应不会长期存在较大差异 , 投资人应能以接近基金份额净值的市价买卖 ETF, 所以当 ETF 市价高于 ( 低于 ) 基金份额估计净值幅度较大时 , 投资人不宜追涨 ( 杀跌 ), 以免以不合理的价格买进 ( 卖出 )ETF 而遭受损失。 12.ETF 是否适合积极选股的投资者 ?答 : 对积极型的投资人来说 , 可以将指数化投资的 ETF 搭配自己积极选股的策略 , 或搭配部分主动式管理的共同基金进行资产配置 , 执行 “ 核心 / 卫星 “ 投资组合策略。简单来说 , 以 ETF 作为核心持股 , 以确保配置于这部分的资金投资绩效可与大盘联动 , 不会错失大盘上涨的机会。另外 , 投资人可根据自身对证券市场后市行情的研判 , 选择个股或另外再搭配产业型或特殊型的共同基金。 13 、如何买卖 ETF?答 :ETF 的交易与股票和封闭式基金的交易完全相同 , 基金份额是在投资者之间买卖的。投资者利用现有的上海证券账户或基金账户即可进行交易 , 而不需要开设任何新的账户。示意图如下 : 14 、 ETF 在上海证券交易所的交易单位是多少 ?答 :ETF 如同股票及封闭式基金 , 在上海证券交易所以 100 个基金单位为 1 个交易单位 ( 即 “1 手 “), 并可适用大宗交易的相关规定。 15 、 ETF 的涨跌幅度是多少 ?答 : 与股票、封闭式基金相同 , 为 10% 。 16 、 ETF 的价格升降单位和股票、封闭式基金是否不同 ?答 : 为使 ETF 的价格能充分反映标的指数的变化 ,ETF 在升降单位和封闭式基金相同 , 为 1 厘。这样 , 上证 50 指数每升 ( 降 )1 点 , 每单位的 ETF 基金份额的净值就相应升 ( 降 )0.001 元 (1 厘 ) 。 17 、买卖 ETF 有哪些成本 ?答 :ETF 的买卖成本和封闭式基金完全相同。 18 、什么是 ETF 基金份额的净值 ?答 : 同一般开放式基金一样 ,ETF 的基金份额净值 (NAY) 是指每份 ETF 所代表的证券投资组合 ( 包括现金部分 ) 的价值 , 即以基金净资产除以发行在外的基金份额总数。 19 、什么是 ETF 参考单位净值 (IOPV)?答 :ETF 是参考单位基金净值 (IOPV) 是由交易所计算的 ETF 实时单位净值的近似值 , 以便于投资者估计 ETF 交易价格是否偏离了内在价值。上海证券交易所除了每 15 秒钟揭示上证 50 指数外 , 也会在相同时间间隔内 , 揭示上证 50 指数 ETF 的单位基金份额估计净值 (IOPV), 以供投资人参考。 20 、 ETF 会不会像封闭式基金一样出现大幅折、溢价 ?答 : 与封闭式基金很不相同的是 , 当 ETF 出现折、溢价时 , 套利者会通过 “ 实物申购与赎回 “ 机制来消除差价。这种独特的内在机制可将 ETF 的折 ( 溢 ) 价空间压缩在极小范围之内。 21 、什么是 ETF 的 “ 实物申购、赎回 ?”答 :ETF 的基金管理人每日开市前会根据基金资产净值、投资组合以及标的指数的成份股情况 , 公布 “ 实物申购与赎回 “ 清单 ( 也称 “ 一篮子股票档案文件 “) 。投资人可依据清单内容 , 将成份股票交付 ETF 的基金管理人而取得 “ 实物申购基数 “ 或其整数倍的 ETF ；以上流程将创造出新的 ETF, 使得 ETF 在外流通量增加 , 称之为实物申购。实物赎回则是与之相反的程序 , 使得 ETF 在外流通量减少 , 也就是投资人将 “ 实物申购基数 “ 或其整数倍的 ETF 转换成实物申购赎回清单的成份股票的流程。ETF 的实物申购与赎回只能以实物交付 , 只有在个别情况下 ( 例如当部分成份股因停牌等原因无法从二级市场直接购买 ), 可以有条件地允许部分成份股采用现金替代的方式。举例而言 , 对于上证 50 指数 ETF,” 申购 “ 是指用一篮子指数成份股股票换取一定数额的 ETF 基金份额。例如 , 投资者可使用 187 手中国联通、 36 手浦发银行、 12 手白云机场等 50 只股票 , 换取 100 万份 ETF 基金份额 ( 即 1 个 “ 最小申购、赎回单位 “) ；或者 374 手中国联通、 72 手浦发银行、 24 手白云机场等 50 只股票 , 换取 200 万份 ETF 基金份额 ( 即 2 个 “ 最小申购、赎回单位 “) 。” 赎回 “ 的过程则相反 , 是指用一定数额的 ETF 份额换取一篮子指数成份股股票 , 例如 ,100 万份 ETF 基金份额 (1 个 “ 最小申购、赎回单位 “) 可以换取 187 手中国联通、 36 手浦发银行、 12 手白云机场等 50 只股票。如果是 200 万份 ETF 基金份额 ( 即 2 个 “ 最小申购、赎回单位 “), 则可以换取 374 手中国联通、 72 手浦发银行、 24 手白云机场等 50 只股票。可见 “ 实物申购、赎回 “ 的交易对手方是投资者和基金。 22 、什么是 “ 最小申购、赎回单位 “?答 :ETF 实物申购与赎回的基本单位 , 称为 “ 最小申购、赎回单位 “ 或 “ 实物申购基数 “ 。每一只 ETF” 最小申购、赎回单位 “ 可能不尽相同 , 以上证 50 指数为标的的首只 ETF 为例 , 其 “ 最小申购、赎回单位 “ 为一百万份基金份额。由于 “ 最小申购、赎回单位 “ 的金额较大 , 故一般情况下 , 只有证券自营商等机构投资者以及资产规模较大的个人投资者才能参与 ETF 的 “ 实物申购与赎回 “ 。 23 、 ETF 的 “ 实物申购、赎回 “ 机制对 ETF 有何重要性 ?ETF 的 “ 实物申购、赎回 “ 机制与套利行为有何关联 ?答 :ETF” 实物申购与赎回 “ 机制是这一产品结构的精髓 , 正是这一机制才迫使 ETF 价格与净值趋于一致 , 极大地减少了 ETF 折 ( 溢 ) 价幅度。在大多数情况下 , 套利一定需要进行申购或赎回 ,ETF 的套利行为简要说明如下 :首先 , 当 ETF 在交易所市场的报价低于其二级市场以低于资产净值的价格大量买进 ETF, 然后于一级市场赎回一篮子股票 , 再于二级市场中卖掉股票 , 赚取之间的差价。这一套利机制 , 将可促使 ETF 在交易所市场的交易价格受到机构套利买盘进场而带动报价上扬 , 缩小其折价差距 , 产生让 ETF 的市场交易价格与基金份额净值趋于一致的效果。其次 , 当 ETF 在交易所市场的报价高于其资产净值时 , 也就是发生溢价时 , 机构可以在二级市场买进一篮子股票 , 然后于一级市场申购 ETF, 再于二级市场中以高于基金份额净值的价格将此申购得到的 ETF 卖出 , 赚取之间的差价。这一套利机制 , 将可促使 ETF 在交易所市场的交易价格收到机构套利卖盘进场而带动报价下跌 , 缩小其溢价差距 , 同样产生让 ETF 的市场交易价格与基金份额净值趋于一致的效果。也正是由于此一套利机制 , 让机构乐于积极地参与 ETF 交易 , 进而带动 ETF 市场的活跃。当套利活动在交易所 ETF 市场上比较活跃时 ,ETF 的折、溢价空间将会逐渐缩小；当 ETF 在交易所市场的报价与资产净值趋于一致时 , 又会加强一般中小投资人投资 ETF 的意愿 , 进而促使整体 ETF 市场更加蓬勃发展 , 因此 , 此一套利机制是促使机构与中小投资人积极进场的非常关键因素 , 也是塑造一只成功 ETF 不可或缺的重要因素。 上证50ETF指数基金的“净值”、“折价率”是怎么一回事？如何利用它们买卖基金？ETF是指数股票型基金，它的价格是由市场供需两方力量拉锯决定出来的，它的“净值”则是根据基金总资产减总负债后，除以发行总份数计算出来的。理论上这种ETF基金的市价，应该随时等於净值。但因市场上多空推移的缘故，市价经常偏离净值。如果市价低於净值，“折价率”大於0%；如果市价高於净值，“折价率”小於0%(此时以溢价率大於0来论)。如何利用它们买卖基金呢？如果市价低於净值，“折价率”大於0%；则投资人将推论市价终将回归净值，亦即ETF市价将会走扬，此时可以买进ETF，同时放空指数成份股来套利。反之，如果市价高於净值，“折价率”小於0%；则投资人将推论市价亦终将回归净值，亦即ETF市价将会走跌，此时此时可以放空ETF同时买进指数成份股来套利。.以上所述一切顺理成章，唯其难处在於，1.投资人不易随时发现基金净值与“折价率”的值；2.买卖ETF容易，做多放空指数成份股难。有50支股票耶！怎麼一次性全部买卖？一般做这种套利的都是法人，起码做一次要丢进来几个仟万甚至上亿，才能赚到价差。3.由於理论上这种ETF基金的市价，应该随时等於净值。因此套利者都是随时盯著盘看，一有显著偏离，立马就做套利，十拿九稳。可它的利润其实不会很大。用力多而收效少，一般股民不玩这个也罢！.总之，一般股民听听套利就好，知道学理就好，别太当一回事。这种交易一般人是玩不起的。","categories":[{"name":"金融","slug":"金融","permalink":"http://yoursite.com/categories/金融/"},{"name":"投资","slug":"金融/投资","permalink":"http://yoursite.com/categories/金融/投资/"}],"tags":[]},{"title":"技术","slug":"金融/投资/技术","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:11:14.598Z","comments":true,"path":"passages/金融/投资/技术/","link":"","permalink":"http://yoursite.com/passages/金融/投资/技术/","excerpt":"","text":"十个经济数据 工业生产总值：它贡献了大部分的GDP，表示报告期内的工业生产总量。 货币供应量：M0是流通中的资金，M1是M0＋企业活期存款＋机关存款＋农村存款＋个人信用卡存款，M2是M1＋居民储蓄＋企业定期＋外币和信托，M3是M2＋金融债券＋商业票据＋大额存单。M1通常叫做狭义货币量，流动性强；M2是广义货币量，流动性较弱，M2与M1的差额叫准货币；M3是金融创新用途。M1反应现实购买力，M2还反应了潜在购买力，M1增速快说明消费端活跃，M2增速快说明投资市场活跃 进出口总额：代表国内商品的竞争力 通货膨胀：代表货币贬值，购买力下降，通常用CPI来反应。通货膨胀会造成财富重新分配，固定资产价格上升，低收入者无力投资，反而更多的花销投入。通货紧缩同样危害很大，它会减少企业利润，导致裁员，进入恶性循环 PMI采购经理人指数：反应商业活动的现实情况，反应整体工商业的增长和衰退情况，通常会领先GDP几个月时间，具有指导意义 用电量：经济冷暖风向标 CPI消费者价格指数：投资第一目标是跑赢CPI PPI生产者物价指数：会传到 CPI 社会消费品零售总额： 消费者信心指数 ENE反向指标 震荡市场，振幅可以有20个点，破下轨买入，破上轨卖出 趋势向上的股票，可能会回到中轨，振幅在10个点，会中轨观察5分钟均线是否能多头排列，在考虑进场 下跌趋势，也可能回中轨，下轨买入点看 5，10，20，30，60均线能否多头排列，中轨5分钟空头排列卖出 macd在 0轴以上，打下轨是好买点 到下轨 7天横盘不涨还会下跌10个点，到上轨7天横盘不跌还会涨 10个点 还好考虑趋势和浪行，会加强或削弱ENE作用 一般参数是 10－11－9，极端用参数 5－11－9 个股健康检查 大盘多头排列时，个股是否同样 大盘延10日线向上，个股如何 大盘融资平稳增加，个股融资有没有爆减或暴增 成交量是否稳定增加 个股是否乖离过大，可用均线或ENE判断","categories":[{"name":"金融","slug":"金融","permalink":"http://yoursite.com/categories/金融/"},{"name":"投资","slug":"金融/投资","permalink":"http://yoursite.com/categories/金融/投资/"}],"tags":[]},{"title":"债券","slug":"金融/投资/债券","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:11:19.529Z","comments":true,"path":"passages/金融/投资/债券/","link":"","permalink":"http://yoursite.com/passages/金融/投资/债券/","excerpt":"","text":"可转换债券是什么意思？可转换债券又称为可转换公司债券是一种被赋予了股票转换权的特殊公司债券。可转换债券持有人可以按发行时规定的条件把其债券转换成发行公司的等值普通股票。发行可转换债券的公司事先规定债权人可以选择有利时机，也就是当债权人看见该公司经营业绩良好，经营前景乐观，公司股票看涨时，就可将债券转换为股票，以受益于公司的发展。 可转换债券具有哪些特点？可转换债券因为可以转换为普通股票所以具有债券和股票的特性， 特点一：可转换债券的债权性：可转换债券是一种公司债券他与其他债券一样，有规定的利率和期限。如果债券人持有可转换债券指导到期，那么他就有权收取利息和要回本金。但是在可转换债券转换成公司普通股票之前，它仅仅是一种债券，持有者只有收取利息和收回本金的保证而不享受股票持有人的分区公司红利和参与公司决策的权利。 特点二：可转换债券的股权性：从可转换债券这个概念我们就可以看出这种债券不是普通的债券，它的这个课转换型说的就是持有可转换债券的投资者可以将该债券转换为改公司的普通股票。因此转换之后的可转换债券就拥有了股票的性质了。当可转换债券的持有者讲债券转换为股票之后，他就成为了该公司的股东之一。也就是说，之前的可转换债券就享有了股票的股权性，它让它的持有者有权享受公司的红利分红，也有权参与公司的重大决策。这就是可转换债券的股权性，我们需要注意的是，可转换债券并不是一开始就具有股权性，而是在转换之后才拥有的，当然可转换债券的持有人也可以不转换为股票，而一直持有这种债券，那么它就不具有股权性了。 特点三：可转换债券的可转换性：前面第二点我们说得很清楚了，可转换债券本身已告诉我们它是一种可以转换的债券。这种转换性是它与普通债券区分的主要标志。这种在债券和股票直接转换的权利，一般的债券持有者是不享有的。也就是说持有课转换债券的投资者，在自己乐意的情况下可以转换为股票，享受股权。但是他也可以一直持有这种债券，直到债券到期，从而获得利息和收回本金。 特点四：可转换债券的利率较低：前面我们讲过可转换债券比一般债券多了一中转换为股票的权利，另外可转换债券的持有人还具有将该债券回售给发行人的权利。因此可转换债券比一般债券的稳健性高很多，那么我们不难理解，其利率比一般的债券低的特点了。可转换债券对于投资者来说是一种较为安全的投资形式，对于发行企业来说，因为其利率低，所以是一种比较理想的筹资手段。","categories":[{"name":"金融","slug":"金融","permalink":"http://yoursite.com/categories/金融/"},{"name":"投资","slug":"金融/投资","permalink":"http://yoursite.com/categories/金融/投资/"}],"tags":[]},{"title":"taobaoExperience","slug":"软件开发/系统架构/分布式架构/taobaoExperience","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:14:28.464Z","comments":true,"path":"passages/软件开发/系统架构/分布式架构/taobaoExperience/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/分布式架构/taobaoExperience/","excerpt":"","text":"高可靠消息服务总体架构 消息系统从部署上分为三个子系统，路由系统、存储系统以及推送系统。消息数据先存储再推送，保证每条消息至少推送一次。写入与推送分离，发送方不同步等待接收方应答，客户端的任何异常不会影响发送方系统的稳定性. 路由系统，各个处理模块管道化，扩展性强。系统监听主站的交易、商品、物流等变更事件，针对不同业务进行消息过滤、鉴权、转换、存储、日志打点等。系统运行过程记录各个消息的处理状况，通过日志采集器输出给 JStorm 分析集群处理并记录消息轨迹，做到每条消息有迹可循。 存储系统 , 主要用于削峰填谷，基于 BitCask 存储结构和内存映射文件，磁盘完全顺序写入，速度极佳。数据读取基于 FileRegion 零拷贝技术，减少内存拷贝消耗，数据读取速度极快。存储系统部署在多个机房，有一定容灾能力。 推送系统，基于 Disputor 构建事件驱动模型，使用 Netty 作为网络层框架，构建海量连接模型，根据连接吞吐量智能控制流量，降低慢连接对系统的压力；使用 WebSocket 构建 长连接通道，延时更低；使用对象池技术，有效降低系统 GC 频率；从消息的触发，到拉取，到发送，到确认整个过程完全异步，性能极佳 推送还是拉取在消息系统中，一般有两种消费模式：服务端推送和客户端拉取。本系统主要面向公网的服务器，采用推送模式，有如下优点 ： 实时性高。从消息的产生到推送，总体平均延时100毫秒，最大不超过200毫秒。 服务器压力小。相比于拉取模式，每次推送都有数据，避免空轮询消耗资源。 使用简便。使用拉取模式，客户端需要维护消费队列的位置，以及处理多客户端同时消费的并发问题。而在推送模式中，这些事情全部由服务器完成，客户端仅需要启动SDK监听消息即可，几乎没有使用门槛。 当然，系统也支持客户端拉取，推送系统会将客户端的拉取请求转换为推送请求，直接返回。推送服务器会据此请求推送相应数据到客户端。即拉取异步化，如果客户端没有新产生的数据，不会返回任何数据，减少客户端的网络消耗。 保证低延时推送在采用推送模式的分布式消息系统中，最核心的指标之一就是推送延时。各个长连接位于不同的推送机器上，那么当消息产生时，该连接所在的机器如何快速感知这个事件？ 在本系统中，所有推送机器彼此连接（如图 6 所示），构成一个通知网，其中任意一台机器感知到消息产生事件后，会迅速通知此消息归属的长连接的推送机器，进而将数据快速推送给客户端。而路由系统每收到一条消息，都会通知下游推送系统。上下游系统协调一致，确保消息一触即达 快速确认消息评估消息系统另外一个核心指标是消息丢失问题。由于面向广大开发者，因此系统必须兼顾各种各样的网络环境问题，开发者能力问题等。为了保证不丢任何一条消息，针对每条推送的消息，都会开启一个事务，从推送开始，到确认结束，如果超时未确认就会重发这条消息，这就是消息确认。 由于公网环境复杂，消息超时时间注定不能太短，如果是内网环境，5 秒足矣，消息事务在内存就能完成。然后在公网环境中，5 秒远远不够，因此需要持久化消息事务。在推送量不大的时候，可以使用数据库记录每条消息的发送记录，使用起来也简单方便。但是当每秒推送量在百万级的时候，使用数据库记录的方式就显得捉襟见肘，即便是分库分表也难以承受如此大的流量。 对于消息推送事务数据，有一个明显特征，99% 的数据会在几秒内读写各一次，两次操作完成这条数据就失去了意义。在这种场景，使用数据库本身就不合理，就像是在数据库中插入一条几乎不会去读的数据。这样没意义的数据放在数据库中，不仅资源浪费，也造成数据库成为系统瓶颈. 针对这种场景，本系统在存储子系统使用 HeapMemory、DirectMemory、FileSystem 三级存储结构。为了保护存储系统内存使用情况，HeapMemory 存储最近 10 秒发送记录，其余的数据会异步写入内存映射文件中，并写入磁盘。HeapMemory 基于时间维度划分成三个HashMap，随着时钟滴答可无锁切换，DirectMemory 基于消息队列和时间维度划分成多个链表，形成链表环，最新数据写入指针头链表，末端指针指向的是已经超时的事务所在链表。这里，基于消息队列维护，可以有效隔离各个队列之间的影响；基于时间分片不仅能控制链表长度，也便于扫描超时的事务。 在这种模式下，95% 的消息事务会在 HeapMemory 内完成，5% 的消息会在 DirectMemory 完成，极少的消息会涉及磁盘读写，绝大部分消息事务均在内存完成，节省大量服务器资源。 零漏单数据同步我们已经有了 API 网关以及可靠的消息服务，但是对外提供服务时，用户在订单数据获取中常常因为经验不足和代码缺陷导致延迟和漏单的现象，于是我们对外提供数据同步的服务。 传统的数据同步技术一般是基于数据库的主备复制完成的。在简单的业务场景下这种方法是可行的，并且已经很多数据库都自带了同步工具。但是在业务复杂度较高或者数据是对外同步的场景下，传统的数据同步工具就很难满足灵活性、安全性的要求了，基于数据的同步技术无法契合复杂的业务场景。 双 11 场景下，数据同步的流量是平常的数十倍，在峰值期间是百倍，而数据同步机器资源不可能逐年成倍增加。保证数据同步写入的平稳的关键在于流量调控及变更合并。 分布式数据一致性保证在数据同步服务中，我们使用了消息 + 对账任务双重保障机制，消息保障数据同步的实时性，对账任务保障数据同步一致性。以订单数据同步为例，订单在创建及变更过程中都会产生该订单的消息，消息中夹带着订单号。接受到该消息后，对短时间内同一订单的消息做合并，数据同步客户端会拿消息中的订单号请求订单详情，然后写入 DB。消息处理过程保证了订单在创建或者发生了任意变更之后都能在极短的延迟下更新到用户的 DB 中","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"分布式架构","slug":"软件开发/系统架构/分布式架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/分布式架构/"}],"tags":[]},{"title":"Hibernate","slug":"软件开发/系统架构/Spring相关/Hibernate","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:14:15.615Z","comments":true,"path":"passages/软件开发/系统架构/Spring相关/Hibernate/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/Spring相关/Hibernate/","excerpt":"","text":"[TOC] 既然说到了Hibernate就把JDBC（Java DataBase Connection）顺带说一下好了，它做为SUN提供的一个数据库接口标准，基本上也是现行的java连接数据库的标准接口，Hiberante也是建立在它的基础之上。简单的说JDBC就是一个标准接口，看过它的源代码就知道其中提供了大量的接口，可以通过这些接口得到connection,执行SQL，返回结果集等数据库操作。再有一点就是数据库驱动是什么？都知道不同的数据库有不同的数据库驱动，打开数据库驱动的包，你就可以看到其实它实现了JDBC中定义的一些接口，例如Connection类就是由数据库驱动包提供的实现类，因为不同的数据库connect的方法一定不同，所以要提供不同的实现，数据库驱动就像一个适配器，在数据库与JDBC之间充当转换的角色。 下面我们就来看一下Hibernate，先解释一下持久化（Persistence）简单的说，就是把数据保存到掉电式存储设备中供之后所用（如硬盘，光盘等）。大多数情况下，特别是企业级应用，数据持久化也就意味着将内存中的数据保存到磁盘上加以“固化”，而持久化的实现过程则大多通过各种关系型数据库来完成。Hibernate一个O/R Mapping 框架，为了消除关系数据库与面向对象语言之间的阻抗。Hibernate的关键点 数据库操作就是一些Hibernate提供的方法用来访问数据库使用的，功能和JDBC的SQL语句类似，里面细节狂多，在这里就不一一说明了。如save,update,load等方法 实体对象的3种状态这个特性与数据库操作相关紧密，也就是与session相关联，因为在Hibernate中session就类似于connection。因为Hibernate做为一个O/R Mapping框架从数据库中取数据的数据都是对象形式的，所以说三种对象的关系一定要搞清楚。 关联关系就是用来配置数据库中的1:N,1:1,M:N关系如何在面向对象的实现的，涉及到级联操作、延迟加载等内容 对象映射也叫做继承映射，面向对象下面向关系最大的不同就是类的继承方面，这一特性就是用来把数据库中的表如何映射到类的继承关系中的。 Cache管理Cache分为一级缓存与二级缓存，一级缓存在Hibernate中就是session，二级缓存是第二方提供的，作用都是为提高性能。 延迟加载也是为了提高性能，对于暂时不需要的数据不进行加载，到使用时再加载，特别是对于存在1：N关系时很有用。以上几点以下都有更详细的说明。 Hibernate 配置Hibernate同时支持xml 格式的配置文件，以及传统的properties文件配置方式，不过这里建议采用xml 型配置文件。xml配置文件提供了更易读的结构和更强的配置能力，可以直接对映射文件加以配置，而在properties文件中则无法配置，必须通过代码中的Hard Coding加载相应的映射文件。配置文件名默认为“hibernate.cfg.xml”（或者hibernate.properties），Hibernate 初始化期间会自动在CLASSPATH 中寻找这个文件，并读取其中的配置信息，为后期数据库操作做好准备。配置文件应部署在CLASSPATH 中，对于Web 应用而言，配置文件应放置在在\\WEB-INF\\classes 目录下。 Hibernate基础语义Configuration正如其名，Configuration 类负责管理Hibernate 的配置信息。Hibernate 运行时需要获取一些底层实现的基本信息，其中几个关键属性包括：1． 数据库URL2． 数据库用户3． 数据库用户密码4． 数据库JDBC驱动类5． 数据库dialect，用于对特定数据库提供支持，其中包含了针对特定数据库特性的实现，如Hibernate数据类型到特定数据库数据类型的映射等。使用Hibernate 必须首先提供这些基础信息以完成初始化工作，为后继操作做好准备。这些属性在hibernate配置文件（hibernate.cfg.xml 或hibernate.properties）中加以设定Configuration 类一般只有在获取SessionFactory时需要涉及，当获取SessionFactory 之后，由于配置信息已经由Hibernate 维护并绑定在返回的SessionFactory之上，因此一般情况下无需再对其进行操作。 SessionFactorySessionFactory 负责创建Session 实例。我们可以通过Configuation 实例构建SessionFactory：Configuration实例config会根据当前的配置信息，构造SessionFactory实例并返回。SessionFactory 一旦构造完毕，即被赋予特定的配置信息。也就是说，之后config 的任何变更将不会影响到已经创建的SessionFactory 实例（sessionFactory）。如果需要使用基于改动后的config 实例的SessionFactory，需要从config 重新构建一个SessionFactory实例。 SessionSession是持久层操作的基础，相当于JDBC中的Connection。Session实例通过SessionFactory实例构建： 数据检索数据查询与检索是Hibernate中的一个亮点。相对其他ORM实现而言，Hibernate提供了灵活多样的查询机制。其中包括： Criteria Query Hibernate Query Language (HQL) SQL 关于unsaved-value在非显示数据保存时，Hibernate将根据这个值来判断对象是否需要保存。一般为null就OK，用在级联中，未保存的记录id是null,与unsaved-value值对比相等就做为新的记录插入，不相等说明是原有的记录做更新操作，做为PO操作 Inverse和CascadeInverse，直译为“反转”。在Hibernate语义中，Inverse指定了关联关系中的方向。关联关系中，inverse=”false”的为主动方，由主动方负责维护关联关系。具体可参见一对多关系中的描述。而Cascade，译为“级联”，表明对象的级联关系，如TUser的Cascade设为all，就表明如果发生对user对象的操作，需要对user所关联的对象也进行同样的操作。如对user对象执行save操作，则必须对user对象相关联的address也执行save操作。 延迟加载（Lazy Loading）为了避免一些情况下，关联关系所带来的无谓的性能开销。Hibernate引入了延迟加载的概念。所谓延迟加载，就是在需要数据的时候，才真正执行数据加载操作。对于我们这里的user对象的加载过程，也就意味着，加载user对象时只针对其本身的属性，而当我们需要获取user对象所关联的address信息时（如执行user.getAddresses时），才真正从数据库中加载address数据并返回。 Hibernate.initialize方法可以通过强制加载关联对象实现这一功能：强制加载一个对象，可以在session关闭后继续读取为了实现透明化的延迟加载机制，hibernate进行了大量努力。其中包括JDKCollection接口的独立实现。 如果我们尝试用HashSet强行转化Hibernate返回的Set型对象：Set hset = (HashSet)user.getAddresses();就会在运行期得到一个java.lang.ClassCastException,实际上，此时返回的是一个Hibernate的特定Set实现“net.sf.hibernate.collection.Set”对象，而非传统意义上的JDK Set实现。这也正是我们为什么在编写POJO时，必须用JDK Collection接口（如Set,Map）,而非特定的JDK Collection实现类（如HashSet、HashMap）申明Collection属性的原因。由于拥有自身的Collection实现，Hibernate就可以在Collection层从容的实现延迟加载特性。只有程序真正读取这个Collection时，才激发底层实际的数据库操作。 Cache管理Cache对于大量倚赖数据读取操作的系统而言（典型的，如114查号系统）尤为重要，在大并发量的情况下，如果每次程序都需要向数据库直接做查询操作，所带来的性能开销显而易见，频繁的网络传输、数据库磁盘的读写操作（大多数数据库本身也有Cache，但即使如此，访问数据库本身的开销也极为可观），这些都大大降低了系统的整体性能。 引入Cache机制的难点是如何保证内存中数据的有效性，否则脏数据的出现将给系统带来难以预知的严重后果。 Hibernate 中实现了良好的Cache 机制，我们可以借助Hibernate 内部的Cache迅速提高系统数据读取性能。 需要注意的是：Hibernate做为一个应用级的数据访问层封装，只能在其作用范围内保持Cache中数据的的有效性，也就是说，在我们的系统与第三方系统共享数据库的情况下，Hibernate的Cache机制可能失效。 Hibernate 在本地JVM 中维护了一个缓冲池，并将从数据库获得的数据保存到池中以供下次重复使用（如果在Hibernate中数据发生了变动，Hibernate同样也会更新池中的数据版本）。外部系统的定义，并非限于本系统之外的第三方系统，即使在本系统中，如果出现了绕过Hibernate数据存储机制的其他数据存取手段，那么Cache的有效性也必须细加考量。如，在同一套系统中，基于Hibernate和基于JDBC的两种数据访问方式并存，那么通过JDBC更新数据库的时候，Hibernate同样无法获知数据更新的情况，从而导致脏数据的出现。用EHCache作为其默认的第二级Cache实现。相对JCS，EHCache更加稳定，并具备更好的缓存调度性能，缺陷是目前还无法做到分布式缓存，如果我们的系统需要在多台设备上部署，并共享同一个数据库，必须使用支持分布式缓存的Cache实现（如JCS、JBossCache）以避免出现不同系统实例之间缓存不一致而导致脏数据的情况。 Spring与hibernate结合使用 123456public class UserDAO extends HibernateDaoSupport implements IUserDAO&#123;public void insertUser(User user) &#123;getHibernateTemplate().saveOrUpdate(user);&#125;&#125; 上面的UserDAO实现了自定义的IUserDAO接口，并扩展了抽象类：HibernateDaoSupportHibernateDaoSupport实现了HibernateTemplate和SessionFactory实例的关联。HibernateTemplate对Hibernate Session操作进行了封装，而HibernateTemplate.execute方法则是一封装机制的核心，感兴趣可以研究一下其实现机制。 借助HibernateTemplate我们可以脱离每次数据操作必须首先获得Session实例、启动事务、提交/回滚事务以及烦杂的try/catch/finally等繁琐操作。从而获得以上代码中精干集中的逻辑呈现效果。 数据库操作 通过get(),load()方法都可以得到特定对象，它的区别是，get从一级缓存和数据库中查找，找不到返回NULL，load从一级缓存，二级缓存和数据库中查找，找不到抛出ObjectNotFindException. Session.createQuery().find()和Session.createQuery().iterator(),a) 前者是直接从数据库中查询放入缓存中，对缓存只写不读，就算是相同的SQL语句也会多次执行，不会从缓存中查找。b) 后者是很执行一次SQL把ID取出，再根据ID在缓存中找，缓存中找不到就执行相当于get的SQL语句，它利用到了缓存，但也可能产生N＋1SQL问题。 实体对象的3种状态实体对象可以分为三个阶段：1．只是一个对象。2.对象与数据库中记录有对应关系。3.对象与数据库有对应关系并且也保存在session缓存中，也就是说与session也有关系。分别对应下面三种状态。 Transient(自由状态) Detached（游离状态） Persistent（持久状态）数据库的insert操作是立即做的，update操作在commit时才做，因为只是缓存中状态变化，session可以把几条语句合成一条来执行，以提高性能。调用flush()时执行SQL操作。 关联关系在做映射时，你需要关心两类对象关系。第一类是基于多重性(multiplicity)的，包含三种类型： 一对一关系(One-to-one relationships)。这是一种两端多重性(multiplicity)最大值都为1的关系(译注：两端最多只有一个对象) 。举个例子来说就像Employee与Position之间的拥有(holds)关系。每个雇员拥有且仅拥有一个职位，每个职位可能拥有一个雇员（有些职位还可能空缺）。 有两种形式：1。主键关联，用2。唯一外键关联,用它是多对一的一种特殊形式。 一对多关系(One-to-many relationships)。也被称作多对一关系(many-to-one relationship)，这种关系产生于一端多重性(multiplicity)最大为1，而另一端大于1的场合。例如 Employee与Division之间的隶属(work in)关系。每个雇员在一个部门工作，任何给定部门都有一个或者多个雇员在里面工作。 尽量使用双向一对多关系，单向性能低，还会出现外键违例。 多对多关系(Many-to-many relationships)。这是一种两端多重性(multiplicity)最大值均大于1的关系。例如Employee与Task之间的分派(assigned)关系。每个雇员可以被分派一个或多个任务，每个任务可以被指派给0个或多个雇员。 第二类是基于方向（directionality）的，包含两种类型：单向关系和双向关系。 单向关系(Uni-directional relationships)。单向关系是指一个对象知道与其关联的其他对象，但是其他对象不知道该对象。例如 Employee 和Position之间的拥有(holds)关系。Employee对象知道其所拥有的职位，而Position对象不知道拥有它的雇员是谁（没有需要知道的必要）。不久你就会看到，单向关系要比双向关系容易实现。 双向关系(Bi-directional relatinships)。双向关系是指，关联两端的对象都彼此知道对方。例如Employee与Division之间的隶属(work in)关系。Employee对象知道自己工作的部门，而Division对象也知道有哪些雇员在本部门工作。 对象映射1. 映射组成关系2. 映射继承关系a) Table per hierarchy(每个类分层结构一张表)该策略的优点：SINGLE_TABLE 映射策略在所有继承策略中是最简单的，同时也是执行效率最高的。他仅需对一个表进行管理及操作，持久化引掣在载入entiry或多态连接时不需要进行任何的关联，联合或子查询，因为所有数据都存储在一个表。该策略的缺点：这种策略最大的一个缺点是需要对关系数据模型进行非常规设计，在数据库表中加入额外的区分各个子类的字段，此外，不能为所有子类的属性对应的字段定义not null约束，此策略的关系数据模型完全不支持对象的继承关系。选择原则：查询性能要求高，子类属性不是非常多时，优先选择该策略。 b) Table per subclass(每个子类一张表)该策略的优点：这种映射方式支持多态关联和多态查询，而且符合关系数据模型的常规设计规则。在这种策略中你可以对子类的属性对应的字段定义not null约束。该策略的缺点：它的查询性能不如上面介绍的映射策略。在这种映射策略下，必须通过表的内连接或左外连接来实现多态查询和多态关联。选择原则：子类属性非常多，需要对子类某些属性对应的字段进行not null约束，且对性能要求不是很严格时，优先选择该策略。 c) Table per concrete class(每个具体类一张表)该策略的优点：在这种策略中你可以对子类的属性对应的字段定义not null约束。该策略的缺点：不支持多态关联和多态查询，不符合关系数据模型的常规设计规则，每个表中都存在属于基类的多余的字段。同时，为了支持策略的映射，持久化管理者需要决定使用什么方法，一种方法是在entity载入或多态关联时，容器使用多次查询去实现，这种方法需要对数据库做几次来往查询，非常影响执行效率。另一种方法是容器通过使用SQL UNIOU查询来实现这种策略。选择原则：除非你的现实情况必须使用这种策略，一般情况下不要选择","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"Spring","slug":"软件开发/系统架构/Spring","permalink":"http://yoursite.com/categories/软件开发/系统架构/Spring/"}],"tags":[]},{"title":"AOP","slug":"软件开发/系统架构/Spring相关/AOP","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:14:12.219Z","comments":true,"path":"passages/软件开发/系统架构/Spring相关/AOP/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/Spring相关/AOP/","excerpt":"","text":"AOP相关设计与实现解析功能增强相关的技术：回调，Proxy，Filter，Listener，Interceptor，AOP 回调回调是最简单也是在各框架应用最广泛的技术手法，可达到控制反转的效果，是模板方法模式的一种实现，一般来说是先写一个抽象类，把其中的回调方法写成抽象方法也就是说子类必须实现的方法，以此实现对子类中方法的回调，也是IOC的基础。这种方法与默认适配法模式刚好相反，前者声明抽象方法是为了强制子类重写，后者是为一个接口先实现一个子类写入很多空方法为的是其子类不必实现所有接口方法。 Proxy代理模式也是用来功能增强的，它实现与代理对象相同的接口，并且包含代理对象，来实现透明的功能增强，因为调用代理类与调用代理对象相同所以说做代理。Java中最常用的就是动态代理了，只能给它相应的接口和代理对象就能在运行时动态的生成代理类，当然用于功能增强的Handler要自己写了。 FilterServlet中相当标准的filter其实它就是一个回调模式的实现,在某操作之前可能调用某个方法，最后再用一个责任链到传到下一个filter Listener(观察者模式)该模式在C/S开发中是基础，因为要监听组件的事件及状态等。被观察者包含一组观察者（也可说观察者注册在被观察者中），可以在某一事件发生前后调用相应的观察者，来达到监听对象的效果。 Interceptor感觉这种实现方法与Listener基本相同，如果有一点不同的话就是Interceptor实现时要和被拦截对象递归来做，因为要用一个Interceptor对象来实现方法前后的拦截。 AOPAOP就是以上这些方法的更进一步的应用，应该是把以上这些功能增强的应用抽象出来了，因为以上这些方法都有侵入性太强的感觉，而AOP抽象出来形成一个应用层次。AOP的实现方式也有很多，一般由实现的由易到难的度分为： 动态代理：由java中的动态代理实现，但只能对接口增强 代码生成：不太常用了 字节码生成：CGLIB可以实现，可对非接口类增强 类加载器增强：Jboss就是用实现自有类加载器来实现，可以new时动态增强 语言增强：AspectJ用java的扩展语言来实现 更确切地说，我们在比较AOP的拦截器和Decorator模式，它们非常相似，一些AOP框架本身就是使用Decorator模式来实现拦截器功能的。 过滤器是架构设计模式中比较常用的一种，几乎每个灵活动态系统都需要过滤器，特别是当我们的数据以内存状态出现时，过滤器无疑成为领域层的一 个核心业务逻辑，当然如果你还是使用面向数据库的编程模式，过滤器功能就被你用SQL语句的where语法给替代了， 当我们在一个AOP框架下编程，经常会问自己，到底过滤器这个功能是应该做成拦截器还是 Decorator，当我在Jdon Framework下重写JiveJdon时就不只一次的问我自己。 其实这是一个分析模式中的过滤器实现问题，也是一个现实设计的问题：在Servlet Filter和职责链以及装饰模式Decorator和AOP几个方面如何选择？ 选择标准无外乎软件的两个终极目标：简单和高质量；高质量是反映在细粒度方面，简单则是在进行设计实现时比较容易方便。 在粒度粗细方面，又有一个衡量指标：功能覆盖范围，也是一个scope，例如：如果功能需求要为某个类的方法实现实现过滤，但是，你使用一个Servlet Filter这样过滤器实现，虽然 它也能够实现我们的目标，但是它对所有的Servlet请求都进行过滤，这无疑范了杀鸡取卵的错误，造成系统性能上的损失。 以一个具体案例为例子： 我们在论坛显示时，希望动态过滤掉不应该出现的字眼，也就是在帖子显示之前，加载一个过滤器，对内容进行替换。 这里的Model是ForumMessage,而对应的Service则是ForumMessageService； ForumMessageService的getMessage可以获得帖子内容，这里我们在getMessage之前加一个过滤器；那么这里应该如何选 择呢？ 因为我在Jdon Framework这样的Ioc/AOP框架下实现，所以想到的是AOP，我们定义一个拦截器，拦截的对象是ForumMessageService的getMessage方法，进行配置文件配置即可。 AOP的拦截器实现原理也是这样，当然，正是有这种考虑，所以所有AOP框 架内，只有 AspectJ性能是最好的，因为它在你编译代码时就将你的拦截意图实现了，这属于静态织入 weaving，这就类似你自己写代码实现，但是与你自己写代码不同的是，你自己不但要写拦截器，而且还要自己手工将拦截器语句插入被拦截的那段代码，现 在，使用AspectJ你就不用做后者了，这也是整合了AspectJ的Spring 2.0给我们带来的效能。所以，为了在编译代码时做手脚，就不能使用SUN的JDK原来的javac了，必须用他们自己特定的javac了。有得必有失 吧。 理解了AOP拦截器拦截的原理，你可能感慨：原来所有的动态AOP（不改换编译器的AOP框架）拦截效能没有Decorator直接指定要快啊。所以，如果你在编码设计阶段，可以知道你所要拦截的方法，那么，无疑直接使用Decorator模式组成过滤器是一种好方式。 这也是我先期不怎么看好使用动态AOP实现的Spring 1.X版本，也不太热衷于同样使用动态AOP实现、虽符合EJB 3.0规范的JBoss 4.0了。可是，为什么总是有人迫不及待地告别EJB 2.x，夸张Spring，然后又狂炫EJB 3.0。在接纳他们之前，先把盒子打开看看验货一下，做一个普通的消费者应有的理性。 当然，不是说动态AOP没有用武之地，它类似SOA的集成作用，可以在不用修改原来代码结构上强行加入过滤器。而且AOP不只是拦截器，还有introduction，这一神奇功能可以突破Java单继承法则，显得象儿童世界里面的神奇魔法一样。 从某个方面来说，动态AOP和 职责链非常类似，职责链类似击鼓传花，更像典型的打太极拳，推来推去，这也是政府效率不高的主要原因，同样，用在软件系统里，性能最差。想象一下，当这朵 花传到真正主人面前时，而这个主人是传花环节中最后一个，这种效率和直接抛绣球一样，直接将花抛给真正主人相比，无疑最耗时间的，所以击鼓传花游戏就是玩 的这个耗时间，在鼓声中，消耗时间，煎熬折磨你的心思，它玩的不是要把花如何快速准确地送给某人，它的目的性不确切。 我们的软件系统不能这么玩吧？ 总结如下：过滤器实现方式在不保证功能前提下，从性能角度考虑有如下先后顺序：Decorator或Proxy模式；AOP拦截器。 考虑使用AOP拦截器时，最好选择那些受众面积比较广的功能，例如一些基础通用功能：权限检查；事务机制；Pool等，这些功能不是针对某个具体类或方法（方法权限除外），而是一系列类，这样使用动态AOP拦截器，就是有些性能损耗也是值得的，而且是必要的，使用其他方法也会引起这样的损耗。 如果过滤器是业务逻辑的一部分，而且在设计时，我们可以确定这些过滤器，这样我们使用Decorator模式或Proxy模式进行特定指定的拦截，当然，因为每个类/接口都需要一个附加的Decorator/Proxy，如果某个过滤功能是很多类都需要的，","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"Spring","slug":"软件开发/系统架构/Spring","permalink":"http://yoursite.com/categories/软件开发/系统架构/Spring/"}],"tags":[]},{"title":"MicroService","slug":"软件开发/系统架构/分布式架构/MicroService","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-25T14:26:59.676Z","comments":true,"path":"passages/软件开发/系统架构/分布式架构/MicroService/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/分布式架构/MicroService/","excerpt":"","text":"MicroService[TOC] 微服务架构监控微服务架构虽然解决了目前诸多的架构层面的问题，但在分布式部署的环境中，如何才能够有效监控每一个服务，并及时发现系统中的问题又成为了新的挑战 在APM领域，程序的细节决定产品的性能。目前按照探针的实现，可行的思路主要有四种： 基于日志系统，探针只负责对日志加上编号，又类似ELK的系统进行收集、处理、展示。这方面没有很成熟的产品，一般都属于公司内部封装的框架。 自动探针，适用语言：Java、C#、PHP、Node.js等等存在VM的语言。绝对大多数的商业产品和热门的开源产品都属于这个系列。 全手动探针，优势是适用范围广，最有名的就是Zipkin的整个生态系统，分布式追踪几乎无处不在。也是现在全球运用最广泛的分布式监控系统。 同时支持自动和手动模式的探针，适用语言同样是Java、C#、PHP、Node.js等等存在VM的语言，由于技术复杂性提高，运用的较少。优点是入门方便，同时使用灵活。商业上主要是Instana，开源主要是sky-walking提供了技术解决方案。 监控系统一般分为三大模块探针或SDK，负责数据采集和发送。探针或SDK是应用程序的收集端。一般使用插件的模式，自动探针一般是不需要修改程序，而SDK则是需要修改部分配置或者代码。skywalking就是自动探针为主，zipkin-brave就是Zipkin的Java手动探针。 Collector模块，负责数据收集、分析、汇总、告警和存储。Collector模块，这个根据不同的APM实现，可能由一个或者多个子系统构成。Collector负责对探针和SDK提供网络接口（TCP、UDP、HTTP不同形式接口）。 功能上，主要包含数据收集、分析、汇总、告警和存储。这些模块在复杂的开源APM和商业产品上都保持一致。大家选择时，值得注意的是，现在包括Zipkin在内的不少国外的追踪系统，是只负责追踪，不负责分析汇总，他们认为分析可以由使用者自己负责。 作为分析方式，分为流式分析和异步批量两种，而流式分析会对数据统计和告警的实时性更有帮助。 UI，负责高实时性的展现。包括但不限于Trace的查询，统计数据展现，拓扑图展现，VM或进程相关信息等，监控关键数据的展现。 服务注册、发现、负载均衡和健康检查和单块(Monolithic)架构不同，微服务架构是由一系列职责单一的细粒度服务构成的分布式网状结构，服务之间通过轻量机制进行通信，这时候必然引入一个服务注册发现问题，也就是说服务提供方要注册通告服务地址，服务的调用方要能发现目标服务，同时服务提供方一般以集群方式提供服务，也就引入了负载均衡和健康检查问题。根据负载均衡LB所在位置的不同，目前主要的服务注册、发现和负载均衡方案有三种： 第一种是集中式LB方案，如下图Fig 1，在服务消费者和服务提供者之间有一个独立的LB，LB通常是专门的硬件设备如F5，或者基于软件如LVS，HAproxy等实现。LB上有所有服务的地址映射表，通常由运维配置注册，当服务消费方调用某个目标服务时，它向LB发起请求，由LB以某种策略（比如Round-Robin）做负载均衡后将请求转发到目标服务。LB一般具备健康检查能力，能自动摘除不健康的服务实例。服务消费方如何发现LB呢？通常的做法是通过DNS，运维人员为服务配置一个DNS域名，这个域名指向LB。 集中式LB方案实现简单，在LB上也容易做集中式的访问控制，这一方案目前还是业界主流。集中式LB的主要问题是单点问题，所有服务调用流量都经过LB，当服务数量和调用量大的时候，LB容易成为瓶颈，且一旦LB发生故障对整个系统的影响是灾难性的。另外，LB在服务消费方和服务提供方之间增加了一跳(hop)，有一定性能开销。 第二种是进程内LB方案，针对集中式LB的不足，进程内LB方案将LB的功能以库的形式集成到服务消费方进程里头，该方案也被称为软负载(Soft Load Balancing)或者客户端负载方案，下图Fig 2展示了这种方案的工作原理。这一方案需要一个服务注册表(Service Registry)配合支持服务自注册和自发现，服务提供方启动时，首先将服务地址注册到服务注册表（同时定期报心跳到服务注册表以表明服务的存活状态，相当于健康检查），服务消费方要访问某个服务时，它通过内置的LB组件向服务注册表查询（同时缓存并定期刷新）目标服务地址列表，然后以某种负载均衡策略选择一个目标服务地址，最后向目标服务发起请求。这一方案对服务注册表的可用性(Availability)要求很高，一般采用能满足高可用分布式一致的组件（例如Zookeeper, Consul, Etcd等）来实现。 进程内LB方案是一种分布式方案，LB和服务发现能力被分散到每一个服务消费者的进程内部，同时服务消费方和服务提供方之间是直接调用，没有额外开销，性能比较好。但是，该方案以客户库(Client Library)的方式集成到服务调用方进程里头，如果企业内有多种不同的语言栈，就要配合开发多种不同的客户端，有一定的研发和维护成本。另外，一旦客户端跟随服务调用方发布到生产环境中，后续如果要对客户库进行升级，势必要求服务调用方修改代码并重新发布，所以该方案的升级推广有不小的阻力。 进程内LB的案例是Netflix的开源服务框架，对应的组件分别是：Eureka服务注册表，Karyon服务端框架支持服务自注册和健康检查，Ribbon客户端框架支持服务自发现和软路由。另外，阿里开源的服务框架Dubbo也是采用类似机制。 第三种是主机独立LB进程方案，该方案是针对第二种方案的不足而提出的一种折中方案，原理和第二种方案基本类似，不同之处是，他将LB和服务发现功能从进程内移出来，变成主机上的一个独立进程，主机上的一个或者多个服务要访问目标服务时，他们都通过同一主机上的独立LB进程做服务发现和负载均衡，见下图Fig 3。 该方案也是一种分布式方案，没有单点问题，一个LB进程挂了只影响该主机上的服务调用方，服务调用方和LB之间是进程内调用，性能好，同时，该方案还简化了服务调用方，不需要为不同语言开发客户库，LB的升级不需要服务调用方改代码。该方案的不足是部署较复杂，环节多，出错调试排查问题不方便。 该方案的典型案例是Airbnb的SmartStack服务发现框架，对应组件分别是：Zookeeper作为服务注册表，Nerve独立进程负责服务注册和健康检查，Synapse/HAproxy独立进程负责服务发现和负载均衡。Google最新推出的基于容器的PaaS平台Kubernetes，其内部服务发现采用类似的机制。 服务容错当企业微服务化以后，服务之间会有错综复杂的依赖关系，例如，一个前端请求一般会依赖于多个后端服务，技术上称为1 -&gt; N扇出(见图Fig 6)。在实际生产环境中，服务往往不是百分百可靠，服务可能会出错或者产生延迟，如果一个应用不能对其依赖的故障进行容错和隔离，那么该应用本身就处在被拖垮的风险中。在一个高流量的网站中，某个单一后端一旦发生延迟，可能在数秒内导致所有应用资源(线程，队列等)被耗尽，造成所谓的雪崩效应(Cascading Failure，见图Fig 7)，严重时可致整个网站瘫痪。 经过多年的探索和实践，业界在分布式服务容错一块探索出了一套有效的容错模式和最佳实践，主要包括： 电路熔断器模式(Circuit Breaker Patten), 该模式的原理类似于家里的电路熔断器，如果家里的电路发生短路，熔断器能够主动熔断电路，以避免灾难性损失。在分布式系统中应用电路熔断器模式后，当目标服务慢或者大量超时，调用方能够主动熔断，以防止服务被进一步拖垮；如果情况又好转了，电路又能自动恢复，这就是所谓的弹性容错，系统有自恢复能力。下图Fig 8是一个典型的具备弹性恢复能力的电路保护器状态图，正常状态下，电路处于关闭状态(Closed)，如果调用持续出错或者超时，电路被打开进入熔断状态(Open)，后续一段时间内的所有调用都会被拒绝(Fail Fast)，一段时间以后，保护器会尝试进入半熔断状态(Half-Open)，允许少量请求进来尝试，如果调用仍然失败，则回到熔断状态，如果调用成功，则回到电路闭合状态。 舱壁隔离模式(Bulkhead Isolation Pattern)，顾名思义，该模式像舱壁一样对资源或失败单元进行隔离，如果一个船舱破了进水，只损失一个船舱，其它船舱可以不受影响 。线程隔离(Thread Isolation)就是舱壁隔离模式的一个例子，假定一个应用程序A调用了Svc1/Svc2/Svc3三个服务，且部署A的容器一共有120个工作线程，采用线程隔离机制，可以给对Svc1/Svc2/Svc3的调用各分配40个线程，当Svc2慢了，给Svc2分配的40个线程因慢而阻塞并最终耗尽，线程隔离可以保证给Svc1/Svc3分配的80个线程可以不受影响，如果没有这种隔离机制，当Svc2慢的时候，120个工作线程会很快全部被对Svc2的调用吃光，整个应用程序会全部慢下来。 限流(Rate Limiting/Load Shedder)，服务总有容量限制，没有限流机制的服务很容易在突发流量(秒杀，双十一)时被冲垮。限流通常指对服务限定并发访问量，比如单位时间只允许100个并发调用，对超过这个限制的请求要拒绝并回退。 回退(fallback)，在熔断或者限流发生的时候，应用程序的后续处理逻辑是什么？回退是系统的弹性恢复能力，常见的处理策略有，直接抛出异常，也称快速失败(Fail Fast)，也可以返回空值或缺省值，还可以返回备份数据，如果主服务熔断了，可以从备份服务获取数据。 Netflix将上述容错模式和最佳实践集成到一个称为Hystrix的开源组件中，凡是需要容错的依赖点(服务，缓存，数据库访问等)，开发人员只需要将调用封装在Hystrix Command里头，则相关调用就自动置于Hystrix的弹性容错保护之下。Hystrix组件已经在Netflix经过多年运维验证，是Netflix微服务平台稳定性和弹性的基石，正逐渐被社区接受为标准容错组件。 服务前端网关微服务除了内部相互之间调用和通信之外，最终要以某种方式暴露出去，才能让外界系统（例如客户的浏览器、移动设备等等）访问到，这就涉及服务的前端路由，对应的组件是服务网关(Service Gateway)， 客户端直接与各个微服务通讯，会有以下的问题： 客户端会多次请求不同的微服务，增加了客户端的复杂性。 存在跨域请求，在一定场景下处理相对复杂。 认证复杂，每个服务都需要独立认证。 难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通讯，那么重构将会很难实施。 某些微服务可能使用了防火墙/浏览器不友好的协议，直接访问会有一定困难 网关是连接企业内部和外部系统的一道门，有如下关键作用： 服务反向路由，网关要负责将外部请求反向路由到内部具体的微服务，这样虽然企业内部是复杂的分布式微服务结构，但是外部系统从网关上看到的就像是一个统一的完整服务，网关屏蔽了后台服务的复杂性，同时也屏蔽了后台服务的升级和变化。 安全认证和防爬虫，所有外部请求必须经过网关，网关可以集中对访问进行安全控制，比如用户认证和授权，同时还可以分析访问模式实现防爬虫功能，网关是连接企业内外系统的安全之门。 限流和容错，在流量高峰期，网关可以限制流量，保护后台系统不被大流量冲垮，在内部系统出现故障时，网关可以集中做容错，保持外部良好的用户体验。 监控，网关可以集中监控访问量，调用延迟，错误计数和访问模式，为后端的性能优化或者扩容提供数据支持。 日志，网关可以收集所有的访问日志，进入后台系统做进一步分析。 除以上基本能力外，网关还可以实现线上引流，线上压测，线上调试(Surgical debugging)，金丝雀测试(Canary Testing)，数据中心双活(Active-Active HA)等高级功能。 网关通常工作在7层，有一定的计算逻辑，一般以集群方式部署，前置LB进行负载均衡。 开源的网关组件有Netflix的Zuul，特点是动态可热部署的过滤器(filter)机制，其它如HAproxy，Nginx等都可以扩展作为网关使用。 在介绍过服务注册表和网关等组件之后，我们可以通过一个简化的微服务架构图(Fig 5)来更加直观地展示整个微服务体系内的服务注册发现和路由机制，该图假定采用进程内LB服务发现和负载均衡机制。在下图Fig 5的微服务架构中，服务简化为两层，后端通用服务（也称中间层服务Middle Tier Service）和前端服务（也称边缘服务Edge Service，前端服务的作用是对后端服务做必要的聚合和裁剪后暴露给外部不同的设备，如PC，Pad或者Phone）。后端服务启动时会将地址信息注册到服务注册表，前端服务通过查询服务注册表就可以发现然后调用后端服务；前端服务启动时也会将地址信息注册到服务注册表，这样网关通过查询服务注册表就可以将请求路由到目标前端服务，这样整个微服务体系的服务自注册自发现和软路由就通过服务注册表和网关串联起来了。如果以面向对象设计模式的视角来看，网关类似Proxy代理或者Façade门面模式，而服务注册表和服务自注册自发现类似IoC依赖注入模式，微服务可以理解为基于网关代理和注册表IoC构建的分布式系统 微服务架构与单体架构的对比对于简单项目来说，微服务架构。优势项：系统设计（高内聚低耦合）、系统设计（扩展性）、需求变更响应速度、系统升级效率、知识积累、非功能需求、职责、成就感、风险劣势项：上手难度、运维效率、开发效率、硬件需求、项目成本； 对于复杂项目来说，微服务架构。优势项：硬件需求、项目成本、开发效率、系统设计（高内聚低耦合）、系统设计（扩展性）、需求变更响应速度、系统升级效率、知识积累、非功能需求、职责、成就感、风险劣势项：上手难度、运维效率； 微服务架构的风险​ 微服务架构将业务逻辑分散到了各个微服务当中，微服务间通过网络层进行通信。网络通信带来了额外的延迟和复杂性，需要多个物理组件和逻辑组件共同协作。分布式系统的额外复杂性增加了出现网络故障的几率。 ​ 微服务架构相比单体架构最大的优势之一在于，不同的团队可以独立地设计、开发和部署他们的服务。他们可以完全掌控自己的微服务生命周期。当然，这也意味着他们无法控制服务依赖项，因为依赖项的控制权掌握在其他团队手中。在采用微服务架构时，我们要时刻铭记，发布、配置等方面的问题可能会导致服务提供者出现短暂的不可用。 变更管理在微服务架构里，服务之间是相互依赖的。所以我们要最小化出现故障的几率，限制故障所造成的负面影响。我们需要良好的变更管理策略和自动回滚机制 例如，在部署新代码时，或者在对配置做出变更时，要先在一小部分服务实例上进行，然后监控它们，一旦发现关键性度量指标出现异常，马上自动回滚 另一个解决方案就是运行两套生产环境。在部署的时候只部署到其中一个生产环境，只有在确认这个环境没问题了之后才能将负载均衡器指向这个环境。这种部署方式被称为蓝绿部署或者红黑部署。 回退代码并不是件坏事。你总不可能一边把有问题的代码留在生产环境里，一边想着到底发生了什么问题。所以，在必要的时候回退代码，越快越好。 健康监测和负载均衡服务实例总是因为各种原因（故障、部署或自动伸缩）经历着启动、重启、停止这样的过程。这个过程会让服务暂时或永久地不可用，为了避免出现问题，负载均衡器需要忽略出现问题的服务实例，因为它们已经不具备为用户或其他子系统提供服务的能力。 应用的健康状态可以通过外部的观察来获得，比如通过不断重复地调用/health端点来得知应用的状态，或者让应用报告自己的状态。服务发现机制会持续地收集服务实例的健康信息，负载均衡器应该被配置成只将流量路由给健康的服务实例。 重试在应用程序里添加重试逻辑的时候要十分小心，因为大量的重试操作会让事情变得更糟糕，甚至导致应用程序无法从故障中恢复。 在分布式系统中，一个微服务系统可能会触发多个请求或重试操作，从而发生级联效应。为了降低重试带来的影响，应该要限制重试的次数，可以使用指数退避（exponential backoff）算法来逐步增加重试之间的延迟，直到达到重试的上限。 微服务架构业务切分从事微服务架构工作的架构师，相比传统架构的架构师而言，所要求的技能更加全面。他们不仅仅是系统架构师，也是业务分析师，他们的责任重大且挑战艰巨。 从大的方向来看，微服务架构师需要具备以下基本职责。 分析业务需求并切分微服务边界。 定义架构规范与文档标准。 确保微服务架构顺利落地。 改善微服务架构并提高开发效率。 职责与挑战往往是无法分离的，微服务架构师必须面对并克服这些挑战。 架构需要适应不断变化的业务需求。 架构具备稳定性、扩展性、安全性、容错性等。 使技术团队深刻理解微服务思想。 展现微服务架构的价值。 我们认为，传统架构师转型为微服务架构首先需要做到的是深刻理解业务，而不是表面上了解需求。业务和需求其实是两码事，业务的背后反映了客户的刚需，而需求往往是产品经理根据业务刚需所指定的解决方案。作为微服务架构师，我们需要透过需求的表象去理解业务的本质。其次需要做到的是不断优化架构，让架构变得更加简单，更加轻量级 经过大量的微服务实践，我们总结了以下五个步骤，可帮助大家有效地切分微服务边界。 梳理业务流程。 在切分微服务之前，我们要做的第一件事情就是梳理业务流程。不妨找业务专家咨询，通过与他们沟通从而了解真实的业务流程，并将其绘制成流程图。对于过于复杂的业务流程，我们也可单独绘制流程图，并增加相关的流程说明。当然也能提供相应的状态图，用于说明业务流程中所涉及状态的变化过程。 抽取公共服务。 在业务流程中与业务不太相关的部分，我们可考虑将其剥离出来，并形成公共服务。例如，邮件发送、文件上传、其他第三方接口等。每种公共服务都对应一个微服务，每个微服务都有相关API，每个API都有自己的输入与输出。这些API一定要形成文档，以便其他服务调用。 定义业务服务。 当公共服务抽取完毕后，业务流程中剩下来的部分就是业务服务了。建议刚开始实施微服务时，不要将业务服务的边界切得太细，可以考虑先“大切几块”，但需要确保每个服务之间尽量不要有依赖关系。换句话说，每个服务都是独立的，虽然此时服务的块头可能比较大我们先确保这些大块头服务可以运行在微服务基础设施上，再不断将它们进行细化，拆解为更小的服务。 设计数据模型。 深入到每个业务服务中，我们首先要做的是定义它底层所涉及的数据模型，也称为“领域模型”。此时会涉及数据库表结构设计，以及数据模型与关系设计。在数据层面上的设计是至关重要的，如果该部分设计得不到位，将增加后期实现微服务的成本。 数据模型的设计同样也需要进行文档化，这些文档将指导后端工程师顺利地完成微服务实现 定义服务接口。 底层的数据模型设计完毕后，我们将视角转换到顶层的服务接口上。服务接口实际上就是一组API，这些API需做到职责单一，而且需要通过名称就能识别出它的业务含义。建议确保每个API的命名是全局唯一的，也建议每个API都有各自的版本号，版本号可以用自增长的方式来体现 参考： 如何设计高可用的微服务架构 轻量级微服务架构及最佳实践 实施微服务，我们需要哪些基础框架？","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"分布式架构","slug":"软件开发/系统架构/分布式架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/分布式架构/"}],"tags":[]},{"title":"分布式系统","slug":"软件开发/系统架构/分布式架构/分布式系统","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:14:31.819Z","comments":true,"path":"passages/软件开发/系统架构/分布式架构/分布式系统/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/分布式架构/分布式系统/","excerpt":"","text":"分布式系统数据访问层单机数据库性能不足的情况下，需要进行拆分。 数据库垂直和水平拆分不升级硬件的情况下，要通过数据库减压的方式来优化。 优化应用，减少不必要的数据库访问。 引入其他方式来降低压力，引入缓存加搜索引擎。 建立数据库集群，拆分数据 数据拆分有两种，垂直拆分和水平拆分。垂直拆分是把不同的业务数据分到不同的数据库，水平拆分是根据一定规则把同一业务数据拆分到多个数据库。 垂直拆分会有以下影响： 单机ACID被打破，要么放弃修改逻辑，要么使用分布式事物 一些Join操作变得困难 外键约束会受影响 水平拆分会有以下影响： 单机ACID被打破，要么放弃修改逻辑，要么使用分布式事物 一些Join操作变得困难 外键约束会受影响 依赖单库的自增ID会受到影响 业务上的单表查询要跨库了，可能需要多次查询 分布式环境下的一致性（事务） 2PC: Two Phase Commitment Protocol Paxos：少数服从多数， CAP: Consistency, Availability, Partition-Tolerance。 CA放弃分区容忍性，这是传统单机数据库的选择。AP放弃一致性. CP放弃可用性。 BASE: Basically Available基本可用允许分区失败，Soft state软状态，接受一段时间状态不同步，Eventually consistent最终一致性。 消息中间件异步，解耦，消峰","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"分布式架构","slug":"软件开发/系统架构/分布式架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/分布式架构/"}],"tags":[]},{"title":"Spring读书笔记","slug":"软件开发/系统架构/Spring相关/Spring读书笔记","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:14:19.023Z","comments":true,"path":"passages/软件开发/系统架构/Spring相关/Spring读书笔记/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/Spring相关/Spring读书笔记/","excerpt":"","text":"[TOC] SpringSpring核心Spring 从核心而言，是一个DI容器，其设计哲学是提供一种无侵入式的高扩展性框架。即无需代码中涉及Spring专有类，即可将其纳入Spring容器进行管理。作为对比，EJB则是一种高度侵入性的框架规范，它制定了众多的接口和编码规范，要求实现者必须遵从。侵入性的后果就是，一旦系统基于侵入性框架设计开发，那么之后任何脱离这个框架的企图都将付出极大的代价。为了避免这种情况，实现无侵入性的目标。Spring 大量引入了Java 的Reflection机制，通过动态调用的方式避免硬编码方式的约束，并在此基础上建立了其核心组件BeanFactory，以此作为其依赖注入机制的实现基础。 Spring 可以分为三大部分： IOC容器：一个或多个容器的实例将应用程序和框架对象配置和装配到一起，管理对象之间的依赖关系及其生命周期。主要是用来创建和管理对象及用DI做对象关系管理，否则应用中会充满工厂或singleton模式不同程度地引入一些难于测试或者程式化代码重复的问题，给对象管理带来复杂性。 AOP 企业级服务 IOC1．依赖注入的几种形式有设置器注入和构造函数注入两种常用形式，一般来说前者更常用一点。还有一种比较少见的方式—-方法注入，这个涉及到spring线程模型的应用，当单例服务依赖于多例DAO的情况下使用。另外DI是推(push)模式，容器在运行时间将依赖“推”入应用程序对象，这与传统的拉(pull)模式正好相反，在拉模式中应用程序对象从它的环境中把依赖“拉”出来。 2．容器bean工厂及ApplicationContextorg.springframework.beans包中包括了这些核心组件的实现类，核心中的核心为BeanWrapper和BeanFactory类。这两个类从技术角度而言并不复杂，但对于Spring 框架而言，却是关键所在，关于beans包，有三个重要的概念。 它提供了设置/读取Javabeans属性功能的BeanWrapper接口。 Bean工厂。BeanFactory是一个泛化工厂，具有实例化对象和管理不同对象间关系的能力。BeanFactory可以管理几种不同类型的bean，并且支持串行化及其他生命周期方法。BeanFactory是按照bean定义（BeanDefinition）来实例化对象的。 BeanDefinition，顾名思义，是你对bean的定义。BeanDefinition不仅定义了bean的类结构、实例化的方式，还定义了bean在运行时的合作者。 Bean Factory顾名思义，负责创建并维护Bean实例。Bean Factory负责根据配置文件创建Bean实例，可以配置的项目有： Bean属性值及依赖关系（对其他Bean的引用） Bean创建模式（是否Singleton模式，即是否只针对指定类维持全局唯一的实例） Bean初始化和销毁方法 Bean的依赖关系 BeanFactory接口不仅仅能管理bean，实际上它能管理你所期望的任意类。很多人在使用Spring时喜欢用BeanFactory管理“真正”的bean（仅有一个默认构造器、私有属性及其读取器和设置器）,事实上它也可以持有非bean形式的类。比如一个从以前系统遗留下来的连接池类――它完全不符合bean规范，不用担心，Spring同样可以很好的管理它。 Spring已经提供了一组现成的BeanFactory实现。XmlBeanFactory类支持在XML文件中指定bean定义，ListableBeanFactory类则支持从properties文件中获得bean定义。 BeanWrapper实现了针对单个Bean的属性设定操作。而BeanFactory则是针对多个Bean的管理容器，根据给定的配置文件，BeanFactory从中读取类名、属性名/值，然后通过Reflection机制进行Bean加载和属性设定 ApplicationContextBeanFactory提供了针对Java Bean的管理功能，而ApplicationContext提供了一个更为框架化的实现（从上面的示例中可以看出，BeanFactory的使用方式更加类似一个API，而非Framework style）。 ApplicationContext覆盖了BeanFactory的所有功能，并提供了更多的特性。此外，ApplicationContext为与现有应用框架相整合，提供了更为开放式的实现（如对于Web应用，我们可以在web.xml中对ApplicationContext进行配置）。提供了更多功能MessageSource支持，事件支持，ResourceLoader支持。 取得资源实际Resource类型取决于位置字符串具有的可选前缀的组合以及应用程序上下文的实际类型。前缀有file: http: classpath:等，没有前缀的情况下取决于实际ApplicationContext的实现 ClasspathXmlApplicationContext：位置被解释成一个类路径位置，返回ClasspathReource类 FilesystemXmlApplicationContext：位置被 解释成一个相对的文件系统位置，返回FilesystemResource类 XmlWebApplicationContext：位置被解释成相对于WEB应用程序目录的位置，返回ServletContextResource类 Bean Wrapper所谓依赖注入，即在运行期由容器将依赖关系注入到组件之中。讲的通俗点，就是在运行期，由Spring根据配置文件，将其他对象的引用通过组件的提供的setter方法进行设定。 一个对于benas包非常重要的概念是BeanWrapper接口及与之对应的实现（BeanWrapperImpl类）。如JavaDoc中所载，BeanWrapper接口提供了设置和读取属性值、获得属性描述以及查询属性是否可读写的功能。BeanWrapper也提供了嵌套属性的支持，允许设置无限深度的子属性，BeanWrapper实现了针对单个Bean的属性设定操作。而BeanFactory则是针对多个Bean的管理容器，根据给定的配置文件，BeanFactory从中读取类名、属性名/值，然后通过Reflection机制进行Bean加载和属性设定。也可以用Bean Wrapper来包装任意的类来操作其中的属性。 使用PropertyEditors包转换属性有时候，为了使用方便，我们需要以另一种形式展现对象的属性。例如，日期可以以一种更容易阅读的形式表现出来，同时我们也会将人们熟悉的格式转换回原始的日期格式（或者使用一个更好的办法：将所有用户偏好形式转换回统一的java.util.Date对象）。为了达到这一目的，我们可以编写自定义编辑器，使其继承java.beans.PropertyEditor类型，并将自定义编辑器注册到BeanWrapper上。通过注册， BeanWrapper组装bean时将根据属性类型对XML文件中的字符串做相应的转换。请阅读Sun公司提供的java.beans包中PropertyEditors的JavaDoc获得进一步信息。 Bean DefinitionsBean definitions是你的bean的详细描述，对应XML中&lt;bean&gt;配置。Bean就是一些提供某些特定功能的普通类，BeanFactory 接口如何管理你的bean以及它们是怎样配置的,都是在一个bean definition中规定的。另外还有大量的工厂bean类可供使用，主要用来提取抽象返回所需要的对象。 3．Bean定义及依赖、主要是XML文件的配置用来定义信赖关系 4．Bean的ScopeSingleton：每个Spring容器中一个bean定义对应一个实例Prototype：一个bean定义对应多个实例Request：在一个HTTP请求中一个bean定义对应一个实例，仅在基于WEB的ApplicationContext情形下有效Session：在一个HTTP Session中一个bean定义对应一个实例，仅在基于WEB的ApplicationContext情形下有效Global session：用于portlet应用中 5．Bean生命周期一些bean的生命周期回调方法，像beanFactoryAware和ApplicationContextAware接口的setBeanFactory()和setApplicationContext()方法就可以用来得到工厂对象 6．资源Spring的Resource接口扩充了java访问底层资源的能力及功能，可以通过classpath和servletContext相对路径来访问资源。ResourceLoader接口用来返回Resource实例对象的实现。 研读代码而写出的调用过程： XmlBeanFactory调用XmlBeanDefinitionReader的loadBeanDefinitions()把Resource转换为Document对象 由XmlBeanDefinitionReader调用DefaultXmlBeanDefinitionParser的registerBeanDefinitions来注册beandefinition 在DefaultXmlBeanDefinitionParser中把xml文件解析并转换来生成beandefinition，并调用beanfactory的registerBeanDefinition向beanfactory的beanDefinitionMap中增加传入的bean definition AOPAOP和OOP有比较大的不通。OOP集中于对象的建模和行为的封装，而AOP考虑的是在流程上如何建模一个比较单独的功能。用OOP来构建一个核心系统是非常好的，但是，如果需要很多其他相关功能，这个时候AOP就有其用武之处了。 AOP关 注的Cross-cutting concerns, 从这些关注面中，我们抽取出一些可识别的Aspects，然后我们把这些Aspects具体设计为Advices，这些Advices根据我们的要求 PointCut，将这些Advices具体Weave到应用的这些可以插入的JointPoint中去。 Aspects 的 具体设计 Advices，它对应到Spring当中，就是那些具体执行操作的类。比如说BeforeAdivce之类的这些表示Aspect的类。PointCut就是一堆配置信息，它描述了有那些Advices使用到那些JointPoint当中去。它对应到Spring当中，就是对应的 ProxyFactoryBean当中的配置信息。Weave就是ProxyFactoryBean，从名字上也知道它是一个代理工厂，生成原方法的代理 对象，然后将Aspect定义的这些功能动态增加到对象中去。JointPoint：其实就是插入点，一般对象在执行方法的时候可以被插入其他的功能。在Spring中，只支持在Method层次上进行插入，而不支 持在Field层次上进行插入，因为这样的话实际上已经对对象的状态产生影响了，它连原来的对象都不是了，不适合用来构建应用系统。 其实静态代理和动态代理的了解对Spring AOP的理解真的是有非常大的帮助，因为Spring AOP就是靠动态代理技术以及动态字节码生成技术来达到目标的：通过构建对象的代理对象来完成功能的插入。 Spring2.0的AOP有两种方式一种是@AspactJ声明式的一种是Schema式的，一个advisor是一个仅仅包含一个通知对象和与之关联的切入点表达式的切面。 一、AOP 概念 Joinpoint：它定义在哪里加入你的逻辑功能，对于Spring AOP，Jointpoint指的就是Method。 Advice：特定的Jointpoint处运行的代码，对于Spring AOP 来讲，有Before advice、AfterreturningAdvice、ThrowAdvice、AroundAdvice(MethodInteceptor)等。 Pointcut：一组Joinpoint，就是说一个Advice可能在多个地方织入， Aspect：这个我一直迷惑，它实际是Advice和Pointcut的组合，但是Spring AOP 中的Advisor也是这样一个东西，但是Spring中为什么叫Advisor而不叫做Aspect。 Weaving：将Aspect加入到程序代码的过程，对于Spring AOP，由ProxyFactory或者ProxyFactoryBean负责织入动作。 Target：这个很容易理解，就是需要Aspect功能的对象。 Introduction：引入，就是向对象中加入新的属性或方法，一般是一个实例一个引用对象。当然如果不引入属性或者引入的属性做了线程安全性处理或 者只读属性，则一个Class一个引用也是可以的（自己理解）。Per-class lifecycle or per-instance life cycle 二、AOP 种类 静态织入：指在编译时期就织入Aspect代码，AspectJ好像是这样做的。 动态织入：在运行时期织入，Spring AOP属于动态织入，动态织入又分静动两种，静则指织入过程只在第一次调用时执行；动则指根据代码动态运行的中间状态来决定如何操作，每次调用Target的时候都执行（性能较差）。 三、Spring AOP 代理原理Spring AOP 是使用代理来完成的，Spring 会使用下面两种方式的其中一种来创建代理： JDK动态代理，特点只能代理接口，性能相对较差，需要设定一组代理接口。 CGLIB 代理，可代理接口和类（final method除外），性能较高(生成字节码)。 四、Spring AOP 通知类型 BeforeAdvice：前置通知需实现MethodBeforeAdvice，但是该接口的Parent是BeforeAdvice，致 于什么用处我想可能是扩展性需求的设计吧。或者Spring未来也并不局限于Method的JoinPoint（胡乱猜测）。BeforeAdvice可 以修改目标的参数，也可以通过抛出异常来阻止目标运行。 AfterreturningAdvice：实现AfterreturningAdvice，我们无法修改方法的返回值，但是可以通过抛出异常阻止方法运行。 AroundAdvice：Spring 通过实现MethodInterceptor(aopalliance)来实现包围通知，最大特点是可以修改返回值，当然它在方法前后都加入了自己的逻辑代码，因此功能异常强大。通过MethodInvocation.proceed()来调用目标方法（甚至可以不调用）。 ThrowsAdvice：通过实现若干afterThrowing()来实现。 IntroductionInterceptor：Spring 的默认实现为DelegatingIntroductionInterceptor 五、Spring AOP Pointcut以上只是Advice，如果不指定切入点，Spring 则使用所有可能的Jointpoint进行织入（当然如果你在Advice中进行方法检查除外）。因此切入点在AOP中扮演一个十分重要的角色。Spring 2.0 推荐使用AspectJ的Annocation的切入点表达式来定义切入点，或者使用aop:xxx/来定义AOP，这方面本篇不做考虑。 Pointcut：它是Spring AOP Pointcut的核心，定义了getClassFilter()和getMethodMatcher()两个方法。 ClassFilter：定义了matches(Class cls)一个方法。 MethodMatcher() 定义了matches(Method，Class)，isRuntime()，matches(Mathod，Class，Object[])三个方法， 如果isRuntime()返回true则表示为动态代理（实际是动态代理的动态代理），则调用第三个方法（每访问一次调用一次），否则调用第一个方法 （并且只调用一次） Spring AOP 静态切入点的几个实现。 ComposablePointcut 太复杂一个切入点无法表达,union MethodMatcher和ClassFilter或者intersection MethodMatcher、ClassFilter和Pointcut。为什么不实现union Pointcut? 而只能通过Pointcuts类对Pointcut进行union操作。 ControlFlowPointcut 对程序的运行过程进行追踪 DynamicMatchMatcherPointcut 动态AOP JdkRegexpMethodPointcut 使用正则表达式 Perl5RegexpMethodPointcut NameMatchMethodPointcut 用方法名字来匹配 StaticMethodMatcherPointcut 静态切入点 六、Spring AOP 中的Advisor其实就是Aspect1、 PointcutAdvisor其实一般使用DefaultPointcutAdvisor就足够了，给它Advice和Pointcut。当然如果想少写那么几行代码也可以使用NameMatchMethodPointcutAdvisor，RegexpMethodPointcutAdvisor等。更多Advisor可以查看API文档。 2、 IntroductionAdvisor默认实现为DefaultIntroductionAdvisor。 在Spring里有可能在同一个AOP代理里模糊advisor和通知类型。例如，你可以在一个代理配置里使用一个interception环绕通知，一个异常通知：Spring将负责自动创建所需的拦截器链。在Spring中创建一个AOP代理的基本方法是使用ProxyFactoryBean类，它对应用的切入点和通知提供了完整的控制能力 七、AOP ProxyFactory使用代码实现AOP 可使用ProxyFactory声明式AOP 可使用ProxyFactoryBeanProxyFactoryBean 需要设定 target，interceptorNames（可以是Advice或者Advisor，注意顺序）对接口代理需设置proxyInterfaces AOP编程的适用领域 Authentication 权限 Caching 缓存 Context passing 内容传递 Error handling 错误处理 Lazy loading 懒加载 Debugging 调试 logging, tracing, profiling and monitoring 记录跟踪 优化 校准 Performance optimization 性能优化 Persistence 持久化 Resource pooling 资源池 Synchronization 同步 Transactions 事务 Web应用中对于异常的处理方式与其他形式的应用并没有太大的不同――通过try/catch语句针对不同的异常进行相应处理。但是在具体实现中，由于异常层次、种类繁杂，我们往往很难在Servlet、JSP层妥善的处理好所有异常情况，代码中大量的try/catch代码显得尤为凌乱。我们通常面对下面两个主要问题： 1． 对异常实现集中式处理典型情况：对数据库异常记录错误日志。一般处理方法无外两种，一是在各处数据库访问代码的异常处理中，加上日志记录语句。二是将在数据访问代码中将异常向上抛出，并在上层结构中进行集中的日志记录处理 第一种处理方法失之繁琐、并且导致系统难以维护，假设后继需求为“对于数据库异常，需记录日志，并发送通知消息告知系统管理员”。我们不得不对分散在系统中的各处代码进行整改，工作量庞大。第二种处理方法实现了统一的异常处理，但如果缺乏设计，往往使得上层异常处理过于复杂。这里，我们需要的是一个设计清晰、成熟可靠的集中式异常处理方案。 2． 对未捕获异常的处理对于Unchecked Exception而言，由于代码不强制捕获，往往被程序员所忽略，如果运行期产生了Unchecked Exception，而代码中又没有进行相应的捕获和处理，则我们可能不得不面对尴尬的500服务器内部错误提示页面。这里，我们需要一个全面而有效的异常处理机制。 自己总结：Spring核心也就是IOC和DI，它实现了松散耦合，使业务逻辑代码不必依赖于Spring的接口，提高了可移植性。还有就是它的AOP是实现很多功能的基础（如事务等），使其可以做出大量的横切模块。 Spring中事务的包装事务的四个关键属性(ACID) 原子性(atomicity):事务是一个原子操作，有一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用 一致性(consistency):一旦所有事务动作完成，事务就被提交。数据和资源就处于一种满足业务规则的一致性状态中 隔离性(isolation):可能有许多事务会同时处理相同的数据，因此每个事物都应该与其他事务隔离开来，防止数据损坏 持久性(durability):一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响。通常情况下，事务的结果被写到持久化存储器中 隔离级别隔离级别 含义ISOLATION_DEFAULT 使用后端数据库默认的隔离级别ISOLATION_READ_UNCOMMITTED 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读ISOLATION_READ_COMMITTED 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生ISOLATION_REPEATABLE_READ 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生ISOLATION_SERIALIZABLE 最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的 首先来看一般的事务包装，TransactionTemplate类中的excute(TransactionCallBack)方法用来作事务操作，该方法中前后会做事务的处理工作，主要的业务是可以写在TransactionCallBack.doInTransaction()中，这是一个回调方法。 再看一下Hibernate的事务包装，HibernateTemplate类中也有excute方法，它与一般的jdbc事务差不多是在其中调用HibernateCallBack类的回调函数的，另外它还把Hibernate中的操作数据库的方法重写了如find,save等，调用的也是excute()方法，其实与一般性操作方法是一样的，只是多包装了几个通用方法。 先用datasource包装一下数据源，再把datasource传给transactionManagement完成事务包装，再可以把transactionManagement传给transactionTemplate来完成手工事务管理，传给动态代理类可以完成声明式事务管理。","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"Spring","slug":"软件开发/系统架构/Spring","permalink":"http://yoursite.com/categories/软件开发/系统架构/Spring/"}],"tags":[]},{"title":"服务容错设计","slug":"软件开发/系统架构/分布式架构/服务容错设计","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:14:35.621Z","comments":true,"path":"passages/软件开发/系统架构/分布式架构/服务容错设计/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/分布式架构/服务容错设计/","excerpt":"","text":"服务容错设计设计原则服务容错的设计有个基本原则，就是“Design for Failure”。为了避免出现“千里之堤溃于蚁穴”这种情况，在设计上需要考虑到各种边界场景和对于服务间调用出现的异常或延迟情况，同时在设计和编程时也要考虑周到。这一切都是为了达到以下目标： 1）一个依赖服务的故障不会严重破坏用户的体验。 2）系统能自动或半自动处理故障，具备自我恢复能力。 经典的容错模式超时与重试（Timeout and Retry）超时模式，是一种最常见的容错模式。常见的有设置网络连接超时时间，一次RPC的响应超时时间等。在分布式服务调用的场景中，它主要解决了当依赖服务出现建立网络连接或响应延迟，不用无限等待的问题，调用方可以根据事先设计的超时时间中断调用，及时释放关键资源，如Web容器的连接数，数据库连接数等，避免整个系统资源耗尽出现拒绝对外提供服务这种情况。 重试模式，一般和超时模式结合使用，适用于对于下游服务的数据强依赖的场景（不强依赖的场景不建议使用！），通过重试来保证数据的可靠性或一致性，常用于因网络抖动等导致服务调用出现超时的场景。与超时时间设置结合使用后，需要考虑接口的响应时间分布情况，超时时间可以设置为依赖服务接口99.5%响应时间的值，重试次数一般1-2次为宜，否则会导致请求响应时间延长，拖累到整个系统。 限流(Rate Limiting/Load Shedder)限流模式，常用于下游服务容量有限，但又怕出现突发流量猛增（如恶意爬虫，节假日大促等）而导致下游服务因压力过大而拒绝服务的场景。常见的限流模式有控制并发和控制速率，一个是限制并发的数量，一个是限制并发访问的速率 控制并发较常见的限流手段，在工程实践中可以通过信号量机制（如Java中的Semaphore）来控制 假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有十个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，我们就可以使用Semaphore来控制并发数 1234567891011121314151617181920212223242526272829public class SemaphoreTest &#123; private static final int THREAD_COUNT = 30; private static ExecutorService threadPool = Executors .newFixedThreadPool(THREAD_COUNT); private static Semaphore s = new Semaphore(10); public static void main(String[] args) &#123; for (int i = 0; i &lt; THREAD_COUNT; i++) &#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; s.acquire(); System.out.println(\"save data\"); s.release(); &#125; catch (InterruptedException e) &#123; e.printStack(); &#125; &#125; &#125;); &#125; threadPool.shutdown(); &#125;&#125; 控制速率使用令牌桶算法来实现这种模式 令牌桶算法是这么描述的： 每秒会有r个令牌放入桶中，或者说，每过1/r秒桶中增加一个令牌。 桶中最多存放b个令牌，如果桶满了，新放入的令牌会被丢弃。 当一个n字节的数据包到达时，消耗n个令牌，然后发送该数据包。 如果桶中可用令牌小于n，则该数据包将被缓存或丢弃。 令牌桶控制的是一个时间窗口内通过的数据量，在API层面我们常说的QPS、TPS，正好是一个时间窗口内的请求量或者事务量，只不过时间窗口限定在1s罢了。以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。令牌桶的另外一个好处是可以方便的改变速度，一旦需要提高速率，则按需提高放入桶中的令牌的速率 电路熔断器(Circuit Breaker)偶尔会遇到一些服务由于网络连接超时，系统有异常或load过高出现暂时不可用等情况，导致对这些服务的调用失败，可能需要一段时间才能修复，这种对请求的阻塞可能会占用宝贵的系统资源，如：内存，线程，数据库连接等等，最坏的情况下会导致这些资源被消耗殆尽，使得系统里不相关的部分所使用的资源也耗尽从而拖累整个系统。在这种情况下，调用操作能够立即返回错误而不是等待超时的发生或者重试可能是一种更好的选择，只有当被调用的服务有可能成功时我们再去尝试 熔断器模式可以防止我们的系统不断地尝试执行可能会失败的调用，使得我们的系统继续执行而不用等待修正错误，或者浪费CPU时间去等到长时间的超时产生。熔断器模式也可以使我们系统能够检测错误是否已经修正，如果已经修正，系统会再次尝试调用操作。下图是个使用熔断器模式的调用流程： 舱壁隔离(Bulkhead Isolation)线程隔离(Thread Isolation)就是这种模式的常见的一个场景。例如，系统A调用了ServiceB/ServiceC/ServiceD三个远程服务，且部署A的容器一共有120个工作线程，采用线程隔离机制，可以给对ServiceB/ServiceC/ServiceD的调用各分配40个线程。当ServiceB慢了，给ServiceB分配的40个线程因慢而阻塞并最终耗尽，线程隔离可以保证给ServiceC/ServiceD分配的80个线程可以不受影响。如果没有这种隔离机制，当ServiceB慢的时候，120个工作线程会很快全部被对ServiceB的调用吃光，整个系统会全部慢下来，甚至出现系统停止响应的情况。 这种Case在我们实践中经常遇到，如某接口由于数据库慢查询，外部RPC调用超时导致整个系统的线程数过高，连接数耗尽等。我们可以使用舱壁隔离模式，为这种依赖服务调用维护一个小的线程池，当一个依赖服务由于响应慢导致线程池任务满的时候，不会影响到其他依赖服务的调用，它的缺点就是会增加线程数。 回退(Fallback)在超时，重试失败，熔断或者限流发生的时候，为了及时恢复服务或者不影响到用户体验，需要提供回退的机制，常见的回退策略有： 自定义处理：在这种场景下，可以使用默认数据，本地数据，缓存数据来临时支撑，也可以将请求放入队列，或者使用备用服务获取数据等，适用于业务的关键流程与严重影响用户体验的场景，如商家/产品信息等核心服务。 故障沉默（fail-silent）：直接返回空值或缺省值，适用于可降级功能的场景，如产品推荐之类的功能，数据为空也不太影响用户体验。 快速失败（fail-fast）：直接抛出异常，适用于数据非强依赖的场景，如非核心服务超时的处理。","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"分布式架构","slug":"软件开发/系统架构/分布式架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/分布式架构/"}],"tags":[]},{"title":"高性能架构","slug":"软件开发/系统架构/分布式架构/高性能架构","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:14:38.926Z","comments":true,"path":"passages/软件开发/系统架构/分布式架构/高性能架构/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/分布式架构/高性能架构/","excerpt":"","text":"架构设计高性能架构性能分析：检查各处处理的日志，查看那个环节响应时间不合理，超过预期；然后检查监控数据，内存，磁盘，网络，CPU，查看是代码问题还是架构问题，或者资源确实不足。性能优化： 针对查到的原因进行优化，根据网站分层架构，可分为Web前端优化，应用服务器性能优化，存储服务器优化。 高并发原则无状态设计应用设计为无状态的，易于水平扩展。实际应用中一般为服务无状态，配置有状态，比如不同区域数据源的读取通过配置文件来指定 拆分 系统维度： 基于业务拆分。 功能拆分：对同一系统的不同功能进行拆分 读写维度： 模块维度：FO，MO，BO 使用消息队列异步，解耦，消峰。 缓存线程池异步Web前端优化主要优化浏览器访问，反向代理，CDN等 浏览器访问优化 减少HTTP请求 使用浏览器缓存 压缩数据 减少Cookie传输 CDN（内容分发网络）加速本质是一个缓存，把数据缓存在离用户最近的地方，CDN部署在网络运营商的机房，是网络的第一跳可以加快访问速度，减少服务器压力 反向代理反向代理提供了安全功能，缓存静态和部分动态数据，负载均衡的功能。 应用服务器优化优化方面主要有缓存、集群、异步 分布式缓存缓存的基本原理缓存本质是内存hash表，可以参考HashMap的实现机制 合理使用缓存 频繁修改的数据: 读写比最少2:1以上 没有热点访问的数据：不遵循二八定律，导致缓存意义不大 数据不一致，脏读：对缓存设置失效时间或者数据更新同时立刻更新缓存 缓存可用性: 当缓存崩溃是，避免造成数据库压力过大，可以通过集群方式处理，单台机器宕机不会造成太大影响。 缓存预热： 预先加载数据 缓存穿透： 不恰当逻辑或恶意攻击导致缓存失效，大规模数据库访问。解决办法可以缓存不存在数据 分布式缓存使用查看Redis 异步操作使用消息队列 异步 解耦 消峰 使用集群通过增加机器和负责均衡来达到优化的目的 代码优化 多线程： 并发可以提高性能，但是会带来多线程问题。可以通过几方面解决，将对象设计成无状态对象，使用函数局部对象，对并发访问的资源使用锁。 资源复用： 单例或者对象池 数据结构 垃圾回收性能优化 存储性能优化由于传统磁盘具有快速顺序读写，慢速随机读写的访问特性，文件系统和数据库通常会对数据排序后存储，以加快检索的速度，关系数据库使用B+树。它是N叉排序树，目前多采用两级索引的B+树，最多三层。 目前NoSQL主要使用LSM树 高可用架构很多问题会导致网站不可用，DNS会被劫持，CDS服务可能会挂掉，网站服务器可能会宕机，网络交换机可能失效，硬盘可能坏掉，网卡送掉，机房停电，黑客攻击，大量访问，第三方服务不可用。 应用层： 服务器通常为了应对高并发的访问请求，会通过负载均衡设备将一组服务器组成一个集群对外提供服务。当负载均衡设备通过心跳机制监测到某台应用服务器不可用，就会将其剔除，把请求转发到其他服务。从而实现无状态服务的失效转移。 服务层：也是通过集群实现高可用，应用层通过分布式服务调用框架访问，应用层客户端会在程序中实现软件均衡负载，通过服务注册中心发现服务。 数据层：因为存储着数据，为了保证数据不丢失，需要在数据写入是同步到多台数据服务器中，实现备份冗余。 应用服务器集群的Session管理事实上业务都是有状态的，保存好用户相关的状态，Web应用通常是通过Session保存的。 集群环境下，Session管理主要有以下的方法： Session复制：多台服务器之间复制，但是在大规模集群下会浪费大量的资源，造成性能问题 Session绑定：利用负载均衡的地址Hash算法，负载均衡服务器总是将同一IP的请求发送到同一服务器。但是服务器宕机会丢失Session 利用Cookie记录Session： cookie会有大小限制而且客户端可能关闭cookie Session服务器： session服务器独立出来和应用服务器分离，可以使用缓存来实现。 高可用服务除了使用负载均衡转移失效服务以外，还有以下高可用服务策略： 分级管理： 不用服务使用不同硬件，优先级高的服务使用较好硬件。 服务部署有必要实现隔离。 超时设置： 超时设置来及时的重试或转移请求到其他服务器 异步调用： 避免一个服务失败，导致整个请求失败，不重要的请求可以使用异步。 服务降级： 大量并发调用可能导致性能下降，严重时可能导致服务宕机。通常通过降级来实现，两种手段,拒绝服务和关闭服务 限流： 防止恶意请求流量，防止流量超出峰值。 幂等设计： 重发服务需要保证幂等性 负载均衡负载均衡算法：轮询，ip-hash,hash-key(哈希算法，一致性哈希)失败重试：心跳检查： 隔离（线程，功能）把系统或资源隔离开，在系统发生故障时，限定影响范围 线程隔离：同一模块划分线程池，防止一个线程池问题导致其他线程池受影响 进程隔离：0-1的系统，后期开始拆分模块实现物理隔离 集群隔离：比如秒杀服务部署单独集群 读写隔离： 读写分离 动静隔离： 动态和静态页面隔离 爬虫隔离： 使用openResty对爬虫user-agent过滤，路由到单独集群。 热点隔离： 读热点使用多级缓存，写热点使用缓存+MQ 超时与重试机制 回滚机制 高可用数据保证数据高可用主要有数据备份和失效转移机制。数据备份保证数据有多个副本，当某一个数据服务器宕机时，通过失效转移，把请求定向到其他服务器。 CAP原理可以知道，分布式环境的高可用会导致一致性问题。 伸缩性架构伸缩性是指不改变网站软硬件设计，通过改变部署服务器数量扩大服务处理能力 根据功能进行物理分离实现伸缩，包括纵向分层分割和横向业务分割分离 单一功能通过集群实现伸缩，集群伸缩又包括，应用服务器和数据服务器集群。 应用服务器集群伸缩应用服务器应该设计成无状态的，不存储上下文如用户信息，每次用户请求可以发送到集群任意服务器。请求的分发装置叫负载均衡服务器。有以下几种实现方式： Http重定向负载均衡 DNS域名解析负载均衡 反向代理负载均衡 IP负载均衡 数据链路层负载均衡：负载均衡服务器在链路层修改mac地址进行负载均衡 负载均衡算法 轮询（Round Robin） 加权轮询 随机 最少链接 源地址散列 分布式缓存集群伸缩一致性Hash算法来实现Key到缓存服务器的映射。 数据库服务器的集群伸缩和缓存不用，数据存储集群对数据持久和可用性的要求更高。","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"分布式架构","slug":"软件开发/系统架构/分布式架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/分布式架构/"}],"tags":[]},{"title":"Redis","slug":"软件开发/系统架构/分布式缓存/Redis","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:14:57.385Z","comments":true,"path":"passages/软件开发/系统架构/分布式缓存/Redis/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/分布式缓存/Redis/","excerpt":"","text":"Redis在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用 Redis 做一个缓冲操作，让请求先访问到 Redis，而不是直接访问数据库。 使用 Redis 的常见问题 缓存和数据库双写一致性问题 缓存雪崩问题 缓存击穿问题 缓存的并发竞争问题 Redis 是单线程工作模型。 原因主要是以下三点： 纯内存操作 单线程操作，避免了频繁的上下文切换 采用了非阻塞 I/O 多路复用机制 热数据和冷数据 值类型 Lists: 按插入顺序排序的字符串元素的集合。他们基本上就是链表（linked lists）。 Sets: 不重复且无序的字符串元素的集合。 Sorted sets,类似Sets,但是每个字符串元素都关联到一个叫score浮动数值（floating number value）。里面的元素总是通过- score进行着排序，所以不同的是，它是可以检索的一系列元素。（例如你可能会问：给我前面10个或者后面10个元素）。 Hashes,由field和关联的value组成的map。field和value都是字符串的。这和Ruby、Python的hashes很像。 Bit arrays (或者说 simply bitmaps): 通过特殊的命令，你可以将 String 值当作一系列 bits 处理：可以设置和清除单独的 - bits，数出所有设为 1 的 bits 的数量，找到最前的被设为 1 或 0 的 bit，等等。 HyperLogLogs: 这是被用于估计一个 set 中元素数量的概率性的数据结构 redis持久化redis支持两种持久化的方式，可以单独使用或者结合起来使用第一种：RDB方式（redis默认的持久化方式）第二种：AOF方式 一、RDBrdb方式的持久化是通过快照完成的，当符合一定条件时redis会自动将内存中的所有数据执行快照操作并存储到硬盘上。默认存储在redis根目录的dump.rdb文件中。(文件名在配置文件中dbfilename)redis进行快照的时机（在配置文件redis.conf中）save 900 1：表示900秒内至少一个键被更改则进行快照。save 300 10save 60 10000 redis自动实现快照的过程1：redis使用fork函数复制一份当前进程的副本(子进程)2：父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件3：当子进程写入完所有数据后会用该临时文件替换旧的RDB文件，至此，一次快照操作完成。注意：redis在进行快照的过程中不会修改RDB文件，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。 这就使得我们可以通过定时备份RDB文件来实现redis数据库的备份， RDB文件是经过压缩的二进制文件，占用的空间会小于内存中的数据，更加利于传输。 手动执行save或者bgsave命令让redis执行快照。两个命令的区别在于，save是由主进程进行快照操作，会阻塞其它请求。bgsave是由redis执行fork函数复制出一个子进程来进行快照操作。文件修复：redis-check-dump RDB存在哪些优势呢？1). 一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。 2). 对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。 3). 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。 4). 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。 RDB又存在哪些劣势呢？ 1). 如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。 2). 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。 二、AOF aof方式的持久化是通过日志文件的方式。默认情况下redis没有开启aof，可以通过参数appendonly参数开启。 appendonly yes aof文件的保存位置和rdb文件的位置相同，都是dir参数设置的，默认的文件名是appendonly.aof，可以通过 appendfilename参数修改 appendfilename appendonly.aof redis写命令同步的时机 a ppendfsync always 每次都会执行 appendfsync everysec 默认 每秒执行一次同步操作（推荐，默认） appendfsync no不主动进行同步，由操作系统来做，30秒一次 aof日志文件重写 auto-aof-rewrite-percentage 100(当目前aof文件大小超过上一次重写时的aof文件大小的百分之多少时会再次进行重写，如果之前没有重写，则以启动时的aof文件大小为依据) auto-aof-rewrite-min-size 64mb 手动执行bgrewriteaof进行重写 AOF的优势有哪些呢？ 1). 该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。 2). 由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。 3). 如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。 4). AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。 AOF的劣势有哪些呢？ 1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。 2). 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。 二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。 高可用（多副本Replication)在 Redis 复制的基础上，使用和配置主从复制非常简单，能使得从 Redis 服务器（下文称 slave）能精确得复制主 Redis 服务器（下文称 master）的内容。 当一个 master 实例和一个 slave 实例连接正常时， master 会发送一连串的命令流来保持对 slave 的更新，以便于将自身数据集的改变复制给 slave ， ：包括客户端的写入、key 的过期或被逐出等等。 当 master 和 slave 之间的连接断开之后，因为网络问题、或者是主从意识到连接超时， slave 重新连接上 master 并会尝试进行部分重同步：这意味着它会尝试只获取在断开连接期间内丢失的命令流。 当无法进行部分重同步时， slave 会请求进行全量重同步。这会涉及到一个更复杂的过程，例如 master 需要创建所有数据的快照，将之发送给 slave ，之后在数据集更改时持续发送命令流到 slave 。 选举机制 Slave of：在slave中指定master，但是如果master不可用，不会自动切换slave 哨兵：监控master和slave，保证master不可用时可以自动切换slave Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务： 监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。 提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。 自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。 redis-cluster Redis集群搭建的方式有多种，例如使用zookeeper等，但从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接 其结构特点： 1. 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。 2. 节点的fail是通过集群中超过半数的节点检测失效时才生效。 3. 客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。 4. redis-cluster把所有的物理节点映射到[0-16383]slot上（不一定是平均分配）,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value。 5. Redis集群预分好16384个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中 集群中至少应该有奇数个节点，所以至少有三个节点，每个节点至少有一个备份节点，所以下面使用6节点（主节点、备份节点由redis-cluster集群确定）。 Redis主从复制原理Redis虽然读取写入的速度都特别快，但是也会产生读压力特别大的情况。为了分担读压力，Redis支持主从复制，Redis的主从结构可以采用一主多从或者级联结构，Redis主从复制可以根据是否是全量分为全量同步和增量同步。 全量同步Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下： 1）从服务器连接主服务器，发送SYNC命令； 2）主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； 3）主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； 4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； 5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； 6）从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令； 增量同步Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令 Redis主从同步策略主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步 如果多个Slave断线了，需要重启的时候，因为只要Slave启动，就会发送sync请求和主机全量同步，当多个同时出现的时候，可能会导致Master IO剧增宕机 水平扩展(分区Partitioning ) The normal client communication port (usually 6379) used to communicate with clients to be open to all the clients that need to reach the cluster, plus all the other cluster nodes (that use the client port for keys migrations). The cluster bus port (the client port + 10000) must be reachable from all the other cluster nodes. 分区是将你的数据分发到不同redis实例上的一个过程，每个redis实例只是你所有key的一个子集 Redis分区主要有两个目的: 分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。 分区使Redis的计算能力通过简单地增加计算机得到成倍提升,Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。 读写路由，Partitioning的不同实现方式分区可以在程序的不同层次实现。 客户端分区就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。 代理分区 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是Twemproxy 查询路由(Query routing) 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接redirected到正确的redis节点。 写入时Sharding 策略Redis集群是 query routing 和 client side partitioning的一种混合实现。 Redis 集群没有使用一致性hash, 而是引入了 哈希槽的概念. Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么: 节点 A 包含 0 到 5500号哈希槽. 节点 B 包含5501 到 11000 号哈希槽. 节点 C 包含11001 到 16384号哈希槽. 一致性保证Redis 并不能保证数据的强一致性. 这意味这在实际中集群在特定的条件下可能会丢失写操作. 第一个原因是因为集群是用了异步复制. 写操作过程: 客户端向主节点B写入一条命令. 主节点B向客户端回复命令状态. 主节点将写操作复制给他得从节点 B1, B2 和 B3. 主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 数据自动均衡Resharding就是把hash slots从一个实例复制到另一个实例，redis还不能自动reshard，可以用redis-cli来实现 ./redis-trib.rb reshard 127.0.0.1:7000 缓存穿透和缓存雪崩问题缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。 缓存穿透解决方案： 利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。 采用异步更新策略，无论 Key 是否取到值，都直接返回。Value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的 Key。迅速判断出，请求所携带的 Key 是否合法有效。如果不合法，则直接返回。 缓存雪崩缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。 缓存雪崩解决方案： 给缓存的失效时间，加上一个随机值，避免集体失效。 使用互斥锁，但是该方案吞吐量明显下降了。 双缓存。我们有两个缓存，缓存 A 和缓存 B。缓存 A 的失效时间为 20 分钟，缓存 B 不设失效时间。自己做缓存预热操作。 然后细分以下几个小点：从缓存 A 读数据库，有则直接返回；A 没有数据，直接从 B 读数据，直接返回，并且异步启动一个更新线程，更新线程同时更新缓存 A 和缓存 B。 redis 基本配置123456789101112#what?局域网内本机IP。#why?只接受外部程序发送到IP 172.17.84.39的数据。 #resoult:更加安全，因为只有同一局域网内的机器能够访问。当然也可以把bind注释掉，以支持包括外网在内的所有IP。bind 172.17.84.39#修改默认端口，避免被恶意脚本扫描。port 9999loglevel debuglogfile /usr/local/redis/logs/redis.log.9999#为服务设置安全密码requirepass redispass#以守护进程方式运行daemonize yes 主从复制（master-slave）主从模式的两个重要目的，提升系统可靠性和读写分离提升部分性能 slave机需要修改一下配置 1234567port 9997logfile /usr/local/redis/logs/redis.log.9997#指定master ip portslaveof 172.17.84.39 9999#认证master时需要的密码。必须和master配置的requirepass 保持一致masterauth redispassprotected-mode no Replication (sentinel模式故障自动迁移)Master-slave主从复制避免了数据丢失带来的灾难性后果。 但是单点故障仍然存在，在运行期间master宕机需要停机手动切换。 Sentinel很好的解决了这个问题，当Master-slave模式中的Master宕机后，能够自主切换，选择另一个可靠的redis-server充当master角色，使系统仍正常运行 1234567891011121314#服务运行端口号port 26379#mymaster为指定的master服务器起一个别名#master IP和端口号#2的含义：当开启的sentinel server认为当前master主观下线的（+sdown）数量达到2时，则sentinel server认为当前master客观下线（+odown）系统开始自动迁移。2的计算（建议）：sentinel server数量的大多数，至少为count（sentinel server）/2 向上取整。2&gt;3/2（主观下线与客观下线？）sentinel monitor mymaster 172.17.84.39 9999 2#master别名和认证密码。这就提醒了用户，在master-slave系统中，各服务的认证密码应该保持一致。sentinel auth-pass mymaster redispass#以守护进程方式运行daemonize yeslogfile /usr/local/redis/logs/sentinel.log.26379protected-mode nosentinel down-after-milliseconds mymaster 6000sentinel failover-timeout mymaster 18000 Clusterredis.conf12345port 7000cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000appendonly yes ~/Work/Develop/redis-5.0.3/src/redis-server ~/Work/Develop/redis-5.0.3/cluster/17001/redis.conf &amp;~/Work/Develop/redis-5.0.3/src/redis-server ~/Work/Develop/redis-5.0.3/cluster/17002/redis.conf &amp;~/Work/Develop/redis-5.0.3/src/redis-server ~/Work/Develop/redis-5.0.3/cluster/17003/redis.conf &amp;~/Work/Develop/redis-5.0.3/src/redis-server ~/Work/Develop/redis-5.0.3/cluster/17004/redis.conf &amp;~/Work/Develop/redis-5.0.3/src/redis-server ~/Work/Develop/redis-5.0.3/cluster/17005/redis.conf &amp;~/Work/Develop/redis-5.0.3/src/redis-server ~/Work/Develop/redis-5.0.3/cluster/17006/redis.conf &amp; 搭建集群通过向实例发送特殊命令来完成创建新集群 ~/Work/Develop/redis-5.0.3/src/redis-cli –cluster create 127.0.0.1:17006 127.0.0.1:17001 127.0.0.1:17002 127.0.0.1:17003 127.0.0.1:17004 127.0.0.1:17005 –cluster-replicas 1 这个命令在这里用于创建一个新的集群, 选项–replicas 1 表示我们希望为集群中的每个主节点创建一个从节点 测试集群写入数据1234567~/Work/Develop/redis-5.0.3/src/redis-cli -c -p 17001127.0.0.1:17001&gt; set foo bar-&gt; Redirected to slot [12182] located at 127.0.0.1:17002OK127.0.0.1:17002&gt; set hello world-&gt; Redirected to slot [866] located at 127.0.0.1:17006OK ~/Work/Develop/redis-5.0.3/src/redis-cli -p 17001 cluster nodes","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"分布式缓存","slug":"软件开发/系统架构/分布式缓存","permalink":"http://yoursite.com/categories/软件开发/系统架构/分布式缓存/"}],"tags":[]},{"title":"分表分库","slug":"软件开发/系统架构/数据存储/分表分库","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:15:32.770Z","comments":true,"path":"passages/软件开发/系统架构/数据存储/分表分库/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/数据存储/分表分库/","excerpt":"","text":"分表分库基本思想Sharding的基本思想就要把一个数据库切分成多个部分放到不同的数据库(server)上，从而缓解单一数据库的性能问题。 对于海量数据的数据库，如果是因为表多而数据多，这时候适合使用垂直切分，即把关系紧密（比如同一模块）的表切分出来放在一个server上。 如果表并不多，但每张表的数据非常多，这时候适合水平切分，即把表的数据按某种规则（比如按ID散列）切分到多个数据库(server)上。 当然，现实中更多是这两种情况混杂在一起，这时候需要根据实际情况做出选择，也可能会综合使用垂直与水平切分，从而将原有数据库切分成类似矩阵一样可以无限扩充的数据库(server)阵列 分库分表需要解决的问题事务问题解决事务问题目前有两种可行的方案：分布式事务和通过应用程序与数据库共同控制实现事务下面对两套方案进行一个简单的对比。 方案一：使用分布式事务优点：交由数据库管理，简单有效缺点：性能代价高，特别是shard越来越多时方案二：由应用程序和数据库共同控制原理：将一个跨多个数据库的分布式事务分拆成多个仅处 于单个数据库上面的小事务，并通过应用程序来总控 各个小事务。优点：性能上有优势缺点：需要应用程序在事务控制上做灵活设计。如果使用 了spring的事务管理，改动起来会面临一定的困难。 跨节点Join的问题只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 跨节点的count,order by,group by以及聚合函数问题这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。 ID问题一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由. 一些常见的主键生成策略： (1)UUID使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 (2)结合数据库维护一个Sequence表此方案的思路也很简单，在数据库中建立一个Sequence表，表的结构类似于 每当需要为某个表的新纪录生成ID时就从Sequence表中取出对应表的nextid,并将nextid的值加1后更新到数据库中以备下次使用。此方案也较简单，但缺点同样明显：由于所有插入任何都需要访问该表，该表很容易成为系统性能瓶颈，同时它也存在单点问题，一旦该表数据库失效，整个应用程序将无法工作 (3)Twitter的分布式自增ID算法Snowflake在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位 在上面的字符串中，第一位为未使用（实际上也可作为long的符号位），接下来的41位为毫秒级时间，然后5位datacenter标识位，5位机器ID（并不算标识符，实际是为线程标识），然后12位该毫秒内的当前毫秒内的计数，加起来刚好64位，为一个Long型。 这样的好处是，整体上按照时间自增排序，并且 整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分），并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。 跨分片的排序分页分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序 分库策略一般有两种方式： 根据数值范围，比如用户Id为1-9999的记录分到第一个库，10000-20000的分到第二个库，以此类推。根据数值取模，比如用户Id mod n，余数为0的记录放到第一个库，余数为1的放到第二个库，以此类推。优劣比较： 评价指标按照范围分库按照Mod分库库数量前期数目比较小，可以随用户/业务按需增长前期即根据mode因子确定库数量，数目一般比较大访问性能前期库数量小，全库查询消耗资源少，单库查询性能略差前期库数量大，全库查询消耗资源多，单库查询性能略好调整库数量比较容易，一般只需为新用户增加库，老库拆分也只影响单个库困难，改变mod因子导致数据在所有库之间迁移数据热点新旧用户购物频率有差异，有数据热点问题新旧用户均匀到分布到各个库，无热点 分库数量首先和单库能处理的记录数有关，一般来说，Mysql 单库超过5000万条记录，Oracle单库超过1亿条记录，DB压力就很大(当然处理能力和字段数量/访问模式/记录长度有进一步关系)。","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"数据存储","slug":"软件开发/系统架构/数据存储","permalink":"http://yoursite.com/categories/软件开发/系统架构/数据存储/"}],"tags":[]},{"title":"事务","slug":"软件开发/系统架构/数据存储/事务","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:15:29.437Z","comments":true,"path":"passages/软件开发/系统架构/数据存储/事务/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/数据存储/事务/","excerpt":"","text":"数据库事务由两个文件组成的，一个数据库文件和一个日志文件，通常情况下，日志文件都要比数据库文件大很多。数据库进行任何写入操作的时候都是要先写日志的，同样的道理，我们在执行事务的时候数据库首先会记录下这个事务的redo操作日志，然后才开始真正操作数据库，在操作之前首先会把日志文件写入磁盘，那么当突然断电的时候，即使操作没有完成，在重新启动数据库时候，数据库会根据当前数据的情况进行undo回滚或者是redo前滚，这样就保证了数据的强一致性 数据库事务具有ACID特性 数据库系统釆用日志来保证事务的原子性、一致性和持久性，发生错误时根据日志来回滚回事取消更新。 釆用锁机制来实现事务的隔离性。有共享锁，更新锁，独占锁等。 数据库事务是为了保证数据的正确无误。多事务并发时会引起，脏读，虚读，不可重复读，丢失更新等问题。这些问题都可以通过加锁机制来解决。 加锁的方法： 在事务中对资源显示（手工）的加锁。 数据库系统自动管理锁。通常情况下优先使用数据库自动管理锁，它会分析事务中的SQL语句，然后自动为SQL语句所操作的数据资源加上合适的锁，而且在锁的数目太多时，会自动进行锁升级，以提高系统性能。 为了能让用户在事务的隔离性与并发性之间做出合理的权衡，数据库系统提供了四种事务隔离级别。 Serializable：串行化 Repeatable Read：可重复读 Read Commited：读已提交数据 Read Uncommited：读未提交的数据 通常情况下可以把隔离级别设为Read Commited，它能避免脏读，而且有较好的并发性能。尽管它会导致不可重复读、虚读和第二类更新丢失等问题，在可能出现这类问题的个别场合可以由应用程序釆用悲观锁或乐观锁来控制。 JTA两阶段提交（2PC）对数据库分布式事务有了解的同学一定知道数据库支持的2PC，又叫做 XA Transactions。 MySQL从5.5版本开始支持，SQL Server 2005 开始支持，Oracle 7 开始支持。 其中，XA 是一个两阶段提交协议，该协议分为以下两个阶段：第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.第二阶段：事务协调器要求每个数据库提交数据。 当需要使用多个事务性资源时，才需要使用JTA（典型应用，关系数据库与消息队列）。而大多数应用并不需要跨多个数据源(也就是说多个connection)，许多高端应用使用单一的，高伸缩性的数据库如Oracle 9i J2EE有两个事务管理的选择： 全局或本地事务。全局事务由应用服务器管理，使用JTA。局部事务是和资源相关的，比如一个和JDBC连接关联的事务。 优点： 尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证强一致）缺点： 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景，如果分布式系统跨接口调用，目前 .NET 界还没有实现方案。 补偿事务（TCC）TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段： Try 阶段主要是对业务系统做检测及资源预留 Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。 Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。 优点： 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些缺点： 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。 本地消息表（异步确保）其核心思想是将分布式事务拆分成本地事务进行处理，这种思路是来源于ebay基本思路就是： 消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。 消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。 生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。 这种方案遵循BASE理论，采用的是最终一致性，笔者认为是这几种方案里面比较适合实际业务场景的，即不会出现像2PC那样复杂的实现(当调用链很长的时候，2PC的可用性是非常低的)，也不会像TCC那样可能出现确认或者回滚不了的情况。 优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。在 .NET中 有现成的解决方案。 缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。 分布式理论这里所说的分区指的是物理分区，分区之后可能不同的库就处于不同的服务器上了，这个时候单个数据库的ACID已经不能适应这种情况了，而在这种ACID的集群环境下，再想保证集群的ACID几乎是很难达到，或者即使能达到那么效率和性能会大幅下降，最为关键的是再很难扩展新的分区了，这个时候如果再追求集群的ACID会导致我们的系统变得很差，这时我们就需要引入一个新的理论原则来适应这种集群的情况，就是 CAP 原则或者叫CAP定理 CAP定理CAP定理是由加州大学伯克利分校Eric Brewer教授提出来的，他指出WEB服务无法同时满足一下3个属性： 一致性(Consistency) ： 客户端知道一系列的操作都会同时发生(生效) 可用性(Availability) ： 每个操作都必须以可预期的响应结束 分区容错性(Partition tolerance) ： 即使出现单个组件无法可用,操作依然可以完成 BASE理论在分布式系统中，我们往往追求的是可用性，它的重要程序比一致性要高，那么如何实现高可用性呢？ 前人已经给我们提出来了另外一个理论，就是BASE理论，它是用来对CAP定理进行进一步扩充的。BASE理论指的是： Basically Available（基本可用） Soft state（软状态） Eventually consistent（最终一致性） BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性 Spring 事物Spring 的 TransactionDefinition接口指定： 事务隔离：当前事务和其它事务的隔离的程度。例如，这个事务能否看到其他事务未提交的数据。 事务传播：嵌套事务中使用，通常在一个事务中执行的所有代码都会在这个事务中运行。但是，如果一上事务上下文已经存在，有几个选项可以指定一个事务性方法的执行行为：例如，简单地在现有的事务中继续运行（大多数情况）；或者挂起现有事务，创建一个新的事务。Spring提供EJB CMT中常见的事务传播选项。 事务超时：事务在超时前能动行多久（自动被底层的事务基础设施回滚）。 只读状态：只读事务不修改任何数据。只读事务在某些情况下（例如当使用Hibernate时），是一个非常有用的优化。 Spring 默认在程序throw UnCheckException时回滚事务，throw CheckException时不做事务的回滚，这点需要注意。 如果看的仔细可以看出以下几点，事务操作基本上是一个整体的，理清以后可以看出巨完整。以下就来连起来说一下： 当数据库被一群牛人从外星带来以后，为了做到一次完整业务操作不会因为中途的操作失败而使用数据库中的数据错误的问题，牛人们决定启用数据库事务来保证数据的正确性。 他们用数据库日志来保证一次完整的操作，用加锁机制来保证并发访问的情况下的一系列问题。 数据库日志没什么好说的，那些老大不让咱们动，一般也不用在程序中动。就来说一下加锁机制好了，咱们可以手动加锁，也可以用数据库系统提供的事务隔离级别来做自动加锁，如果你也是也狂牛，你可以用全手动加锁：）嘿嘿嘿！一般来说都是用事务隔离级别＋部分手动加锁在程序里实现事务性功能。 以上几点就是整个事务的一个层次结构，当然还有一些细节的东西，那些可以在个体应用时再看了。 在所有使用 spring 的应用中, 声明式事务管理可能是使用率最高的功能了, 但是, 从我观察到的情况看,绝大多数人并不能深刻理解事务声明中不同事务传播属性配置的的含义, 让我们来看一下 TransactionDefinition 接口中的定义 在 spring 中一共定义了六种事务传播属性, 如果你觉得看起来不够直观, 那么我来转贴一个满大街都有的翻译引用 PROPAGATION_REQUIRED – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 PROPAGATION_SUPPORTS – 支持当前事务，如果当前没有事务，就以非事务方式执行。 PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。 PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。 PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。 PROPAGATION_NESTED – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。 前六个策略类似于EJB CMT，第七个（PROPAGATION_NESTED）是Spring所提供的一个特殊变量。 它要求事务管理器或者使用JDBC 3.0 Savepoint API提供嵌套事务行为（如Spring的DataSourceTransactionManager） 认为 Service 之间应该避免互相调用, 其实根本不用担心这点， PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行.另一方面, PROPAGATION_NESTED 开始一个 “嵌套的” 事务, 它是已经存在事务的一个真正的子事务. 潜套事务开始执行时, 它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交. 由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于, PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 潜套事务也会被 commit, 这个规则同样适用于 roll back. 代码不做任何修改, 那么如果内部事务(即 ServiceB#methodB) rollback, 那么首先 ServiceB.methodB 回滚到它执行之前的 SavePoint(在任何情况下都会如此),外部事务(即 ServiceA#methodA) 将根据具体的配置决定自己是 commit 还是 rollback (+MyCheckedException). 上面大致讲述了潜套事务的使用场景, 下面我们来看如何在 spring 中使用 PROPAGATION_NESTED, 首先来看 AbstractPlatformTransactionManager 我们要设置 transactionManager 的 nestedTransactionAllowed 属性为 true, 注意, 此属性默认为 false!!!可以看到 Savepoint 是 SavepointManager.createSavepoint 实现的, 再看 SavepointManager 的层次结构, 发现其 Template 实现是 JdbcTransactionObjectSupport, 常用的 DatasourceTransactionManager, HibernateTransactionManager中的 TransactonObject 都是它的子类 :JdbcTransactionObjectSupport 告诉我们必须要满足两个条件才能 createSavepoint : java.sql.Savepoint 必须存在, 即 jdk 版本要 1.4+ Connection.getMetaData().supportsSavepoints() 必须为 true, 即 jdbc drive 必须支持 JDBC 3.0确保以上条件都满足后, 你就可以尝试使用 PROPAGATION_NESTED 了.","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"数据存储","slug":"软件开发/系统架构/数据存储","permalink":"http://yoursite.com/categories/软件开发/系统架构/数据存储/"}],"tags":[]},{"title":"Lucence","slug":"软件开发/系统架构/搜索引擎/Lucence","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:15:00.426Z","comments":true,"path":"passages/软件开发/系统架构/搜索引擎/Lucence/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/搜索引擎/Lucence/","excerpt":"","text":"[TOC] 一、环境需要导入lucene.jar包（在lucene.apache.org下载） 二、基本概念1．Lucene的工作流程： 使用IndexWriter，在指定的目录建立索引的文件 将需要检索的数据转换位Document的Filed对象，然后将Document用IndexWriter添加倒索引的文件中 处理索引信息，关闭IndexWriter流 创建搜索的Query 给IndexSearcher 2．Lucene的字段类型Lucene有四种不同的字段类型：Keyword，UnIndexed，UnStored和Text，用于指定建立最佳索引。 Keyword字段是指不需要分析器解析但需要被编入索引并保存到索引中的部分。JavaSourceCodeIndexer类使用该字段来保存导入类的声明。 UnIndexed字段是既不被分析也不被索引，但是要被逐字逐句的将其值保存到索引中。由于我们一般要存储文件的位置但又很少用文件名作为关键字来搜索，所以用该字段来索引Java文件名。 UnStored字段和UnIndexed字段相反。该类型的Field要被分析并编入索引，但其值不会被保存到索引中。由于存储方法的全部源代码需要大量的空间。所以用UnStored字段来存储被索引的方法源代码。可以直接从Java源文件中取出方法的源代码，这样作可以控制我们的索引的大小。 Text字段在索引过程中是要被分析、索引并保存的。类名是作为Text字段来保存。下表展示了JavaSourceCodeIndexer类使用Field字段的一般情况。 3．基本概念（与传统表的对比）：Lucene 传统表 说明IndexWriter tableDocument 一条记录Field 每个字段 分为可被索引的，可切分的，不可被切分的，不可被索引的几种组合类型Hits RecoreSet 结果集 IndexWriter提供了一些参数可供设置，列表如下 属性 默认值 说明mergeFactor org.apache.lucene.mergeFactor 10 控制index的大小和频率,两个作用 一个段有多少document 多少个段合成一个大段 maxMergeDocs org.apache.lucene.maxMergeDocs Integer.MAX_VALUE 限制一个段中的document数目 minMergeDocs org.apache.lucene.minMergeDocs 10 缓存在内存中的document数目，超过他以后会写入到磁盘 maxFieldLength 1000 一个Field中最大Term数目，超过部分忽略，不会index到field中，所以自然也就搜索不到 这些参数的的详细说明比较复杂：mergeFactor有双重作用 设置每mergeFactor个document写入一个段，比如每10个document写入一个段 设置每mergeFacotr个小段合并到一个大段，比如10个document的时候合并为1小段，以后有10个小段以后合并到一个大段，有10个大段以后再合并，实际的document数目会是mergeFactor的指数 简单的来说mergeFactor 越大，系统会用更多的内存，更少磁盘处理，如果要打批量的作index，那么把mergeFactor设置大没错， mergeFactor 小了以后， index数目也会增多，searhing的效率会降低，但是mergeFactor增大一点一点，内存消耗会增大很多(指数关系),所以要留意不要”out of memory”把maxMergeDocs设置小，可以强制让达到一定数量的document写为一个段，这样可以抵消部分mergeFactor的作用.minMergeDocs相当于设置一个小的cache,第一个这个数目的document会留在内存里面，不写入磁盘。这些参数同样是没有最佳值的，必须根据实际情况一点点调整。maxFieldLength可以在任何时刻设置，设置后，接下来的index的Field会按照新的length截取，之前已经index的部分不会改变。可以设置为Integer.MAX_VALUE 4．几种查询方式查询方式 说明TermQuery 条件查询例如：TermQuery tquery=new TermQuery(new Term(&quot;name&quot;,&quot;jerry&quot;));name:字段名jerry:要搜索的字符串12345678910MultiTermQuery 多个字段进行同一关键字的查询Query query= null;Query =MultiFieldQueryParser.parse(\"我\",new String[] &#123;\"title\",\"content\"&#125;,analyzer);Searcher searcher=new IndexSearcher(indexFilePath); Hits hits=searcher.search(query);BooleanQuery 例如：BooleanQuery bquery=new BooleanQuery(); bquery.add(query,true,false); bquery.add(mquery,true,false); bquery.add(tquery,true,false); Searcher searcher=new IndexSearcher(indexFilePath); Hits hits=searcher.search(bquery); WildcardQuery 语义查询（通配符查询）例：Query query= new WildcardQuery(new Term(&quot;sender&quot;,&quot;*davy*&quot;)); PhraseQuery 短语查询 PrefixQuery 前缀查询 PhrasePrefixQuery 短语前缀查询 FuzzyQuery 模糊查询 RangeQuery 范围查询 SpanQuery 范围查询在全文检索时建议大家先采用语义时的搜索，先搜索出有意义的内容，之后再进行模糊之类的搜索 (1)联合两个索引查询，已解决：123456IndexSearcher[] searchers = new IndexSearcher[2]; searchers[0] = new IndexSearcher(m_indexpath); searchers[1] = new IndexSearcher(m_outindexpath); MultiSearcher multiSearcher = new MultiSearcher(searchers); (2)还有个进行多条件搜索 and 与 or 的操作————123456789用 MultiFieldQueryParser 建议重新封装 MultiFieldQueryParser.Parser(p[],d[],f[],analyer) 成or 与 and操作合一 或者 BooleanQuery m_BooleanQuery = new BooleanQuery(); Query query = QueryParser.Parse(m_SearchText, \"INSTRUMENT_NAME\", analyzer); Query query2 = QueryParser.Parse(m_SearchText2, \"INSTRUMENT_NAME2\", analyzer); m_BooleanQuery.Add(query, true, false); m_BooleanQuery.Add(query2, true, false); (3)复合查询（多种查询条件的综合查询）123456Query query=MultiFieldQueryParser.parse(\"索引”,new String[] &#123;\"title\",\"content\"&#125;,analyzer);Searcher searcher=new IndexSearcher(indexFilePath);Hits hits=searcher.search(query);for (int i = 0; i &lt; hits.length(); i++) &#123; System.out.println(hits.doc(i).get(\"name\"));&#125; 5. 为查询优化索引(index)Indexwriter.optimize()方法可以为查询优化索引（index），之前提到的参数调优是为indexing过程本身优化，而这里是为查询优化，优化主要是减少index文件数，这样让查询的时候少打开文件，优化过程中，lucene会拷贝旧的index再合并，合并完成以后删除旧的index，所以在此期间，磁盘占用增加， IO符合也会增加，在优化完成瞬间，磁盘占用会是优化前的2倍,在optimize过程中可以同时作search。 org.apache.lucene.document.Field 即上文所说的“字段”，它是Document的片段section。 Field的构造函数： Field(String name, String string, boolean store, boolean index, boolean token)。 Indexed：如果字段是Indexed的，表示这个字段是可检索的。 Stored：如果字段是Stored的，表示这个字段的值可以从检索结果中得到。 Tokenized：如果一个字段是Tokenized的，表示它是有经过Analyzer转变后成为一个tokens序列，在这个转变过程tokenization中， Analyzer提取出需要进行索引的文本，而剔除一些冗余的词句（例如：a，the,they等，详见 org.apache.lucene.analysis.StopAnalyzer.ENGLISH_STOP_WORDS和 org.apache.lucene.analysis.standard.StandardAnalyzer(String[] stopWords)的API）。Token是索引时候的. 类型 Analyzed Indexed Stored 说明Field.Keyword(String,String/Date) N Y Y 这个Field用来储存会直接用来检索的比如(编号,姓名,日期等)Field.UnIndexed(String,String) N N Y 不会用来检索的信息,但是检索后需要显示的,比如,硬件序列号,文档的url地址Field.UnStored(String,String) Y Y N 大段文本内容,会用来检索,但是检索后不需要从index中取内容,可以根据url去load真实的内容Field.Text(String,String) Y Y Y 检索,获取都需要的内容,直接放index中,不过这样会增大indexField.Text(String,Reader) Y Y N 如果是一个Reader, lucene猜测内容比较多,会采用Unstored的策略. Lucene 的检索结果排序 Lucene的排序主要是对org.apache.lucene.search.Sort的使用。Sort可以直接根据字段Field生成，也可以根据标准的SortField生成，但是作为Sort的字段，必须符合以下的条件：唯一值以及Indexed。可以对Integers, Floats, Strings三种类型排序。 对整数型的ID检索结果排序只要进行以下的简单操作：Sort sort = new Sort(“id”); Hits hits = searcher.search(query, sort);用户还可以根据自己定义更加复杂的排序，详细请参考API。 6．分析器Lucene使用分析器来处理被索引的文本。在将其存入索引之前，分析器用于将文本标记化、摘录有关的单词、丢弃共有的单词、处理派生词（把派生词还原到词根形式，意思是把bowling、bowler和bowls还原为bowl）和完成其它要做的处理。Lucene提供的通用分析器是： SimpleAnalyzer：用字符串标记一组单词并且转化为小写字母。 StandardAnalyzer：用字符串标记一组单词，可识别缩写词、email地址、主机名称等等。并丢弃基于英语的stop words (a, an, the, to)等、处理派生词。 ChineseAnalyzer.class，它是一个单字分析法，它把句子中的词全部分成一个一个的字符，以单个字为单位存储。CJKAnalyzer.class，它是双字分析法，它把中文以双字为单位拆分得到结果，从而建立词条。当然这些得到的双字词中会有很多不符合中文语义单位的双字被送进索引。 十、需要注意的问题： IndexWriter在添加新的document后，需要重新建立Index，则需要调用writer.optimize();方法 Lucene没有update索引的方法，需要删除后重新建立，参考remove方法 用IndexReader删除Document后，需要重新用IndexWriter进行整理，否则无法在进行搜索（不知道是不是我设置问题） Lucene先在内存中进行索引操作，并根据一定的批量进行文件的写入。这个批次的间隔越大，文件的写入次数越少，但占用内存会很多。反之占用内存少，但文件IO操作频繁，索引速度会很慢。在IndexWriter中有一个MERGE_FACTOR参数可以帮助你在构造索引器后根据应用环境的情况充分利用内存减少文件的操作。根据我的使用经验：缺省Indexer是每20条记录索引后写入一次，每将MERGE_FACTOR增加50倍，索引速度可以提高1倍左右。 并发操作Lucene(1)所有只读操作都可以并发(2)在index被修改期间，所有只读操作都可以并发(3)对index修改操作不能并发，一个index只能被一个线程占用(4)ndex的优化，合并，添加都是修改操作(5)但需要注意的是,在创建搜索的时候用:searcher = new IndexSearcher(IndexReader.open(“E:\\lucene\\test4\\index”));searcher.close();这时候是不能关闭searcher的.如果想让searcher能关闭,就不要用IndexReader了:searcher = new IndexSearcher(“E:\\lucene\\test4\\index”); Locking机制lucence内部使用文件来locking，默认的locking文件放在java.io.tmpdir,可以通过-Dorg.apache.lucene.lockDir=xxx指定新的dir，有write.lock commit.lock两个文件，lock文件用来防止并行操作index，如果并行操作， lucene会抛出异常，可以通过设置-DdisableLuceneLocks=true来禁止locking，这样做一般来说很危险，除非你有操作系统或者物理级别的只读保证，比如把index文件刻盘到CDROM上。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970实例：1.判断索引文件是否存在:/** * 检查索引是否存在. * @param indexDir * @return */ public static boolean indexExist(String indexDir) &#123; return IndexReader.indexExists(indexDir); &#125; private IndexWriter getWriter(String indexFilePath) throws Exception &#123; boolean append=true; File file=new File(indexFilePath+File.separator+\"segments\"); if(file.exists()) append=false; return new IndexWriter(indexFilePath,analyzer,append); &#125; 2.删除索引/** * 删除索引. * @param aTerm 索引删除条件 * @param indexDir 索引目录 */ public static void deleteIndex(Term aTerm, String indexDir) &#123; List aList = new ArrayList(); aList.add(aTerm); deleteIndex(aList, indexDir); &#125; /** * 删除索引. * @param aTerm 索引删除条件. * @param indexDir 索引目录 * */ public static void deleteIndex(List terms, String indexDir) &#123; if (null == terms) &#123; return; &#125; if(!indexExist(indexDir)) &#123; return; &#125; IndexReader reader = null; try &#123; reader = IndexReader.open(indexDir); for (int i = 0; i &lt; terms.size(); i++)&#123; Term aTerm = (Term) terms.get(i); if (null != aTerm)&#123; reader.delete(aTerm); &#125; &#125; &#125; catch (IOException e)&#123; LogMan.warn(\"Error in Delete Index\", e); &#125; finally &#123; try&#123; if (null != reader)&#123; reader.close(); &#125; &#125;catch (IOException e)&#123; LogMan.warn(\"Close reader Error\"); &#125; &#125; &#125; 删除索引需要一个条件,类似数据库中的字段条件,例如删除一条新闻的代码如下: public static void deleteNewsInfoIndex(int nid) &#123; Term aTerm = new Term(\"nid\", String.valueOf(nid)); deleteIndex(aTerm,indexDir); &#125; Lucene几个重要部分：1、分词2、索引3、搜索 分词方式对数据搜索的性能影响特别大，在基于数据库的查询时对单字段可做二元，四元等分词，这样主要是为了减少clause数量，它是索引和搜索的关键。索引的问题就是新建和更新，批量新建时可以用RAMDirectory先写，最后再并入FSDirectory中去，可以加快速度，更新时要先删除一个再新增一个。 搜索有Query子类声明和QueryParser转换两种方式，最终都会变为BooleanQuery来进行搜索。","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"搜索引擎","slug":"软件开发/系统架构/搜索引擎","permalink":"http://yoursite.com/categories/软件开发/系统架构/搜索引擎/"}],"tags":[]},{"title":"Restful","slug":"软件开发/系统架构/架构设计/Restful","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:15:39.555Z","comments":true,"path":"passages/软件开发/系统架构/架构设计/Restful/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/架构设计/Restful/","excerpt":"","text":"Java Web有很多成熟的框架，主要可以分为两类Web Application和Web Services。用于Web Application的框架包括官方的Servlet/JSP, JSTL/JSF以及第三方Struts/Spring MVC(action-based)。Web Services的项目又可以分为基于XML的（SOAP/WSDL）的和基于JSON的，Java Communitiy为这两种方式都定义了标准，Java EE5引入了JAX-WS(Java API for XML Web Services)-JSR224，Java EE6引入了JAX-RS(Java API for RESTful Web Services)-JSR331。RESTful Service由于轻量，好测试，有弹性等特点，越来越受欢迎。Jersey，RESTEasy都是JAX-RS标准的具体实现。 ####RESTful架构 Rest（representational state transfer, 表现层状态转化）是一种渐渐变成Web设计主流的设计理念，最早由Roy Thomas Fielding（HTTP1.0/1.1协议主要设计者之一，Apache作者之一，Apache基金会第一任主席）在2000年的博士论文中提出。 资源（Resource）：网络上一个实体（具体信息），每个资源都用一个URI来标识和定位。所有的资源都位于服务器中。 表现层（Representation）：资源的表现形式。例如文本信息可以用Txt展现，也可以用HTML，XML，JSON格式表现，甚至是二进制格式。URI只代表资源实体，它的表现形式在Http请求头中用Accept和Content-Type字段指定，这两个字段才是对表现层的描述。客户端见到的所有东西都只是服务器上资源的表现层，客户端和服务器之间传递的也都是表现层（资源请求携带的参数，返回的JSON，TXT，JPG等MIME-TYPE）。 状态转换（State Transfer）：客户端所有操作本质上就是用某种方法让服务器中的资源状态发生变化。客户端只能见到资源的表现层，所以服务器上资源状态的转换必然建立在表现层上。客户端让服务器资源发生状态变化的唯一方法就是使用HTTP请求，通过HTTP请求的不同方法（Method）实现对资源的不同的状态更改操作（如增删改查Create,Read,Update,Delete）。HTTP协议中设计的请求方法包括GET(获取)，POST(新增)，PUT(更新)，DELETE(删除)，HEAD，STATUS，OPTIONS等，不同方法代表了不同的操作，但是HTML只实现了GET和POST。 对url进行规范，写RESTful格式的url 非REST的url：http://…../queryItems.action?id=001&amp;type=T01 REST的url风格：http://…./items/001 特点：url简洁，将参数通过url传到服务端 http的方法规范 a)不管是删除，添加，更新….使用的url都是一致，那么如果需要删除，就把http的方法设置删除 b) 控制器：通过判断http的方法来执行操作（增删改查） 对http的contentType规范 请求时指定contentType，要json数据，设置成json格式的type。 ####JAX-RSJava API for RESTful Web Services，Roy Fielding也参与了JAX-RS的制订，他在自己的博士论文中定义了REST。对于那些想要构建RESTful Web Services的开发者来说，JAX-RS给出了不同于JAX-WS（JSR-224）的另一种解决方案。目前共有4种JAX-RS实现，所有这些实现都支持Spring，Jersey则是JAX-RS的参考实现，也是本文所用的实现 JAX-RS和所有JAVA EE的技术一样，只提供了技术标准，允许各个厂家有自己的实现版本，实现版本有：RESTEasy(JBoss), Jersey(Sun提供的参考实现), Apache CXF, Restlet(最早的REST框架，先于JAX-RS出现), Apache Wink。JAX-RS基于JavaEE的Servlet。标准中定义的注解大大简化资源位置和参数的描述，仅仅使用注解就可以将一个POJO java类封装成一个Web资源。JAX-RS也有类似于Spring依赖注入的方式，减少类之间的耦合度。 12345678910111213@Path(&quot;/greeter&quot;) public class GreeterResource &#123; @GET @Path(&quot;/&#123;name&#125;&quot;) public String sayHello(@PathParam(&quot;name&quot;) String name) &#123; return &quot;Hello, &quot; + name; &#125; @DELETE @Path(&quot;/&#123;name&#125;&quot;) public String sayBye(@PathParam(&quot;name&quot;) String name) &#123; return &quot;Bye, &quot; + name; &#125;&#125; 标注包括：@Path，标注资源类或方法的相对路径@GET，@PUT，@POST，@DELETE，标注方法是用的HTTP请求的类型@Produces，标注返回的MIME媒体类型@Consumes，标注可接受请求的MIME媒体类型@PathParam，@QueryParam，@HeaderParam，@CookieParam，@MatrixParam，@FormParam,分别标注方法的参数来自于HTTP请求的不同位置，例如@PathParam来自于URL的路径，@QueryParam来自于URL的查询参数，@HeaderParam来自于HTTP请求的头信息，@CookieParam提取Cookie值，不仅可以注入基本类型，还可以注入Cookie对象。也可以用@Context注入HttpHeaders对象获取所有Cookie信息。。@FormParam提取Post请求中的Form参数，其中Content-Type被假设为application/x-www-formurlencoded 参考：体系化认识RPC Richardson Maturity Model Spring MVC与JAX-RS比较与分析 - Spring MVC与JAX-RS比较与分析","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"架构设计","slug":"软件开发/系统架构/架构设计","permalink":"http://yoursite.com/categories/软件开发/系统架构/架构设计/"}],"tags":[]},{"title":"Self-Contains","slug":"软件开发/系统架构/架构设计/Self-Contains","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:15:43.050Z","comments":true,"path":"passages/软件开发/系统架构/架构设计/Self-Contains/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/架构设计/Self-Contains/","excerpt":"","text":"什么是自包含系统 自包含系统（SCS）与微服务有很多相似的特征。它们都可以独立部署，并以解耦系统为目的。不过，SCS一般具有更粗的粒度和更精确的定义。 每一个SCS都是一个自主的Web应用，包含了Web UI、业务逻辑和持久化层。对于SCS来说，API是一个可选项，而且SCS不应该共享UI，当然，那些调用了多个服务的单页应用（SPA）除外。 在进行领域驱动设计（DDD）时，为了尽可能降低SCS之间的耦合，每个SCS都应该实现一个边界上下文（Bounded Context）。可以通过对用户故事进行来定义边界上下文。 SCS之间可以通过多种方式进行交互：UI集成，如引用JavaScript文件、ESI或SSI；异步通信和事件；同步通信。 一个SCS只能由一个单独的团队进行开发。一个用户故事一般只能由一个团队来实现。SCS致力于将每一个变更都包含在单个SCS里，所以开发效率会很高，因为不需要做太多的协调工作。 SCS可以保证一个特性只会在一个SCS里实现，因此可以单独部署到生产环境。微服务支持独立部署，但如果大多数变更要求部署多个微服务，那么在微服务上的投入就没有多大意义。 如何将一个系统拆分成SCS在进行领域驱动设计（DDD）时，为了尽可能降低SCS之间的耦合，每个SCS应该实现一个边界上下文。每个系统不只拥有一个领域模型，事实上，一个系统可以包含多个不同的领域模型。每一个模型都有一个边界上下文。例如，在电子商务系统里搜索产品的当前价格时，产品的描述和数量是很重要的。而如果要向客户发货，则还需要其他的信息：产品的重量和客户的收货地址。将系统拆分成边界上下文是构建自包含系统最为有效的方式。 可以通过对用户故事进行分组来定义边界上下文。假设我们通过全文检索来搜索产品，那么通过分类和推荐来搜索也应该属于相同的边界上下文。当然，有时候拆分并不会有非常清楚的界线，这要取决于搜索的复杂性。 在将系统拆分成SCS时也需要考虑到用户体验。用户体验描述了客户与系统之间的交互步骤，比如搜索产品、结账或注册。每一个步骤都可能成为一个SCS。这些步骤之间一般只有很少的依赖。这些步骤之间有承上启下的关系：购物车在结账时就变成了一个订单，然后完成支付。 SCS不只处理某种特定的领域对象。例如，使用一个SCS来处理所有的客户数据就没有多大意义：很多不同的边界上下文都会用到客户数据。所以，为客户单独创建模型并在一个单独的SCS里实现是不可能的事情。如果真的这样子做了，那么每个需要用到客户数据的系统都会依赖它。这也就是为什么在将系统拆分成SCS时需要通过用户故事、边界上下文或用户体验来驱动，这种自上而下的方法会带来低耦合的系统。 虽然在后续有必要识别出公共部分，但这不应该成为关键点。公共逻辑可以被抽取到另一个系统里，但这意味着SCS会对这个系统产生依赖，它们之间就产生了耦合. SCS之间的交互SCS之间可以通过多种方式进行交互。 UI集成提供了很大的灵活性。对于SCS来说，最简单的事情莫过于渲染一个超链接。这个虽然简单，不过已经足以说明其灵活性。链接页面可以被更改，甚至用PDF文档替代HTML文档。不过，有时候一个Web页面由多个不同的SCS生成的元素组成。例如，一个登陆页面的不同部分可能展示来自多个SCS的信息。在这种情况下，使用超链接是不行的，必须使用包含片段的方式，比如包含HTML片段。 可以在浏览器里进行片段包含，通过JavaScript加载HTML片段。JavaScript代码库基本上都支持这种操作。不过片段包含也可以在后端进行。 Edge-Side Includes（ESI）就是一种标准，它通过HTTP缓存（如Varnish）和内容分发网络（CDN）来实现片段包含。ESI定义了一些HTML元素，从其他服务器加载的HTML会替换这些元素。Server-Side Includes（SSI）与ESI非常相似，不过它是通过Web服务器来实现的，如nginx或Apache httpd。所以，如果所有的请求都经过一个Web服务器，那么就可以使用SSI。 UI集成带来低耦合的系统：它们只渲染UI的一部分。所以不需要定义数据schema，而且它本身就具备弹性。如果使用JavaScript进行集成，当集成的系统不可用时，JavaScript就不会被执行。 接下来是异步交互。异步交互也能降低耦合：一般是通过事件来解耦。接收事件的系统可以决定如何处理事件，所以逻辑变更可能只发生在接收系统内。这种方式也具有弹性，如果一个系统不可用，到最后总是能够再恢复过来，然后继续处理消息。换句话说，这样只是会增加一些延迟，不过异步系统还是要尽量降低延迟。 最后一种交互方式是同步调用。虽然可以使用这种方式，但不建议这么做，因为这样容易导致耦合，而且为了避免因其他依赖系统的不可用造成的错误级联问题，需要做额外的处理工作。 这里有必要说明同步交互和异步交互的区别。同步交互是指SCS在处理一个请求时调用另外一个系统，并等待响应。异步交互是指在没有可处理的请求时发生交互，没有必要等待响应。 可以使用像REST这样的同步协议来实现异步交互。例如，在没有请求可处理时，使用REST进行数据复制，这也算是一种异步交互。也可以使用REST来发送事件，例如Atom - Wikipedia)就经常被用在博客系统里。订阅者也可以对特定的URL进行轮询，获取最新的博文。这种方式也可以用于查找其他事件，如新订单或其他类似的事件。除了REST，还有其他的消息解决方案，它们默认就提供了异步交互模型。 SCS与微服务自包含系统与微服务有很多相似的特征：它们都可以独立部署，并以解耦系统为目的。不过，SCS具有更精确的定义。微服务之间可以使用任何一种交互方式，它们可能不会提供UI，而且一个用户故事可以使用多个微服务来实现。SCS相对更为严格。 SCS取微服务之长，低耦合和独立部署让一个微服务的变更不会影响到其他微服务。所以，对微服务做出变更相对容易。SCS确保一个特性只在一个SCS里实现，因此可以单独部署到生产环境。微服务支持独立部署，但如果大多数变更要求部署多个微服务，那么在微服务上的投入就没有多大意义。 不过，SCS具有更粗的粒度。每个SCS都会实现一个由DDD定义的边界上下文。这样可以确保每个业务需求只在一个SCS里实现。不过，有时候SCS也可以包含细粒度的微服务。例如，假设订单处理的最后一个步骤需要进行大量的计算，那么计算逻辑就需要进行独立的伸缩。订单处理的其他步骤可以在一个SCS里实现，但最后一步可以在一个单独的微服务里实现，使用多个微服务实例来处理这些负载。 所以说，SCS最起码也算是一个微服务。作为一个Web应用，它可以独立部署。不过，出于伸缩性和安全方面的考虑，一个SCS可能包含多个微服务。 SCS的技术选型SCS可以使用不同的技术来实现。这也是微服务和SCS的优势之一，你可以选择最好的技术来解决问题。既然SCS是Web应用，那么就可以使用Web框架。这方面的技术已经为人们所熟知，它们都可以被用在SCS上。 不过，SCS不应该共享UI。当然，那些调用了多个服务的单页应用（SPA）除外。SPA非常流行，可以使用Angular来实现。不过，如果把一个SPA作为多个服务的前端，那么它就是一个被共享的UI。这种架构不符合SCS的定义。SPA的变更会涉及到后端的服务和SPA本身，不太可能出现添加一个特性只修改UI或者只修改后端服务的情况。 SCS可以与SPA组合在一起，每个SCS可以有它自己的SPA。不过，如果从一个SCS切换到另一个SCS，那么就需要使用新的SPA，这个过程不会很快，而且会造成不好的用户体验。不过SCS仍然可以通过JavaScript提供更好地用户体验，前提是JavaScript代码只能用于增强UI，不能用于UI共享。虽然SPA目前很流行，而且SCS有很多好处，但要将SPA与SCS组合在一起使用会比较困难。 SCS之间的交互可以通过REST来实现。如果使用了REST，那么底层就是基于HTTP的，不过HTTP本来就是一个Web应用所需要的。另一种交互方式是消息系统。如果使用了消息系统，就要保证高可用和伸缩性，因为消息系统的崩溃会导致整个系统不可用。 实现SCS面临的挑战每个SCS可以有自己的UI，所以要提供统一的外观。每个SCS有自己的Web接口，所以设计和外观上也有可能不一样。可以提供一个界面风格指南，用于定义UI元素。这不仅仅是指视觉设计，还包括用户体验和可用性。如果没有风格指南，在为复杂的系统创建UI时就会遇到困难，不管是开发一个单体还是开发一系列SCS。 风格指南里可以包含字体、图标、CSS，用于规范HTML，或者使用JavaScript实现更高级的UI元素。对于单体来说，这些文件与系统里其他代码一样，已经被集成在一起了。不过，SCS有自己的UI，所以每一个SCS都需要能够访问到这些文件。最简单的做法是将这些文件放在专门的服务器上，或者使用文件管道，然后在项目里包含这个管道，就像包含其他代码依赖一样。这是唯一一个违反SCS不共享代码原则的地方，但这个代价是不可避免的。 虽说SCS的外观要尽量保持统一，但在对外观做出更改之后，不要将变更推送给SCS，而是让每个SCS尽快拉取最新的版本，并确保每个SCS都通过了测试。所以，风格文件要进行版本管理，有时候需要同时使用新旧版本的文件。 UI层面的集成看起来很简单，不过也存在一些限制。例如，可能无法在同一个应用的不同页面上运行相同的JavaScript代码，因为不同页面可能使用了不同版本的JavaScript代码库。所以在理想情况下，不应该在SCS之间共享JavaScript代码。同时还要注意，从外部包含进来的HTML代码片段不要破坏了整个页面的布局。 虽然UI集成看似乎简单，不过还是要注意一些与界面有关的事项。实现SCS需要一定的前端开发技能。我们借助UI技术来解决SCS的架构问题，这反过来要求团队具备混合技能（跨功能的）。 开发效率和系统复杂性微服务架构通常会带来额外的复杂性，因为有很多系统需要部署和运维。SCS也是微服务，所以也会有复杂性方面的问题。不过，因为SCS是粗粒度的，所以需要部署的服务不会太多。 实际上，SCS与Web应用使用的是相同的基础设施。所以，基础设施的复杂性不会很高，如果你知道怎么运行一个Web应用，就也能运行一个SCS，只是数量比以前要多一些。这是SCS的另一个优势，对高级技术的要求没有那么高。不过，SCS仍然具备了微服务的很多优势。与REST或消息系统的集成不是必需的，可以只通过超链接来完成集成，这点看起来很有意思。 SCS致力于将每个变更都包含在单个SCS里，所以开发效率会比较高，因为只需要改动和部署一个单独的SCS。因此，SCS的技术复杂度相对较低。它们就是普通的Web应用，对我们来说再熟悉不过了。不过，它们还提供了其他很多好处。 什么时候使用SCS很显然，SCS只适用于Web系统。不过，对于其他一些系统，虽然它们没有非常清晰的隔离边界，但每个系统都有自己的边界上下文、数据库和逻辑，那么也可以使用SCS。对于没有持久化需求并且只包含了少量逻辑的portal来说，也可以使用SCS，比如UI集成。 SCS不应该依赖DDD的边界上下文，而且如果当前架构依赖了其他不同的技术，那么就很难迁移到SCS。迁移是一个非常重要的因素，如果一个架构无法进行迁移，那么它就一文不值。最后，我们必须再次强调，SCS要求对Web应用有很好的理解。虽说Web应用已经很普遍，但随着SPA的崛起，一些有关SPA的基本概念并没有被很好地理解。 从我们的经验来看，SCS解决了很多复杂的Web应用问题，在进行系统架构时，可以从它入手。现在有很多项目在使用SCS，比如Otto——世界上最大的电商公司之一。 结论自包含系统是一种架构模式，它的想法源自微服务，并将这些想法与传统的Web应用开发结合在一起，用于开发一系列低耦合的系统。因为SCS本质上就是Web应用，所以大多数开发人员对它的基本概念都很熟悉。SCS为Web应用提供了久经考验的架构模式，同时也给其他类型的应用带来了灵感。 参考： 自包含系统：打开微服务的正确方式","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"架构设计","slug":"软件开发/系统架构/架构设计","permalink":"http://yoursite.com/categories/软件开发/系统架构/架构设计/"}],"tags":[]},{"title":"重构","slug":"软件开发/系统架构/架构设计/重构","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:15:50.065Z","comments":true,"path":"passages/软件开发/系统架构/架构设计/重构/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/架构设计/重构/","excerpt":"","text":"重构技巧 — 函数重构 重命名函数（Rename Function Name） : Clean Code 要求定义的变量和函数名可读性要强，从名字就可以知道这个变量和函数去做什么事情，所以好的可读性强的函数名称很重要，特别是有助于理解比较复杂的业务逻辑。 移除参数（Remove Parameter）: 当函数不再需要某个参数时，要果断移除，不要为了某个未知需求预留参数，过多的参数会给使用者带来参数困扰。 将查询函数和修改函数分离：如果某个函数既返回对象值，又修改对象状态。这时候应该建立两个不同的函数，其中一个负责查询，另一个负责修改。如果查询函数只是简单的返回一个值而没有副作用，就可以无限次的调用查询函数。对于复杂的计算也可以缓存结果。 令函数携带参数：如果若干函数做了类似的工作，只是少数几个值不同导致行为略有不同，合并这些函数，以参数来表达不同的值。 以明确函数取代参数：有一个函数其中的逻辑完全取决于参数值而采取不同行为，针对该参数的每一个可能值建立一个单独的函数。 保持对象完整性：如果你需要从某个对象取若干值，作为函数的多个参数传进去，特别是需要传入较多参数比如 5 个参数或者更多参数时，这种情况建议直接将这个对象直接传入作为函数参数，这样既可以减少参数的个数，增加了对象间的信赖性，而且这样被调用者需要这个对象的其他属性时可以不用人为的再去修改函数参数。 以函数取代参数：对象调用某个函数，并将所得结果作为参数传递给另外一个函数，而那个函数本身也能够调用前一个函数，直接让那个函数调用就行，可以直接去除那个参数，从而减少参数个数。 引入参数对象：某些参数总是同时出现，新建一个对象取代这些参数，不但可以减少参数个数，而且也许还有一些参数可以迁移到新建的参数类中，增加类的参数扩展性。 移除设值函数（Setting Method）：如果类中的某个字段应该在对象创建时赋值，此后就不再改变，这种情景下就不需要添加 Setting method。 隐藏函数：如果有一个函数从来没有被其他类有用到，或者是本来被用到，但随着类动态添加接口或者需求变更，之后就使用不到了，那么需要隐藏这个函数，也就是减小作用域。 以工厂函数取代构造函数：如果你希望创建对象时候不仅仅做简单的构建动作，最显而易见的动机就是派生子类时根据类型码创建不同的子类，或者控制类的实例个数。重构技巧 — 条件表达式 分解条件表达式：如果有一个复杂的条件语句，if/else 语句的段落逻辑提取成一个函数。 合并条件表达式：一系列条件测试，都得到相同的测试结果，可以将这些测试表达式合并成成一个，并将合并后的表达式提炼成一个独立函数，如果这些条件测试是相互独立不相关的，就不要合并。 合并重复的条件片段：在条件表达式的每个分支上有着相同的一段代码，把这段代码迁移到表达式之外。 移除控制标记：不必遵循单一出口的原则，不用通过控制标记来决定是否退出循环或者跳过函数剩下的操作，直接 break 或者 return。 以卫语句替代嵌套条件表达式：条件表达式通常有两种表现形式，一：所有分支都属于正常行为；二：只有一种是正常行为，其他都是不常见的情况。对于一的情况，应该使用 if/else 条件表达式；对于二这种情况，如果某个条件不常见，应该单独检查条件并在该条件为真时立即从函数返回，这样的单独检查常常被称为卫语句。 以多态取代条件表达式：如果有个条件表达式根据对象类型的不同选择而选择不同的行为，将条件表达式的每个分支放进一个子类内的覆写函数中，将原始函数声明为抽象函数。 引入 Null 对象：当执行一些操作时，需要再三检查某对象是否为 NULL，可以专门新建一个 NULL 对象，让相应函数执行原来检查条件为 NULL 时要执行的动作，除 NULL 对象外，对特殊情况还可以有 Special 对象，这类对象一般是 Singleton. 引入断言：程序状态的一种假设 以 MAP 取代条件表达式：通过 HashMap 的 Key-Value 键值对优化条件表达式，条件表达式的判断条件作为 key 值，value 值存储条件表达式的返回值。 通过反射取代条件表达式：通过动态反射原理","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"架构设计","slug":"软件开发/系统架构/架构设计","permalink":"http://yoursite.com/categories/软件开发/系统架构/架构设计/"}],"tags":[]},{"title":"设计模式","slug":"软件开发/系统架构/架构设计/设计模式","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:15:45.689Z","comments":true,"path":"passages/软件开发/系统架构/架构设计/设计模式/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/架构设计/设计模式/","excerpt":"","text":"设计模式设计模式的分类五种创建者模式 ： 单例模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式七种结构型模式 ： 适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式十一种行为模式 ： 策略模式，模板方法模式，观察者模式，迭代子模式，责任链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式并发型模式 ： Future模式,Master_worker模式,Guarded Suspension模式,不变模式,生产者消费者模式 线程池模式 : HS/HA半同步/半异步模式，L/F领导者跟随者模式 设计模式七大原则 单一职责原则【SINGLE RESPONSIBILITY PRINCIPLE】：一个类负责一项职责. 里氏替换原则【LISKOV SUBSTITUTION PRINCIPLE】：继承与派生的规则. 依赖倒置原则【DEPENDENCE INVERSION PRINCIPLE】：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程. 接口隔离原则【INTERFACE SEGREGATION PRINCIPLE】：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少. 迪米特法则【LOW OF DEMETER】：低耦合，高内聚. 开闭原则【OPEN CLOSE PRINCIPLE】：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭. 组合/聚合复用原则【Composition/Aggregation Reuse Principle(CARP) 】：尽量使用组合和聚合少使用继承的关系来达到复用的原则. 23种设计模式五种创建者模式 单例模式(Singleton pattern)： JVM中只创建一个实例存在，反复使用,严格单例需要控制线程安全，反序列化创建对象 工厂方法模式 普通工厂模式(factory method pattern)： 建立一个工厂类，对实现同一接口的类进行实例创建，多个实例共用一个工厂方法 多个工厂方法模式(Abstract factory pattern) ： 提供一个接口, 用于创建相关或依赖对象的家族, 而不需要指定具体类，对普通工厂改进，每一类实例的创建对应一个工厂方法 静态工厂方法模式 ： 对多个工厂方法模式改进，将方法设置为静态的，不再需要创建工厂实例 抽象工厂模式 ： 抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，只需增加新的工厂类，不需要修改原有代码 建造者模式(Builder pattern)： 封装一个产品的构造过程, 并允许按步骤构造. 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示, 建造者是创建复合对象，工厂模式创建单个产品 原型模式(prototype pattern)： 对一个已有对象的复制产生一个和原对象类似的新对象，通过clone, 当创建给定类的实例过程很昂贵或很复杂时, 就使用原形模式.浅复制 ： 基本数据类型的变量会被重新创建，引用类型还是指向原对象 (Object.clone就是浅拷贝)深复制 ： 基本数据类型和引用类型被重新创建 (写入读出二进制流产生新对象) 多例模式(Multition pattern): 在一个解决方案中结合两个或多个模式, 以解决一般或重复发生的问题. 七种结构型模式 适配器模式(Adapter pattern)将一个类的接口, 转换成客户期望的另一个接口. 适配器让原本接口不兼容的类可以合作无间. 对象适配器使用组合, 类适配器使用多重继承类的适配器模式 ： 接口Targetable拥有和A相同的方法，并有新的适配方法，类Adapter继承A实现Targetable对象的适配器模式 ： 和类适配器不同的是，持有A的实例而不是继承A接口的适配器模式 ： 解决有时候并不想实现接口中的所有的方法，让抽象类B实现接口C，其他的实现类只需要继承B 装饰器模式(decorator pattern)：动态地将责任附加到对象上, 若要扩展功能, 装饰者提供了比继承更有弹性的替代方案， 给一个对象动态增加新的功能，装饰对象B实现被装饰对象A相同的接口，并且B持有A的实例，用户更关注被装饰后的功能 代理模式(Proxy pattern)： 类Proxy实现被代理的类A相同的接口，并持有A的实例，实现类似装饰器模式，但用户更关注被代理的对象功能 (可参考JDK proxy) 外观模式(facade pattern)： 提供了一个统一的接口, 用来访问子系统中的一群接口. 外观定义了一个高层接口, 让子系统更容易使用, 解决类与类之间的依赖关系，将其他的类组合在一起 桥接模式(Bridge pattern)： 使用桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变，把事物和具体实现分开，使得二者可以独立变化 (参考JDBC的不同数据库驱动加载) 组合模式(composite pattern)：允许你将对象组合成树形结构来表现”整体/部分”层次结构. 组合能让客户以一致的方式处理个别对象以及对象组合， 多个对象组合在一起进行操作,整体和个体的设计(参考二叉树，目录) 享元模式(Flyweight Pattern)： 如想让某个类的一个实例能用来提供许多”虚拟实例”， 实现对象的共享(参考数据库连接池的实现，commons-pool开源实现) 十一种行为模式 父类和子类策略模式(strategy pattern): 多个子类实现同一个接口，用户按自己的选择选用不同的实现，如排序接口，具体实现快排，堆排等模板方法模式(Template pattern)： 抽象类定义主方法，子类继承抽象类，选择实现父类的方法，通过调用父类实现对子类的调用 两个类之间观察者模式(observer pattern): 在对象之间定义一对多的依赖, 这样一来, 当一个对象改变状态, 依赖它的对象都会收到通知, 并自动更新, 观察者先订阅，被观察者变化时通知列表内的观察者迭代子模式(iterator pattern): 用于遍历聚集中的对象，如集合,Iterator持有遍历对象实例，对其进行顺序访问责任链模式(Chain of responsibility pattern): 通过责任链模式, 你可以为某个请求创建一个对象链. 每个对象依序检查此请求并对其进行处理或者将它传给链中的下一个对象, 一个实例对象调用自己的实例去处理一个任务，然后递归，始终会有一个对象去处理这个任务，这个查找链不限于链表和树等命令模式(Command pattern)： 将”请求”封闭成对象, 以便使用不同的请求,队列或者日志来参数化其他对象. 命令模式也支持可撤销的操作, 实现和请求分开，如controller和service层的分离 类的状态备忘录模式(Memento pattern): 当你需要让对象返回之前的状态时(例如, 你的用户请求”撤销”), 你使用备忘录模式，原始类A创建备忘类B保存在C中，B保存A的属性，C只能新增不能修改状态模式(State pattern)：允许对象在内部状态改变时改变它的行为, 对象看起来好象改了它的类, 类A有不同状态Status，不同的状态同一方法对应不同的行为 通过中间类访问者模式(visitor pattern)： 分离对象数据结构和行为的方法，解决为现有类A新增功能，不能修改A的代码的情况,缺点是不适用数据结构易于变化的场景中介者模式(Mediator pattern)： 为降低类的耦合性，只需保持其它类和中间类的关系，不需要类之间相互持有实例对象解释器模式(Interpreter pattern)： 类似编译器，正则表达式实现，使用场景受限 并发型模式123456789101. 主动对象模式 Active Object : 自带处理线程，其他请求进入缓冲区等待异步执行，调用和执行分离2. 阻碍模式 Balking Pattern : 设置一个共享变量，当线程进入一个方法，判断该值是否为真，如果为真说明已经在执行了，返回结束，否则设为真并执行3. 双重检查锁定 Double Checked Locking ： 参考单例模式实例的初始化双检查4. 守卫模式 Guarded ： 判断共享变量是否为真，当为假wait,等待条件为真时notify5. 领导者/追随者模式 Leaders/Followers : 每个线程共享一个事件源，并在三个状态切换leader、follower和processor;leader接受事件，状态变成processor，选举一个新的leader，事件处理完状态变成follower；不需要线程的上下文切换6. 监测对象模式 Monitor object : 互斥执行和协作。使用ｓｙｎｃｈｒｏｎｉｚｅｄ和wait/notify/notifyAll7. 读写锁 Read-write lock ： 读写锁分离，增加吞吐量 8. 调度模式 Scheduler ： 定期处理(Timer)9. 线程池模式 Thread pool ： 线程被当作资源管理分配10. 线程特定存储 Thread-specific storage : 将变量保存在ＴｈｒｅａｄLocal中，避免重复创建或从其他地方获取 Java 3种并发实现1231. Thread : 直接使用Thread/Runnable/Future2. Executors和Services ： 线程池技术来控制应用程序的并发，线程数通常和业务相关于cpu不相关，需要上下文切换实现并发，任务从开始到结束时间是不稳定的，执行过程中需要抢占cpu3. ForkJoin框架和并行流 ： cpu数来控制并行，并发数量不会大于cpu的并发数 Java并发策略123451. Future模式: 提高响应速度2. Master_worker模式: 子任务分配，提高响应速度 3. Guarded Suspension模式 : 队列缓冲，非立即处理，避免因为请求太多而崩溃4. 不变模式: 类似String/Double...不需要同步，线程安全5. 生产者消费者模式 : 缓解两者间的性能差 Spring中的设计模式 简单工厂 又叫做静态工厂方法（StaticFactory Method）模式，但不属于23种GOF设计模式之一。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。 工厂方法（Factory Method） 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。Spring中的FactoryBean就是典型的工厂方法模式。如下图： 单例（Singleton） 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 Spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为Spring管理的是是任意的Java对象。 适配器（Adapter） 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。Spring中在对于AOP的处理中有Adapter模式的例子，见如下图： 由于Advisor链需要的是MethodInterceptor（拦截器）对象，所以每一个Advisor中的Advice都要适配成对应的MethodInterceptor对象。 5.包装器（Decorator） 动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。基本上都是动态地给一个对象添加一些额外的职责。 代理（Proxy） 为其他对象提供一种代理以控制对这个对象的访问。从结构上来看和Decorator模式类似，但Proxy是控制，更像是一种对功能的限制，而Decorator是增加职责。 Spring的Proxy模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。 7.观察者（Observer） 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 Spring中Observer模式常用的地方是listener的实现。如ApplicationListener。 策略（Strategy） 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。Spring中在实例化对象的时候用到Strategy模式，见如下图： 9.模板方法（Template Method） 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。Spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"架构设计","slug":"软件开发/系统架构/架构设计","permalink":"http://yoursite.com/categories/软件开发/系统架构/架构设计/"}],"tags":[]},{"title":"Docker","slug":"软件开发/系统架构/虚拟机容器/docker","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:16:04.833Z","comments":true,"path":"passages/软件开发/系统架构/虚拟机容器/docker/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/虚拟机容器/docker/","excerpt":"","text":"Docker基础Ubuntu Docker 安装http://www.docker.org.cn/book/install/install-docker-under-ubuntu-precise-20.html curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/intranet | sh 内核要求：由于LXC的一个bug，Docker在3.8内核下面运行最佳。Ubuntu的Precise版本内置的是3.2版本的内核，因此我们首先需要升级内核。安装下面的步骤可以升级到3.8内核，并内置AUFS的支持。同时还包括了通用头文件，这样我们就可以激活依赖于这些头文件的包，比如ZFS，VirtualBox的增强功能包。 123456# install the backported kernelsudo apt-get updatesudo apt-get install linux-image-generic-lts-raring linux-headers-generic-lts-raring# rebootsudo reboot 使用Docker可以下载ubuntu镜像并启动一个镜像来验证安装是否正常。 sudo docker run -i -t ubuntu /bin/bash 成功运行之后，输入exit退出即可。 下载镜像docker search 使用docker pull imagename（镜像名）来下载镜像 下载完成后使用以下命令查看本地所有的镜像： docker images 创建 image 文件有了 Dockerfile 文件以后，就可以使用docker image build命令创建 image 文件了。 123$ docker image build -t koa-demo .# 或者$ docker image build -t koa-demo:0.0.1 . 上面代码中，-t参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是latest。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。 如果运行成功，就可以看到新生成的 image 文件koa-demo了。 1$ docker image ls 生成容器docker container run命令会从 image 文件生成容器。 123$ docker container run -p 8000:3000 -it koa-demo /bin/bash# 或者$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash 上面命令的各个参数含义如下：1234-p参数：容器的 3000 端口映射到本机的 8000 端口。-it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。/bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。 如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。 1root@66d80f4aaf1e:/app# 这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。 1root@66d80f4aaf1e:/app# node demos/01.js RUN命令与CMD命令的区别在哪里？简单说，RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个RUN命令，但是只能有一个CMD命令。 启动容器容器是在镜像的基础上来运行的，一旦容器启动了，我们就可以登录到容器中，安装自己所需的软件或应用程序。 使用进入已经运行的dockerdocker attach dabfb413d8cf[容器ID] 使用以下命令即可启动容器：docker run -i -t -v /root/software/:/mnt/software/ –privileged=true 2a392a47afc5docker run &lt;相关参数&gt; &lt;镜像 ID&gt; &lt;初始命令&gt; 其中相关参数包括：-i：表示以交互模式运行容器-t：表示容器启动后会进入其命令行-v：表示需要将本地哪个目录挂载到容器中，格式-v&lt;宿主机目录&gt;：&lt;容器目录&gt; 假设我们的所有安装程序都放在了宿主机的/root/software/目录下，现在需要将其挂载到容器的/mnt/software/目录下。这一切做好后你就可以为这个容器安装软件了。 Docker 传送文件命令docker cp more.log e7de404c00bd:/tmp/ 提交Docker镜像docker pull python 启动python镜像容器docker run -t -i python:3.5 /bin/bash 安装对应库 1234$ pip install pandas $ pip install lxml $ pip install bs4$ pip install tushare 退出你刚才配置好的docker镜像exit 使用以下命令可以看到刚才退出的docker镜像docker ps -a 用以下命令，根据某个”容器ID”来创建一个新的”镜像”： docker commit -m=”Add pandas/lxml/bs4/tushare” -a=”oliver” 165364af3418 oliver/python:3.5a 各个参数说明： -m:提交的描述信息 -a:指定镜像作者 165364af3418 oliver/python:3.5a:指定要创建的目标镜像名 该容器ID是”57c312bbaad1”，所创建的镜像名是”javaweb”注意：”57c312bbaad1” 这个ID是使用 docker ps 命令来查看的提交了新的镜像可以把这个镜像储存tar包docker save -o ~/python.tar oliver/pythondocker save -o 保存的目录 镜像名 发布 image 文件容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。 首先，去 hub.docker.com 或 cloud.docker.com 注册一个账户。然后，用下面的命令登录。 1$ docker login 接着，为本地的 image 标注用户名和版本。 123$ docker image tag [imageName] [username]/[repository]:[tag]# 实例$ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1 也可以不标注用户名，重新构建一下 image 文件。 1$ docker image build -t [username]/[repository]:[tag] . 最后，发布 image 文件。 1$ docker image push [username]/[repository]:[tag] 发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。 编写Dockerfile我使用了Dockerfile来描述开发环境，下面是我写的一个只安装Eclipse的Dockerfile，诸如mysql，jdk什么的比较简单就不再写进来了。 vi Dockerfile1234567891011121314151617181920212223242526RUN echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiverse&quot; &gt; /etc/apt/sources.listRUN echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-security main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-updates main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-backports main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN echo &quot;deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ trusty-proposed main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.listRUN apt-get update &amp;&amp; apt-get install -y libgtk2.0-0 libcanberra-gtk-moduleRUN apt-get install -y eclipse# Replace 1000 with your user / group idRUN export uid=1000 gid=1000 &amp;&amp; \\ mkdir -p /home/developer &amp;&amp; \\ echo &quot;developer:x:$&#123;uid&#125;:$&#123;gid&#125;:Developer,,,:/home/developer:/bin/bash&quot; &gt;&gt; /etc/passwd &amp;&amp; \\ echo &quot;developer:x:$&#123;uid&#125;:&quot; &gt;&gt; /etc/group &amp;&amp; \\ echo &quot;developer ALL=(ALL) NOPASSWD: ALL&quot; &gt; /etc/sudoers.d/developer &amp;&amp; \\ chmod 0440 /etc/sudoers.d/developer &amp;&amp; \\ chown $&#123;uid&#125;:$&#123;gid&#125; -R /home/developerUSER developerENV HOME /home/developerCMD /usr/bin/eclipse Docker Builddocker build -t eclipse . 有error1234567891011121314151617error pulling image configuration: Get https://dseasb33srnrn.cloudfront.net/registry-v2/docker/registry/v2/blobs/sha256/e4/e4422b8da209755dd5a8aa201ba79cef0c465003f46f6313f318a0e306e4fe05/data?Expires=1525925417&amp;Signature=VMqDbVQri5CAHgh9WfKsiOgbuEAKi6VpZUjFdjgrA0Q8~XTyXdLYeRDwznGSfPdaMCkcPdRg32r-tdBLJ9~hPXb8QcaAAw0OXCZi86X8xXbv8Bjdjrl4whMB~ooIE0Sd6fXiQBRnlsB8lO5MhTg0lkkb7IPes9XU31-RiovOFrM_&amp;Key-Pair-Id=APKAJECH5M7VWIS5YZ6Q: net/http: TLS handshake timeout出现这个问题原因为国内网络问题，无法连接到 docker hub。 好在国内已经有 daocloud，docker指定该源即可。1. systemctl stop docker2. sudo vi /etc/docker/daemon.json3. add &#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]&#125;4. service docker restartservice docker start如果service命令启动不了用下面的systemctl start docker.service Run Docker123456789101112131415161718192021docker run -ti --rm \\ -e DISPLAY=$DISPLAY \\ -v /tmp/.X11-unix:/tmp/.X11-unix \\ psharkey/eclipsemkdir -p .eclipse-dockerdocker run -ti --rm \\ -e DISPLAY=$DISPLAY \\ -v /tmp/.X11-unix:/tmp/.X11-unix \\ -v `pwd`/.eclipse-docker:/home/developer \\ -v `pwd`:/workspace \\ fgrehm/eclipse:v4.4.1run: 运行docker--ti: 伪终端交互模式--rm: 运行后删除Container--name: 运行的容器的名称--v: 将主机的目录和容器的目录做镜像，这样容器在这个目录操作的内容就自动同步保存到主机上--e: 环境变量设置iwakoshi/eclipse：镜像的名字，docker pull下来的--device：可选参数，设备和主机共享 关闭容器docker stop containerId 使用 Docker 搭建开发环境Docker 安装 Python12docker search pythondocker pull python:3.5 使用python镜像运行容器docker run -v $PWD/myapp:/usr/src/myapp -w /usr/src/myapp python:3.5 python helloworld.py docker run -v $PWD:/usr/src/myapp -w /usr/src/myapp oliver/python:3.5a python test.py命令说明：-v $PWD/myapp:/usr/src/myapp :将主机中当前目录下的myapp挂载到容器的/usr/src/myapp-w /usr/src/myapp :指定容器的/usr/src/myapp目录为工作目录python helloworld.py :使用容器的python命令来执行工作目录中的helloworld.py文件 Docker 安装 mongodocker search mongodocker pull mongo:3.6 使用mongo镜像 运行容器docker run -p 27017:27017 -v $PWD/db:/data/db -d mongo:3.6 命令说明： -p 27017:27017 :将容器的27017 端口映射到主机的27017 端口-v $PWD/db:/data/db :将主机中当前目录下的db挂载到容器的/data/db，作为mongo数据存储目录 查看容器启动情况 docker ps docker stopdocker kill 使用mongo镜像执行mongo 命令连接到刚启动的容器,主机IP为172.17.0.1 docker run -it mongo:3.6 mongo –host 172.17.0.1","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"虚拟机容器","slug":"软件开发/系统架构/虚拟机容器","permalink":"http://yoursite.com/categories/软件开发/系统架构/虚拟机容器/"}],"tags":[]},{"title":"Kafka","slug":"软件开发/系统架构/消息中间件/kafka","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:15:55.196Z","comments":true,"path":"passages/软件开发/系统架构/消息中间件/kafka/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/消息中间件/kafka/","excerpt":"","text":"KafkaKafka 是一种分布式的，基于发布 / 订阅的消息系统。主要设计目标如下： 以时间复杂度为 O(1) 的方式提供消息持久化能力，即使对 TB 级以上数据也能保证常数时间复杂度的访问性能。 高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒 100K 条以上消息的传输。 支持 Kafka Server 间的消息分区，及分布式消费，同时保证每个 Partition 内的消息顺序传输。 同时支持离线数据处理和实时数据处理。 Scale out：支持在线水平扩展。 Kafka is a distributed, partitioned, replicated commit log service. ” 它提供了一个非常特殊的消息机制，不同于传统的mq 常见的实践场景是： 复杂系统的解耦 复杂链路的异步调用 瞬时高峰的削峰处理 引入中间件的问题： 系统可用性降低：因为引入了中间件就相当于引入了新的风险 系统稳定性降低： 消息高可靠传递（0丢失）， 消息幂等性传递（绝对不重复）， 百万消息积压的线上故障处理 分布式一致性问题： 需要使用可靠消息最终一致性的分布式事务方案来保障 Q: 线上服务宕机时，如何保证数据100%不丢失？ A: 关闭AutoAck,在finally中手工Ack Q: 消息中间件集群崩溃，如何保证百万生产数据不丢失？ A: 消息持久化 与传统的mq区别 更快！单机上万TPS 传统的MQ，消息被消化掉后会被mq删除，而kafka中消息被消化后不会被删除，而是到配置的expire时间后，才删除 传统的MQ，消息的Offset是由MQ维护，而kafka中消息的Offset是由客户端自己维护 分布式，把写入压力均摊到各个节点。可以通过增加节点降低压力 kafka基本原理通常来讲，消息模型可以分为两种：队列和发布-订阅式。队列的处理方式是一组消费者从服务器读取消息，一条消息只有其中的一个消费者来处理。在发布-订阅模型中，消息被广播给所有的消费者，接收到消息的消费者都可以处理此消息。Kafka为这两种模型提供了单一的消费者抽象模型： 消费者组(consumer group)。消费者用一个消费者组名标记自己。 一个发布在Topic上消息被分发给此消费者组中的一个消费者。假如所有的消费者都在一个组中，那么这就变成了queue模型。假如所有的消费者都在不同的组中，那么就完全变成了发布-订阅模型。更通用的， 我们可以创建一些消费者组作为逻辑上的订阅者。每个组包含数目不等的消费者，一个组内多个消费者可以用来扩展性能和容错。 并且，kafka能够保证生产者发送到一个特定的Topic的分区上，消息将会按照它们发送的顺序依次加入，也就是说，如果一个消息M1和M2使用相同的producer发送，M1先发送，那么M1将比M2的offset低，并且优先的出现在日志中。消费者收到的消息也是此顺序。如果一个Topic配置了复制因子（replication facto）为N,那么可以允许N-1服务器宕机而不丢失任何已经提交（committed）的消息。此特性说明kafka有比传统的消息系统更强的顺序保证。但是，相同的消费者组中不能有比分区更多的消费者，否则多出的消费者一直处于空等待，不会收到消息。 主题和日志 (Topic和Log)每一个分区(partition)都是一个顺序的、不可变的消息队列,并且可以持续的添加。分区中的消息都被分了一个序列号,称之为偏移量(offset),在每个分区中此偏移量都是唯一的。Kafka集群保持所有的消息,直到它们过期,无论消息是否被消费了。实际上消费者所持有的仅有的元数据就是这个偏移量，也就是消费者在这个log中的位置。 这个偏移量由消费者控制：正常情况当消费者消费消息的时候，偏移量也线性的的增加。但是实际偏移量由消费者控制，消费者可以将偏移量重置为更老的一个偏移量，重新读取消息。 可以看到这种设计对消费者来说操作自如， 一个消费者的操作不会影响其它消费者对此log的处理。 再说说分区。Kafka中采用分区的设计有几个目的。一是可以处理更多的消息，不受单台服务器的限制。Topic拥有多个分区意味着它可以不受限的处理更多的数据。第二，分区可以作为并行处理的单元，稍后会谈到这一点。 分布式(Distribution)Log的分区被分布到集群中的多个服务器上。每个服务器处理它分到的分区。根据配置每个分区还可以复制到其它服务器作为备份容错。 每个分区有一个leader，零或多个follower。Leader处理此分区的所有的读写请求，而follower被动的复制数据。如果leader宕机，其它的一个follower会被推举为新的leader。 一台服务器可能同时是一个分区的leader，另一个分区的follower。 这样可以平衡负载，避免所有的请求都只让一台或者某几台服务器处理。 基本术语Producer/Consumer这两个与传统的MQ一样 Broker集群中的KafkaServer，用来提供Partition服务 TopicKafka中的topic其实对应传统MQ的channel，即消息管道，例如同一业务用同一根管道。Topic 在逻辑上可以被认为是一个 queue，每条消费都必须指定它的 Topic，可以简单理解为必须指明把这条消息放进哪个 queue 里。为了使得 Kafka 的吞吐率可以线性提高，物理上把 Topic 分成一个或多个 Partition，每个 Partition 在物理上对应一个文件夹，该文件夹下存储这个 Partition 的所有消息和索引文件 Offset单个Partition中的消息的顺序ID，例如第一个进入的Offset为0，第二个为1，以此类推。传统的MQ，Offset是由MQ自己维护，而kafka是由client维护 Producer 消息路由Kafka会统计replica与leader的同步情况。当一个replica与leader数据相差不大，会被认为是一个”in-sync” replica。只有”in-sync” replica才有资格参与重新选举。 Producer 发送消息到 broker 时，会根据 Paritition 机制选择将其存储到哪一个 Partition。如果 Partition 机制设置合理，所有消息可以均匀分布到不同的 Partition 里，这样就实现了负载均衡。如果一个 Topic 对应一个文件，那这个文件所在的机器 I/O 将会成为这个 Topic 的性能瓶颈，而有了 Partition 后，不同的消息可以并行写入不同 broker 的不同 Partition 里，极大的提高了吞吐率。可以在 $KAFKA_HOME/config/server.properties 中通过配置项 num.partitions 来指定新建 Topic 的默认 Partition 数量 在发送一条消息时，可以指定这条消息的 key，Producer 根据这个 key 和 Partition 机制来判断应该将这条消息发送到哪个 Parition ConsumerGroup一个或多个Consumer构成一个ConsumerGroup，一个消息应该只能被同一个ConsumerGroup中的一个Consumer消化掉，但是可以同时发送到不同ConsumerGroup。 通常的做法，一个Consumer去对应一个Partition。 传统MQ中有queuing（消息）和publish-subscribe（订阅）模式，Kafka中也支持： 当所有Consumer具有相同的ConsumerGroup时，该ConsumerGroup中只有一个Consumer能收到消息，就是 queuing 模式当所有Consumer具有不同的ConsumerGroup时，每个ConsumerGroup会收到相同的消息，就是 publish-subscribe 模式 controller kafka 集群中的其中一个服务器，用来进行 leader election 以及 各种 failover。 zookeeper kafka 通过 zookeeper 来存储集群的 meta 信息。 Message Delivery Semantics 有这么几种可能的 delivery guarantee： At least one 消息可能会丢，但绝不会重复传输。如果producer收到来自Kafka broker的确认（ack）或者acks = all，则表示该消息已经写入到Kafka。但如果producer ack超时或收到错误，则可能会重试发送消息，客户端会认为该消息未写入Kafka。如果broker在发送Ack之前失败，但在消息成功写入Kafka之后，此重试将导致该消息被写入两次，因此消息会被不止一次地传递给最终consumer，这种策略可能导致重复的工作和不正确的结果。 At most once 消息绝不会丢，但可能会重复传输。如果在ack超时或返回错误时producer不重试，则该消息可能最终不会写入Kafka，因此不会传递给consumer。在大多数情况下，这样做是为了避免重复的可能性，业务上必须接收数据传递可能的丢失。 Exactly once 每条消息肯定会被传输一次且仅传输一次，很多时候这是用户所想要的。即使producer重试发送消息，消息也会保证最多一次地传递给最终consumer。该语义是最理想的，但也难以实现，这是因为它需要消息系统本身与生产和消费消息的应用程序进行协作。例如如果在消费消息成功后，将Kafka consumer的偏移量rollback，我们将会再次从该偏移量开始接收消息。这表明消息传递系统和客户端应用程序必须配合调整才能实现excactly-once。 ACK 前需要保证有多少个备份Broker 存活包含两个条件，一是它必须维护与 ZooKeeper 的 session（这个通过 ZooKeeper 的 Heartbeat 机制来实现）。二是 Follower 必须能够及时将 Leader 的消息复制过来，不能“落后太多” Leader 会跟踪与其保持同步的 Replica 列表，该列表称为 ISR（即 in-sync Replica）。如果一个 Follower 宕机，或者落后太多，Leader 将把它从 ISR 中移除。这里所描述的“落后太多”指 Follower 复制的消息落后于 Leader 后的条数超过预定值或者 Follower 超过一定时间 Kafka 的复制机制既不是完全的同步复制，也不是单纯的异步复制。事实上，完全同步复制要求所有能工作的 Follower 都复制完，这条消息才会被认为 commit，这种复制方式极大的影响了吞吐率（高吞吐率是 Kafka 非常重要的一个特性）。而异步复制方式下，Follower 异步的从 Leader 复制数据，数据只要被 Leader 写入 log 就被认为已经 commit，这种情况下如果 Follower 都复制完都落后于 Leader，而如果 Leader 突然宕机，则会丢失数据。而 Kafka 的这种使用 ISR 的方式则很好的均衡了确保数据不丢失以及吞吐率。Follower 可以批量的从 Leader 复制数据，这样极大的提高复制性能（批量写磁盘），极大减少了 Follower 与 Leader 的差距。 高效使用磁盘根据JBOD配置的顺序写的性能可以达到600Mb/sec，是随机写100k/sec的6000倍 顺序写磁盘Kafka 的整个设计中，Partition 相当于一个非常长的数组，而 Broker 接收到的所有消息顺序写入这个大数组中。同时 Consumer 通过 Offset 顺序消费这些数据，并且不删除已经消费的数据，从而避免了随机写磁盘的过程。 由于磁盘有限，不可能保存所有数据，实际上作为消息系统 Kafka 也没必要保存所有数据，需要删除旧的数据。而这个删除过程，并非通过使用“读 - 写”模式去修改文件，而是将 Partition 分为多个 Segment，每个 Segment 对应一个物理文件，通过删除整个文件的方式去删除 Partition 内的数据。这种方式清除旧数据的方式，也避免了对文件的随机写操作。 充分利用 Page Cache使用 Page Cache 的好处如下 I/O Scheduler 会将连续的小块写组装成大块的物理写从而提高性能 I/O Scheduler 会尝试将一些写操作重新按顺序排好，从而减少磁盘头的移动时间 充分利用所有空闲内存（非 JVM 内存）。如果使用应用层 Cache（即 JVM 堆内存），会增加 GC 负担 读操作可直接在 Page Cache 内进行。如果消费和生产速度相当，甚至不需要通过物理磁盘（直接通过 Page Cache）交换数据 如果进程重启，JVM 内的 Cache 会失效，但 Page Cache 仍然可用 Zero copyKafka 中存在大量的网络数据持久化到磁盘（Producer 到 Broker）和磁盘文件通过网络发送（Broker 到 Consumer）的过程。这一过程的性能直接影响 Kafka 的整体吞吐量。 Linux 2.4+ 内核通过 sendfile 系统调用，提供了零拷贝。为了理解sendfile,需要去看以下通常情况下怎样传输数据从文件到网络socket: 操作系统把数据从硬盘读入内核空间的pagecache 应用把数据从内核读入user-space buffer 应用把数据写回到kernel space 再到一个 socket buffer 操作系统把数据从socket buffer复制到NIC buffer发送到网络 上面的操作效率很低，包含了4次复制和2次系统call. 使用 sendfile, 可以通过OS直接发送数据从pagecache到网络来避免重复的复制. 所以使用这种优化方式，只需要最后一次NIC buffer复制.使用zero-copy优化, 数据只复制到pagecache一次，并且重用而不是存储在内存和user-space。这种pagecache和sendfile的组合意味着consumers消费时没有磁盘读，所有的数据都从pagecache读。 高可用(多副本Replication)Kafka Log的分区被分布到集群中的多个服务器上。每个服务器处理它分到的分区。根据配置每个分区还可以复制到其它服务器作为备份容错。 每个分区有一个leader，零或多个follower。Leader处理此分区的所有的读写请求，而follower被动的复制数据。如果leader宕机，其它的一个follower会被推举为新的leader。 一台服务器可能同时是一个分区的leader，另一个分区的follower。 这样可以平衡负载，避免所有的请求都只让一台或者某几台服务器处理 Kafka node 存活有两个条件： Node必须保存session在ZooKeeper中(通过ZooKeeper’s heartbeat机制) Slave需要复制leader的写操作并且不能落后太多 但不同的是，这个 ISR 是由 Leader 动态维护的。如果 Follower 不能紧“跟上”Leader，它将被 Leader 从 ISR 中移除，待它又重新“跟上”Leader 后，会被 Leader 再次加加 ISR 中。每次改变 ISR 后，Leader 都会将最新的 ISR 持久化到 Zookeeper 中。 Replicated Logs: Quorums, ISRs, and State MachinesKafka 在 ZooKeeper 中动态维护了一个 ISR（in-sync replicas），这个 ISR 里的所有 Replica 都跟上了 leader，只有 ISR 里的成员才有被选为 Leader 的可能。在这种模式下，对于 f+1 个 Replica，一个 Partition 能在保证不丢失已经 commit 的消息的前提下容忍 f 个 Replica 的失败 如何将所有 Replica 均匀分布到整个集群为了更好的做负载均衡，Kafka 尽量将所有的 Partition 均匀分配到整个集群上。一个典型的部署方式是一个 Topic 的 Partition 数量大于 Broker 的数量。同时为了提高 Kafka 的容错能力，也需要将同一个 Partition 的 Replica 尽量分散到不同的机器 Kafka 的 Data Replication 需要解决如下问题： 怎样 Propagate 消息 在向 Producer 发送 ACK 前需要保证有多少个 Replica 已经收到该消息 怎样处理某个 Replica 不工作的情况 怎样处理 Failed Replica 恢复回来的情况 Producer 在发布消息到某个 Partition 时，先通过 ZooKeeper 找到该 Partition 的 Leader，然后无论该 Topic 的 Replication Factor 为多少（也即该 Partition 有多少个 Replica），Producer 只将该消息发送到该 Partition 的 Leader。Leader 会将该消息写入其本地 Log。每个 Follower 都从 Leader pull 数据。这种方式上，Follower 存储的数据顺序与 Leader 保持一致。Follower 在收到该消息并写入其 Log 后，向 Leader 发送 ACK。一旦 Leader 收到了 ISR 中的所有 Replica 的 ACK，该消息就被认为已经 commit 了，Leader 将增加 HW 并且向 Producer 发送 ACK。 为了提高性能，每个 Follower 在接收到数据后就立马向 Leader 发送 ACK，而非等到数据写入 Log 中。因此，对于已经 commit 的消息，Kafka 只能保证它被存于多个 Replica 的内存中，而不能保证它们被持久化到磁盘中，也就不能完全保证异常发生后该条消息一定能被 Consumer 消费 Consumer 读消息也是从 Leader 读取，只有被 commit 过的消息（offset 低于 HW 的消息）才会暴露给 Consumer。 ISR 实现可用性与数据一致性的动态平衡常用数据复制及一致性方案 Master-Slave RDBMS 的读写分离即为典型的 Master-Slave 方案 同步复制可保证强一致性但会影响可用性 异步复制可提供高可用性但会降低一致性 WNR 主要用于去中心化的分布式系统中。DynamoDB 与 Cassandra 即采用此方案或其变种 N 代表总副本数，W 代表每次写操作要保证的最少写成功的副本数，R 代表每次读至少要读取的副本数 当 W+R&gt;N 时，可保证每次读取的数据至少有一个副本拥有最新的数据 多个写操作的顺序难以保证，可能导致多副本间的写操作顺序不一致。Dynamo 通过向量时钟保证最终一致性 Paxos 及其变种 Google 的 Chubby，Zookeeper 的原子广播协议（Zab），RAFT 等 基于 ISR 的数据复制方案Kafka 的数据复制是以 Partition 为单位的。而多个备份间的数据复制，通过 Follower 向 Leader 拉取数据完成Kafka 的数据复制方案接近于上文所讲的 Master-Slave 方案。不同的是，Kafka 既不是完全的同步复制，也不是完全的异步复制，而是基于 ISR 的动态复制方案 ISR，也即 In-sync Replica。每个 Partition 的 Leader 都会维护这样一个列表，该列表中，包含了所有与之同步的 Replica（包含 Leader 自己）。每次数据写入时，只有 ISR 中的所有 Replica 都复制完，Leader 才会将其置为 Commit，它才能被 Consumer 所消费。 这种方案，与同步复制非常接近。但不同的是，这个 ISR 是由 Leader 动态维护的。如果 Follower 不能紧“跟上”Leader，它将被 Leader 从 ISR 中移除，待它又重新“跟上”Leader 后，会被 Leader 再次加加 ISR 中。每次改变 ISR 后，Leader 都会将最新的 ISR 持久化到 Zookeeper 中。Kafka 删除 Segment 的方式，是直接删除 Segment 对应的整个 log 文件和整个 index 文件而非删除文件中的部分内容。 水平扩展(分区Partition)一个Topic中可以有一个或多个partition。一个Broker上可以跑一个或多个Partition。集群中尽量保证partition的均匀分布，例如定义了一个有3个partition的topic，而只有两个broker，那么一个broker上跑两个partition，而另一个是1个。但是如果有3个broker，必然是3个broker上各跑一个partition。 Partition中严格按照消息进入的顺序排序一个从Producer发送来的消息，只会进入Topic的某一个Partition（除非特殊实现Producer要求消息进入所有Partition）Consumer可以自己决定从哪个Partition读取数据 负载均衡负载均衡可以通过client端控制，选择一个key来hash到不同的partition 客户端控制把数据发到哪个partition。可以是随机的负载均衡，也可以是其他的分区方式。Kafka暴露接口可以让用户自己实现逻辑，比如可以把user id作为key，然后同一个user的数据就会到同一个partition。 异步发送批量发送可以提高性能，kafka producer可以累积数据在内存中，然后把一批数据通过一个请求发送出去。batch大小可以通过时间和数据大小控制。 数据自动均衡增加和减少partition时可能需要做数据平衡，需要使用使用kafka提供的工具kafka-reassign-partitions.sh来迁移数据 基本交互原理每个Topic被创建后，在zookeeper上存放有其metadata，包含其分区信息、replica信息、LogAndOffset等默认路径/brokers/topics/&lt;topic_id&gt;/partitions/&lt;partition_index&gt;/state Producer可以通过zookeeper获得topic的broker信息，从而得知需要往哪写数据。 Consumer也从zookeeper上获得该信息，从而得知要监听哪个partition。 创建一个ProducerKafka提供了java api，Producer特别的简单，举传输byte[] 为例 12345Properties p = new Properties();props.put(\"metadata.broker.list\", \"10.1.110.21:9092\");ProducerConfig config = new ProducerConfig(props);Producer producer = new Producer&lt;String, byte[]&gt;(config);producer.send(byte[] msg); 创建一个ConsumerKafka提供了两种java的Consumer API：High Level Consumer和Simple Consumer 如何保证kafka的高容错性？ producer不使用批量接口，并采用同步模型持久化消息。consumer不采用批量化，每消费一次就更新offset Setup KafkaQuick Start Linux Start the server ~/Work/Develop/kafka_2.11-1.0.0/bin/zookeeper-server-start.sh ~/Work/Develop/kafka_2.11-1.0.0/config/zookeeper.properties &amp; ~/Work/Develop/kafka_2.11-1.0.0/bin/kafka-server-start.sh ~/Work/Develop/kafka_2.11-1.0.0/config/server1.properties &amp; Create a topic ~/Work/Develop/kafka_2.11-1.0.0/bin/kafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic test ~/Work/Develop/kafka_2.11-1.0.0/bin/kafka-topics.sh –list –zookeeper localhost:2181 Send/Consume some messages ~/Work/Develop/kafka_2.11-1.0.0/bin/kafka-console-producer.sh –broker-list localhost:9092 –topic test ~/Work/Develop/kafka_2.11-1.0.0/bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic test –from-beginning Setting up a multi-broker cluster 1234567891011121314config/server-1.properties: broker.id=1 listeners=PLAINTEXT://:9092 log.dirs=~/Work/Develop/kafka_2.11-1.0.0/logs/kafka-logs-1 config/server-2.properties: broker.id=2 listeners=PLAINTEXT://:9094 log.dirs=~/Work/Develop/kafka_2.11-1.0.0/logs/kafka-logs-2config/server-3.properties: broker.id=3 listeners=PLAINTEXT://:9094 log.dirs=~/Work/Develop/kafka_2.11-1.0.0/logs/kafka-logs-3 Restart 3 nodes 123~/Work/Develop/kafka_2.11-1.0.0/bin/kafka-server-start.sh ~/Work/Develop/kafka_2.11-1.0.0/config/server1.properties &amp;~/Work/Develop/kafka_2.11-1.0.0/bin/kafka-server-start.sh ~/Work/Develop/kafka_2.11-1.0.0/config/server2.properties &amp;~/Work/Develop/kafka_2.11-1.0.0/bin/kafka-server-start.sh ~/Work/Develop/kafka_2.11-1.0.0/config/server3.properties &amp; create a new topic with a replication factor of three: 1&gt; ~/Work/Develop/kafka_2.11-1.0.0/bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 3 --topic my-replicated-topic describe topics” command: 1~/Work/Develop/kafka_2.11-1.0.0/bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topic ~/Work/Develop/kafka_2.11-1.0.0/bin/kafka-console-producer.sh –broker-list localhost:9092 –topic my-replicated-topic~/Work/Develop/kafka_2.11-1.0.0/bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –from-beginning –topic my-replicated-topic ps aux | grep server-1.properties Windows1. Start the serverstart zookeeperbin\\windows\\zookeeper-server-start.bat config\\zookeeper.propertiesstart kafkabin\\windows\\kafka-server-start.bat config\\server.properties 2. Create a topicLet’s create a topic named “test” with a single partition and only one replica:bin\\windows\\kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test We can now see that topic if we run the list topic command:bin\\windows\\kafka-topics.bat --list --zookeeper localhost:2181 3. Send some messagesKafka comes with a command line client that will take input from a file or from standard input and send it out as messages to the Kafka cluster. By default, each line will be sent as a separate message. Run the producer and then type a few messages into the console to send to the server. bin\\windows\\kafka-console-producer.bat --broker-list localhost:9092 --topic test 4. Start a consumerKafka also has a command line consumer that will dump out messages to standard output. bin\\windows\\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginning","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"消息中间件","slug":"软件开发/系统架构/消息中间件","permalink":"http://yoursite.com/categories/软件开发/系统架构/消息中间件/"}],"tags":[]},{"title":"消息中间件","slug":"软件开发/系统架构/消息中间件/消息中间件","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:15:59.255Z","comments":true,"path":"passages/软件开发/系统架构/消息中间件/消息中间件/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/消息中间件/消息中间件/","excerpt":"","text":"RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。 kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache定级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务 消息队列中间件（简称消息中间件）是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下提供应用解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步等等功能，其作为分布式系统架构中的一个重要组件，有着举足轻重的地位。 消息系统好处 解耦 可独立的扩展或修改两边的处理过程。 扩展性 单独增加生产者或消费者处理能力即可，交互方式不变。 峰值处理能力 使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。 可恢复性 系统的一部分组件失效时，不会影响到整体。 数据分发 一次生产，多次消费 选型要点衡量一款消息中间件是否符合需求需要从多个维度进行考察，首要的就是功能维度，这个直接决定了你能否最大程度上的实现开箱即用，进而缩短项目周期、降低成本等 功能维度优先级队列优先级队列不同于先进先出队列，优先级高的消息具备优先被消费的特权，这样可以为下游提供不同消息级别的保证。不过这个优先级也是需要有一个前提的：如果消费者的消费速度大于生产者的速度，并且消息中间件服务器（一般简单的称之为 Broker）中没有消息堆积，那么对于发送的消息设置优先级也就没有什么实质性的意义了，因为生产者刚发送完一条消息就被消费者消费了，那么就相当于 Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。 延迟队列当你在网上购物的时候是否会遇到这样的提示：“三十分钟之内未付款，订单自动取消”？这个是延迟队列的一种典型应用场景。延迟队列存储的是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。延迟队列一般分为两种：基于消息的延迟和基于队列的延迟。基于消息的延迟是指为每条消息设置不同的延迟时间，那么每当队列中有新消息进入的时候就会重新根据延迟时间排序，当然这也会对性能造成极大的影响。实际应用中大多采用基于队列的延迟，设置不同延迟级别的队列，比如 5s、10s、30s、1min、5mins、10mins 等，每个队列中消息的延迟时间都是相同的，这样免去了延迟排序所要承受的性能之苦，通过一定的扫描策略（比如定时）即可投递超时的消息 死信队列由于某些原因消息无法被正确的投递，为了确保消息不会被无故的丢弃，一般将其置于一个特殊角色的队列，这个队列一般称之为死信队列。与此对应的还有一个“回退队列”的概念，试想如果消费者在消费时发生了异常，那么就不会对这一次消费进行确认（Ack）, 进而发生回滚消息的操作之后消息始终会放在队列的顶部，然后不断被处理和回滚，导致队列陷入死循环。为了解决这个问题，可以为每个队列设置一个回退队列，它和死信队列都是为异常的处理提供的一种机制保障。实际情况下，回退队列的角色可以由死信队列和重试队列来扮演 重试队列重试队列其实可以看成是一种回退队列，具体指消费端消费消息失败时，为防止消息无故丢失而重新将消息回滚到 Broker 中。与回退队列不同的是重试队列一般分成多个重试等级，每个重试等级一般也会设置重新投递延时，重试次数越多投递延时就越大。举个例子：消息第一次消费失败入重试队列 Q1，Q1 的重新投递延迟为 5s，在 5s 过后重新投递该消息；如果消息再次消费失败则入重试队列 Q2，Q2 的重新投递延迟为 10s，在 10s 过后再次投递该消息。以此类推，重试越多次重新投递的时间就越久，为此需要设置一个上限，超过投递次数就入死信队列。重试队列与延迟队列有相同的地方，都是需要设置延迟级别，它们彼此的区别是：延迟队列动作由内部触发，重试队列动作由外部消费端触发；延迟队列作用一次，而重试队列的作用范围会向后传递 消费模式消费模式分为推（push）模式和拉（pull）模式。推模式是指由 Broker 主动推送消息至消费端，实时性较好，不过需要一定的流制机制来确保服务端推送过来的消息不会压垮消费端。而拉模式是指消费端主动向 Broker 端请求拉取（一般是定时或者定量）消息，实时性较推模式差，但是可以根据自身的处理能力而控制拉取的消息量。 广播消费消息一般有两种传递模式：点对点（P2P，Point-to-Point）模式和发布 / 订阅（Pub/Sub）模式。对于点对点的模式而言，消息被消费以后，队列中不会再存储，所以消息消费者不可能消费到已经被消费的消息。虽然队列可以支持多个消费者，但是一条消息只会被一个消费者消费。发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题（topic），主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者则从主题中订阅消息。主题使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布 / 订阅模式在消息的一对多广播时采用。RabbitMQ 是一种典型的点对点模式，而 Kafka 是一种典型的发布订阅模式。但是 RabbitMQ 中可以通过设置交换器类型来实现发布订阅模式而达到广播消费的效果，Kafka 中也能以点对点的形式消费，你完全可以把其消费组（consumer group）的概念看成是队列的概念。不过对比来说，Kafka 中因为有了消息回溯功能的存在，对于广播消费的力度支持比 RabbitMQ 的要强 消息回溯一般消息在消费完成之后就被处理了，之后再也不能消费到该条消息。消息回溯正好相反，是指消息在消费完成之后，还能消费到之前被消费掉的消息。对于消息而言，经常面临的问题是“消息丢失”，至于是真正由于消息中间件的缺陷丢失还是由于使用方的误用而丢失一般很难追查，如果消息中间件本身具备消息回溯功能的话，可以通过回溯消费复现“丢失的”消息进而查出问题的源头之所在。消息回溯的作用远不止与此，比如还有索引恢复、本地缓存重建，有些业务补偿方案也可以采用回溯的方式来实现。 消息堆积 + 持久化流量削峰是消息中间件的一个非常重要的功能，而这个功能其实得益于其消息堆积能力。从某种意义上来讲，如果一个消息中间件不具备消息堆积的能力，那么就不能把它看做是一个合格的消息中间件。消息堆积分内存式堆积和磁盘式堆积。RabbitMQ 是典型的内存式堆积，但这并非绝对，在某些条件触发后会有换页动作来将内存中的消息换页到磁盘（换页动作会影响吞吐），或者直接使用惰性队列来将消息直接持久化至磁盘中。Kafka 是一种典型的磁盘式堆积，所有的消息都存储在磁盘中。一般来说，磁盘的容量会比内存的容量要大得多，对于磁盘式的堆积其堆积能力就是整个磁盘的大小。从另外一个角度讲，消息堆积也为消息中间件提供了冗余存储的功能。援引 纽约时报的案例，其直接将 Kafka 用作存储系统。 消息追踪对于分布式架构系统中的链路追踪（trace）而言，大家一定不会陌生。对于消息中间件而言，消息的链路追踪（以下简称消息追踪）同样重要。对于消息追踪最通俗的理解就是要知道消息从哪来，存在哪里以及发往哪里去。基于此功能下，我们可以对发送或者消费完的消息进行链路追踪服务，进而可以进行问题的快速定位与排查。 消息过滤消息过滤是指按照既定的过滤规则为下游用户提供指定类别的消息。就以 kafka 而言，完全可以将不同类别的消息发送至不同的 topic 中，由此可以实现某种意义的消息过滤，或者 Kafka 还可以根据分区对同一个 topic 中的消息进行分类。不过更加严格意义上的消息过滤应该是对既定的消息采取一定的方式按照一定的过滤规则进行过滤。同样以 Kafka 为例，可以通过客户端提供的 ConsumerInterceptor 接口或者 Kafka Stream 的 filter 功能进行消息过滤。 多租户也可以称为多重租赁技术，是一种软件架构技术，主要用来实现多用户的环境下公用相同的系统或程序组件，并且仍可以确保各用户间数据的隔离性。RabbitMQ 就能够支持多租户技术，每一个租户表示为一个 vhost，其本质上是一个独立的小型 RabbitMQ 服务器，又有自己独立的队列、交换器及绑定关系等，并且它拥有自己独立的权限。vhost 就像是物理机中的虚拟机一样，它们在各个实例间提供逻辑上的分离，为不同程序安全保密地允许数据，它既能将同一个 RabbitMQ 中的众多客户区分开，又可以避免队列和交换器等命名冲突。 多协议支持消息是信息的载体，为了让生产者和消费者都能理解所承载的信息（生产者需要知道如何构造消息，消费者需要知道如何解析消息），它们就需要按照一种统一的格式描述消息，这种统一的格式称之为消息协议。有效的消息一定具有某种格式，而没有格式的消息是没有意义的。一般消息层面的协议有 AMQP、MQTT、STOMP、XMPP 等（消息领域中的 JMS 更多的是一个规范而不是一个协议），支持的协议越多其应用范围就会越广，通用性越强，比如 RabbitMQ 能够支持 MQTT 协议就让其在物联网应用中获得一席之地。还有的消息中间件是基于其本身的私有协议运转的，典型的如 Kafka。 跨语言支持对很多公司而言，其技术栈体系中会有多种编程语言，如 C/C++、JAVA、Go、PHP 等，消息中间件本身具备应用解耦的特性，如果能够进一步的支持多客户端语言，那么就可以将此特性的效能扩大。跨语言的支持力度也可以从侧面反映出一个消息中间件的流行程度。 流量控制流量控制（flow control）针对的是发送方和接收方速度不匹配的问题，提供一种速度匹配服务抑制发送速率使接收方应用程序的读取速率与之相适应。通常的流控方法有 Stop-and-wait、滑动窗口以及令牌桶等。 消息顺序性顾名思义，消息顺序性是指保证消息有序。这个功能有个很常见的应用场景就是 CDC（Change Data Chapture），以 MySQL 为例，如果其传输的 binlog 的顺序出错，比如原本是先对一条数据加 1，然后再乘以 2，发送错序之后就变成了先乘以 2 后加 1 了，造成了数据不一致。 安全机制在 Kafka 0.9 版本之后就开始增加了身份认证和权限控制两种安全机制。身份认证是指客户端与服务端连接进行身份认证，包括客户端与 Broker 之间、Broker 与 Broker 之间、Broker 与 ZooKeeper 之间的连接认证，目前支持 SSL、SASL 等认证机制。权限控制是指对客户端的读写操作进行权限控制，包括对消息或 Kafka 集群操作权限控制。权限控制是可插拔的，并支持与外部的授权服务进行集成。对于 RabbitMQ 而言，其同样提供身份认证（TLS/SSL、SASL）和权限控制（读写操作）的安全机制。 消息幂等性对于确保消息在生产者和消费者之间进行传输而言一般有三种传输保障（delivery guarantee）：At most once，至多一次，消息可能丢失，但绝不会重复传输；At least once，至少一次，消息绝不会丢，但是可能会重复；Exactly once，精确一次，每条消息肯定会被传输一次且仅一次。对于大多数消息中间件而言，一般只提供 At most once 和 At least once 两种传输保障，对于第三种一般很难做到，由此消息幂等性也很难保证。 Kafka 自 0.11 版本开始引入了幂等性和事务，Kafka 的幂等性是指单个生产者对于单分区单会话的幂等，而事务可以保证原子性地写入到多个分区，即写入到多个分区的消息要么全部成功，要么全部回滚，这两个功能加起来可以让 Kafka 具备 EOS（Exactly Once Semantic）的能力。 不过如果要考虑全局的幂等，还需要与从上下游方面综合考虑，即关联业务层面，幂等处理本身也是业务层面所需要考虑的重要议题。以下游消费者层面为例，有可能消费者消费完一条消息之后没有来得及确认消息就发生异常，等到恢复之后又得重新消费原来消费过的那条消息，那么这种类型的消息幂等是无法有消息中间件层面来保证的。如果要保证全局的幂等，需要引入更多的外部资源来保证，比如以订单号作为唯一性标识，并且在下游设置一个去重表。 事务性消息事务本身是一个并不陌生的词汇，事务是由事务开始（Begin Transaction）和事务结束（End Transaction）之间执行的全体操作组成。支持事务的消息中间件并不在少数，Kafka 和 RabbitMQ 都支持，不过此两者的事务是指生产者发生消息的事务，要么发送成功，要么发送失败。消息中间件可以作为用来实现分布式事务的一种手段，但其本身并不提供全局分布式事务的功能。 性能功能维度是消息中间件选型中的一个重要的参考维度，但这并不是唯一的维度。有时候性能比功能还要重要，况且性能和功能很多时候是相悖的，鱼和熊掌不可兼得，Kafka 在开启幂等、事务功能的时候会使其性能降低，RabbitMQ 在开启 rabbitmq_tracing 插件的时候也会极大的影响其性能。消息中间件的性能一般是指其吞吐量，虽然从功能维度上来说，RabbitMQ 的优势要大于 Kafka，但是 Kafka 的吞吐量要比 RabbitMQ 高出 1 至 2 个数量级，一般 RabbitMQ 的单机 QPS 在万级别之内，而 Kafka 的单机 QPS 可以维持在十万级别，甚至可以达到百万级。 可靠性 + 可用性消息丢失是使用消息中间件时所不得不面对的一个同点，其背后消息可靠性也是衡量消息中间件好坏的一个关键因素。尤其是在金融支付领域，消息可靠性尤为重要。然而说到可靠性必然要说到可用性，注意这两者之间的区别，消息中间件的可靠性是指对消息不丢失的保障程度；而消息中间件的可用性是指无故障运行的时间百分比，通常用几个 9 来衡量。 从狭义的角度来说，分布式系统架构是一致性协议理论的应用实现，对于消息可靠性和可用性而言也可以追溯到消息中间件背后的一致性协议。对于 Kafka 而言，其采用的是类似 PacificA 的一致性协议，通过 ISR（In-Sync-Replica）来保证多副本之间的同步，并且支持强一致性语义（通过 acks 实现）。对应的 RabbitMQ 是通过镜像环形队列实现多副本及强一致性语义的。多副本可以保证在 master 节点宕机异常之后可以提升 slave 作为新的 master 而继续提供服务来保障可用性。Kafka 设计之初是为日志处理而生，给人们留下了数据可靠性要求不要的不良印象，但是随着版本的升级优化，其可靠性得到极大的增强，详细可以参考 KIP101。就目前而言，在金融支付领域使用 RabbitMQ 居多，而在日志处理、大数据等方面 Kafka 使用居多，随着 RabbitMQ 性能的不断提升和 Kafka 可靠性的进一步增强，相信彼此都能在以前不擅长的领域分得一杯羹 KafkaKafka体系架构一个Kafka体系架构包括若干Producer, 若干Broker，若干Consumer ，以及一个Zookeeper集群。 Kafka通过Zookeeper管理集群配置，选举leader，以及在consumer group发生变化时进行rebalance。 Producer使用push(推)模式将消息发布到broker，Consumer使用pull(拉)模式从broker订阅并消费消息。 Broker: 消息中间件处理节点，一个Kafka节点就是一个broker，一个或者多个Broker可以组成一个Kafka集群 Topic: Kafka根据topic对消息进行归类，发布到Kafka集群的每条消息都需要指定一个topic Producer: 消息生产者，向Broker发送消息的客户端 Consumer: 消息消费者，从Broker读取消息的客户端 Consumer Group: 每个Consumer属于一个特定的Consumer Group，一条消息可以发送到多个不同的Consumer Group，但是一个Consumer Group中只能有一个Consumer能够消费该消息 Partition: 物理上的概念，一个topic可以分为多个partition，每个partition内部是有序的 Topic &amp; Partition每个topic将被分成多个partition，每个partition在存储层面是append log文件。任何发布到此partition的消息都会被追加到log文件的尾部。 每条消息在文件中的位置称为offset(偏移量)，offset为一个long型的数字，它唯一标记一条消息。每条消息都被append到partition中，是顺序写磁盘，因此效率非常高。 由 max offset和current offset，我们可以获得当前还有多少消息没有被消费（lag）。 由（lag/（maxoffset - minoffset）），我们可以算出当前还没有被消费的消息占的百分比，如果这个百分比接近100%，那么接下来很可能会导致offset out of range exception而丢失数据。 Kafka Replication为了提高消息的可靠性，Kafka每个topic的partition有N个副本（replicas），其中N(大于等于1)是topic的复制因子（replica fator）的个数。 Kafka通过多副本机制实现故障自动转移，Kafka集群中一个broker失效情况下仍然保证服务可用。N个replicas中，其中一个replica为Leader，其他都为Follower，Leader处理partition的所有读写请求。 高可靠性配置 要可靠性: 当然可以，Leader收到消息之后，等所有Follower返回ok了ack，慢死。但好处是，主挂了，哪个Follower都可以做主，因为大家数据都一样。 要速度: 当然可以，Leader收到消息写入本地就ack，然后再发给Follower。问题也很显而易见，最坏得情况下，Leader返回ack了，但Follower因为各种原因没有写入，主挂了，丢数据了。 要保证数据写入到Kafka是安全的，高可靠的，需要如下的配置： 复制系数replication.factor&gt;=3，即副本数至少是3个 Minimum In-sync Replicas， 2&lt;=min.insync.replicas&lt;=replication.factor 这个参数设定ISR中的最小副本数是多少，默认值为1。 当且仅当acks参数设置为-1时，此参数才生效。 如果ISR中的副本数少于min.insync.replicas配置的数量时，客户端会返回异常： NotEnoughReplicasExceptoin: Messages are rejected since there are fewer in-sync replicas than required。 不完全的Leader选举 – 不允许不同步的副本成为Leader（仅Broker级别） unclean.leader.election.enable=false Acknowledgements – acks 1（default）：这意味着producer在ISR中的leader已成功收到的数据并得到确认后发送 下一条message。如果leader宕机了，则会丢失数据。 0：这意味着producer无需等待来自broker的确认而继续发送下一批消息。这种情况下数 据传输效率最高，但是数据可靠性确是最低的。 -1/all：producer等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠 性最高。但是这样也不能保证数据不丢失，当ISR中只有leader时（ISR中的成员由于某 些情况会增加也会减少，最少就只剩一个leader），这样就变成了acks=1的情况。 Producer - 配置生产者的重试参数 Consumer - Disable auto commit TipsKafka Producer, Consumer 怎么找到分区Leader 原数据请求 – 包括Topic的分区，每个分区副本，Leader，每个Broker都有缓存。 定期刷新 分区Leader 如何选举 控制器Controller, 集群第一个启动broker，在ZK创建controller临时节点，其他会watch，一旦这个控制器Broker关闭，ZK节点会消失，其他Broker会尝试重建。 一个broker down，它知道哪些分区失去了Leader，并确定新Leader 发送/接受消息是batch的, 并注意发送和接收的单个最大消息size配置 Producer : batch.size, linger.ms，max.request.size Consumer : fetch.min.bytes, fetch.max.wait.ms, message.max.bytes 序列化与反序列化分区接受策略（Producer）&amp; 分区分配策略（Consumer） Default Round Robin（轮询） 自定义策略 消费者群组 起多个Consumer Group，起多个Consumer，增加partition数量 一个partition一个consumer thread 分区Consumer再均衡Auto offset reset Latest Earliest 如何提交offset Auto commit 先提交offset再处理message - At most once: 消息可能会丢，但绝不会重复传输 先处理message再提交offset - At least once：消息绝不会丢，但可能会重复传输 文件管理 log.retention.ms &amp; log.retention.bytes 活跃片断永远不会删除 注意调整操作系统文件句柄数量 – 分区每个片段都会打开一个句柄，包括不活跃的 架构模型RabbitMQ遵循AMQP协议，RabbitMQ的broker由Exchange,Binding,queue组成，其中exchange和binding组成了消息的路由键；客户端Producer通过连接channel和server进行通信，Consumer从queue获取消息进行消费（长连接，queue有消息会推送到consumer端，consumer循环从输入流读取数据）。rabbitMQ以broker为中心；有消息的确认机制。 kafka遵从一般的MQ结构，producer，broker，consumer，以consumer为中心，消息的消费信息保存的客户端consumer上，consumer根据消费的点，从broker上批量pull数据；无消息确认机制。 TPS比较Kafka最高，RabbitMq 次之， ActiveMq 最差 吞吐量kafka具有高的吞吐量，内部采用消息的批量处理，zero-copy机制，数据的存储和获取是本地磁盘顺序批量操作，具有O(1)的复杂度，消息处理的效率很高。 rabbitMQ在吞吐量方面稍逊于kafka，他们的出发点不一样，rabbitMQ支持对消息的可靠的传递，支持事务，不支持批量的操作；基于存储的可靠性的要求存储可以采用内存或者硬盘。 可用性rabbitMQ支持miror的queue，主queue失效，miror queue接管。 kafka的broker支持主备模式。 集群负载均衡kafka采用zookeeper对集群中的broker、consumer进行管理，可以注册topic到zookeeper上；通过zookeeper的协调机制，producer保存对应topic的broker信息，可以随机或者轮询发送到broker上；并且producer可以基于语义指定分片，消息发送到broker的某分片上。 rabbitMQ的负载均衡需要单独的loadbalancer进行支持。 ActiveMq RabbitMq Kafka producer容错，是否会丢数据 有ack模型，也有事务模型，保证至少不会丢数据。ack模型可能会有重复消息，事务模型则保证完全一致 批量形式下，可能会丢数据。 非批量形式下， 1. 使用同步模式，可能会有重复数据。 2. 异步模式，则可能会丢数据。 consumer容错，是否会丢数据 有ack模型，数据不会丢，但可能会重复处理数据。 批量形式下，可能会丢数据。非批量形式下，可能会重复处理数据。（ZK写offset是异步的） 架构模型 基于JMS协议 基于AMQP模型，比较成熟，但更新超慢。RabbitMQ的broker由Exchange,Binding,queue组成，其中exchange和binding组成了消息的路由键；客户端Producer通过连接channel和server进行通信，Consumer从queue获取消息进行消费（长连接，queue有消息会推送到consumer端，consumer循环从输入流读取数据）。rabbitMQ以broker为中心；有消息的确认机制 producer，broker，consumer，以consumer为中心，消息的消费信息保存的客户端consumer上，consumer根据消费的点，从broker上批量pull数据；无消息确认机制。 吞吐量 rabbitMQ在吞吐量方面稍逊于kafka，他们的出发点不一样，rabbitMQ支持对消息的可靠的传递，支持事务，不支持批量的操作；基于存储的可靠性的要求存储可以采用内存或者硬盘。 kafka具有高的吞吐量，内部采用消息的批量处理，zero-copy机制，数据的存储和获取是本地磁盘顺序批量操作，具有O(1)的复杂度，消息处理的效率很高 可用性 rabbitMQ支持miror的queue，主queue失效，miror queue接管 kafka的broker支持主备模式 集群负载均衡 rabbitMQ的负载均衡需要单独的loadbalancer进行支持 kafka采用zookeeper对集群中的broker、consumer进行管理，可以注册topic到zookeeper上；通过zookeeper的协调机制，producer保存对应topic的broker信息，可以随机或者轮询发送到broker上；并且producer可以基于语义指定分片，消息发送到broker的某分片上","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"消息中间件","slug":"软件开发/系统架构/消息中间件","permalink":"http://yoursite.com/categories/软件开发/系统架构/消息中间件/"}],"tags":[]},{"title":"108个经济学常识","slug":"金融/投资/108个经济学常识","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:11:41.596Z","comments":true,"path":"passages/金融/投资/108个经济学常识/","link":"","permalink":"http://yoursite.com/passages/金融/投资/108个经济学常识/","excerpt":"","text":"&lt;108个经济学常识：不做经济白痴&gt; 第一部分 第1节：当前10大热点(1) 上篇：经济常识篇 第O讲：当前10大热点 居庙堂之高则忧其民，处江湖之远则忧其君 金融危机 【点睛】国家流感，时常出现一些变异的新品种，传染性极强，最糟糕可导致病人死亡——即国家破产。 【释义】金融危机，是指一个国家或几个国家与地区的全部或大部分金融指标急剧、短暂和超周期的恶化。其特征是基于人们对经济未来更加悲观的预期，整个区域内货币币值出现幅度较大的贬值，经济总量与经济规模出现较大的损失，经济增长受到打击，往往伴随着企业大量倒闭，失业率提高，社会普遍的经济萧条，甚至有些时候会有社会动荡或国家政治层面的动荡。 【谈古说今】 &quot;你想过中产阶级的生活吗？买房吧！&quot; &quot;积蓄不够吗？找阿牛贷款公司吧！&quot; &quot;首付也付不起？我们提供零首付！&quot; &quot;每个月的房钱还是付不起？没关系，前24个月只要支付利息即可。想想24个月后你估计早就升官发财了，还怕付不起！&quot; &quot;怎么还怕不行？你也太小心啦，你看这两年房子都涨了这么多了，到时实在不行转手卖了，不但白住两年，还能大赚一笔！我都敢贷，你还不敢借？&quot; 大约从十年前开始，美国贷款公司的广告就漫天飞舞，电视上，报纸上，街头巷尾，无处不在。就在这样的诱惑下，无数的美国市民毫不犹豫地贷款买了房。 很快阿牛贷款公司的钱一下子全贷出去了，可是贷出去能收回吗？董事长阿牛先生虽然喜欢忽悠，可是自己心里还是清楚的，这贷款风险也太大了，还是把风险转嫁出去吧。于是阿牛找到了美国经济界的带头大哥——投资银行。 带头大哥转头找来哈佛的教授，还有一些诺贝尔经济学奖获得者，用上最新的模型，几番捣鼓，把这些零散的贷款打包到一起，然后找来评级机构进行评级。如果某个贷款要最先偿还，就评个A级吧，那个叫次级债的贷款是在A级的贷款还了之后再还的，那就评个B级吧。经过这些巨牛的专家的认证，加上投行们三寸不烂之金舌，时不时蹦出几个听不懂的词吓唬吓唬你，很快债券就被卖到全世界的投资者那里去了。 2001年开始，美国的房地产一路飙升，短短几年就翻了一倍，像阿牛贷款公司广告中所说的那样，就算还不起钱，大不了把房卖了，还是能赚上一笔。本来这些投行只是把这些高风险的贷款打包卖给别人，自己并不敢碰，可是别人买了啥事也没有，而且由于利率高，个个都赚得肥肥的。就像老朱家有馊掉的饭菜，正巧看见隔壁那条讨厌的小花狗，本来打算毒它一把，没想到小花狗吃了不但没事，而且越长越壮，这下老朱给搞懵了，难道馊饭菜营养更高？于是自己也开始狂吃。 第一部分 第2节：当前10大热点(2) 就这样，养老基金，对冲基金，保险公司，大投行个个都赚的满满的。可是好景不长，2006年底，风光了五年的美国房地产终于开始下跌了。房价跌了，那些零首付、零收入的人，很多到了时间无法付起贷款，房子卖了也只能还那些需要先还的贷款，次级债是无法还的了。然后贷款公司开始倒闭，保险公司大亏，投行大亏，股市大跌，民众都亏钱了，更加无法还房贷了，最终金融危机爆发了，并且像瘟疫一样传到了全球各地。 商品倾销 【点睛】这是一个把东西廉价卖给别人却还要挨骂挨打的奇怪世界。 【释义】商品倾销就是厂商以低于商品成本的极其低廉的价格在某一地区销售商品，以达到消灭竞争对手，垄断整个市场的目的。倾销被视为一种不正当的竞争手段，为WTO所禁止，因此反倾销也成为各国保护本国市场，扶持本国企业强有力的借口和理由。 【谈古说今】说到倾销，中国绝大部分外贸型的企业可能都深有感触，因为他们三天两头被一些国家指控倾销，要进行反倾销的立案调查。下面我们看一个例子： 2006年10月7号，欧盟正式表决通过了针对中国皮鞋征收16.5%的反倾销税的提案。其中作为中国皮鞋主要出口商的温州鞋企受到了严重的打击。事实上在2006年的4月份，欧盟就开始对中国皮鞋征收临时性反倾销税了，这直接导致了出口额的明显下降，很多温州小型鞋企甚至出现了零订单的现象。欧盟对中国鞋企征收反倾销税主要是因为中国的皮鞋价格太低了，欧盟生产商的平均价格是30-70欧元，中国的出口价格却只有10欧元，反倾销是他们为了支持本国企业，保护本国市场所采取的一个手段。 不仅仅是皮鞋，中国生产的很多产品，比如纺织品，打火机等都有被国外指控倾销的经历。各位看官也许要问了：为什么受伤的总是我？中国人惹谁了？下面看一个中国的在美留学生的自述，你可能会有点启发： 我喜欢做些运动，也喜欢爬山。大约是在2004年，我买了几双登山鞋，其中最便宜的是耐克牌的一双登山鞋。当时的价格是89.95美元。就在前几天，我去沃尔玛进行圣诞采购时发现，沃尔玛正在卖一款大陆生产的登山鞋，令人吃惊的是价格只有2.99美元。而且买第二双的时候给半价的优惠。换句话说就是，买两双大陆产的登山鞋只要3.49美元。也就是说包括运费、关税在内每个只要十几元人民币。 对此我非常奇怪，也非常震惊，于是打电话给国内的朋友，我问他：&quot;在大陆你能花十几元人民币买到一双登山鞋吗？&quot;这位朋友对我说：&quot;都什么时代了，在大陆哪还有十几元的鞋？你还要买登山鞋，三百多块买的还是烂牌子，好一点的都要一千多块。&quot;可是我的确在美国买到了。 第一部分 第3节：当前10大热点(3) 各位看官可能也觉得好奇，出口到别的国家售价竟然比国内还便宜，莫非真的是倾销？其实这一点都不奇怪，在大陆劳工便宜，不像美国有这个保险，那个公会的，成本怎能不低呢？国内价格贵的原因出在流通环节。国内高速公路收费之高远远超过人们的想象，公路交警的罚款也是名目繁多。从广州开车到北京光过路费就要1400多人民币，这还是一路没有罚款的情况下。相比之下，从大陆运货到美国比从广州到上海还便宜。并且大陆市场看起来很大，其实很小，很多老百姓买鞋才不去管什么是山用的，什么是跑步用的，买登山鞋都是那些有钱的闲人。再加上国内有些商人没有信用，发了货不给钱，厂商只有通过提高价格来弥补损失。这一切导致了卖到美国的鞋反而更便宜。 所以这种情况下，被指有倾销行为应该很好理解了吧？ 政府救市 【点睛】救市如救火。林子里的大火如若不救，烧尽了自然会熄灭，历经寒暑新的草木也能慢慢长起来；如若救得得当，树干不倒，来年新春便可恢复如初，欣欣向荣。 【释义】政府救市指当经济运行状况恶化、需求萎缩、企业运营困难时，政府通过财政税收和监管权对市场进行干预，以维持正常经济秩序，刺激经济发展的行为。 【谈古说今】政府该不该救市的问题争吵了几百年也没有一个结果。经济学的鼻祖亚当·斯密出版了《国富论》，阐述了市场万能的理念，他将市场比作一只看不见的手，当供给和需求不等时，市场总是能够通过价格的变化来使得供需重新达到平衡。从那时起，人们便开始相信政府不该干预市场，自由的市场是经济进步的动力。可是三十年代的大萧条改变了这一切，人们眼睁睁地看着银行一家家倒掉，公司一家家倒闭，工人一个个下岗，而市场自身却无法进行及时有效的调节。于是罗斯福新政开辟了政府干预主义的先河，凯恩斯的政府干预理论得到大部分人的认同。然而这场争论仍然没有停止，下面我们看看信奉自由主义的小布什和相信政府干预主义的萨科奇之间的PK。 首先，一贯喜欢以老大哥身份出现的小布什粉墨登场。2008年11月3日，他刚上任就开始向世界训话：&quot;各个国家听好了，在应付这场百年不遇的金融危机的过程中你们不应该放弃资本主义的自由市场原则，因为它可以保证我们的经济增长。&quot; 萨科奇忍不住了：&quot;你不要在那边瞎扯蛋了，目前遇到这种危机正是我们政府大有作为的时候，我们要保证政府在危机中发挥重要作用。&quot; 小布什道：&quot;根据伟大的马克思主义唯物辩证法原理和历史的经验，我们知道过多政府干预将是经济平稳增长的巨大威胁！&quot; 第一部分 第4节：当前10大热点(4) 澳洲总理陆克文在一旁急了：&quot;布什哥哥啊，你美国政府自己在危机前就像小女孩那样扭扭捏捏，愚昧而又无知也就算了，你不要用你那美国总统史上最低的智商来考虑我们的决策好不好？&quot; 虽然他们在讲话时，用一大堆完美的外交辞令进行修饰，但是基本的意思如上翻译。信奉经济自由主义的小布什虽然在总统的宝座上已经蹦跶不了几天了，但是他所信奉的思想还是有很多的拥护者。 后面我们也看到，在奥巴马的操刀下，美国政府竭尽全力地救助企业，扶持银行，刺激市场，以维持人们对经济的信心，帮助美国经济走出低谷。中国政府在此轮危机中也出台了很多政策，四万亿投资，减少税收，降低利率，稳定房价等等，都是政府救市的表现，大众也都在期待着政府主导下经济的复苏。但是至于政府该不该救市至今仍无定论，学术界也将会继续争论下去。 次级债券 【点睛】什么时候还我钱并不重要，关键要给我足够的利息。 【释义】次级债券是指偿还次序优于公司股本权益、但低于公司一般债务的一种债务形式。如果一家公司破产了，那么最先需要偿还的是正常的债权或者贷款，等这些债券和贷款全部偿还完毕之后，才对次级债券进行偿还，如果还有剩余的钱就会留给股东分了。 【谈古说今】2008年，9月16日、17日连续两日，中国A股的银行板块出现集体跌停的壮观景象。你要知道中国工商银行，中国银行，这些国有大行盘子非常大，买卖人数非常多，所以价格很稳定，一般正常的情况下波动幅度都非常小，可是那两天竟然每天跌去10%！主要原因就是这些银行在美国的次级债券很多都是血本无归。 2008年9月17日，招商银行发布公告，称其持有雷曼兄弟发行的债券共计7000万美元，其中高级债券6000万美元，次级债券1000万美元。我们都知道这次金融危机影响深重，就连美国金融界的带头大哥投行中排老三的雷曼兄弟也破产了。一旦破产就要进行清算，把自己手里所有的资产都拿出来还债，首先还的是高级债券和贷款。根据当时的估计，高级债券要损失30%~40%，而次级债券是在高级债券还完之后再还，现在高级债券都没钱还了，所以次级债券肯定血本无归。这个消息一出，招商银行的股票就趴在了跌停板上，一动不动。 当日中行也报告自己持有雷曼兄弟发行的债券7562万美元，占集团中资产的0.01%，占净资产的0.19%。还有中国第一大行工商银行也不例外，他持有的雷曼公司债券额度是1.518亿美元，它的股价也毫不例外的趴在跌停板上。 其实不光国外金融机构发行次级债券，国内大的金融机构也经常发行次级债券。2009年7月，中国工商银行就发行了400亿元的次级债券来提高自己的资本充足率；2009年6月，中国银行被批准发行不超过400亿元的次级债券；2009年2月，招商银行被批准发行400亿元的刺激债券等。这些大银行或金融机构发行次级债券主要是为了提高一下自己的资本充足率，一般次级债券时间都比较久，10年或者更长，所以他们可以放心使用而不用担心像储户那样随时随地可能找你还钱。 第一部分 第5节：当前10大热点(5) 可能有人会问，为什么人们会去买那么危险的玩意呢，买高级债券不是很好么？有句话说得好：重赏之下，必有勇夫。虽然次级债券比较危险，但是他的利息高啊，那些发行人为了把这些次级债券发出去，往往会给投资人很高的利息，自然就有人愿意冒这个险了。 国际游资 【点睛】政府觉得它们是金融界的骇客，不过索罗斯大概会认为自己是个黑客，你觉得呢？（注：骇客搞破坏，黑客提醒人们漏洞的存在）。 【释义】国际游资又可称为国际投机资本，指那些长期游离于本国实体经济之外，在各个国家和经济体之间快速流动，以追逐短期高额利润为最终目的的资本。国际游资一般投资于那些高风险高收益的金融衍生品，如外汇、期货、期权、股票等。 【谈古说今】&quot;这个家伙来到我们的国家，一夜之间，使我们全国人民十几年的奋斗化为乌有。&quot;这句话是马来西亚总理马哈蒂尔在1997年东南亚金融危机时说的，其中这个家伙就是指索罗斯。就是这个索罗斯，曾于1992年打垮了曾经的世界中央银行英格兰银行，迫使英国退出欧洲汇率体系；1994年又击败了墨西哥政府，使他们的货币比索一夜之间贬值一半以上；1997年横扫东南亚，让曾经的亚洲小龙小虎们不再神气。 诸位看官会奇怪了，索罗斯何许人物，焉能如此嚣张？这最大的原因啊，还在于他旗下的&quot;量子基金&quot;。量子基金应该算是国际游资的开山鼻祖了，基本上他们做的事就是坑死你不偿命，不管你是一个国家还是一个州，或者火星上来的，只要你的经济出现漏洞，他们就闻风而动，倾巢前来狙击你。 到此应该能大致了解国际游资从事的行当了吧，神秘而又嚣张，真够拽的。下面就让我们来看一下他们是怎么狙击别国经济漏洞进而获得巨额收益的。 首先要做的是寻找猎物。成为猎物的国家必然具有某些相同的特征，比如经济中存在泡沫，或者银行坏账太多，再或者贸易赤字过于严重。1997年东南亚金融危机时，泰国之所以会成为首选目标，就是因为其国内经济的发展存在很大的泡沫，房产高估，股市飙升，更要命的是在出现这些问题的同时泰国的国内资金开始流出，外汇储备大幅减少……如此完美的猎物，自然逃不过这些鳄鱼们的眼睛。 选定猎物之后，他们所要做的就是攻击了：在外汇市场上疯狂做空泰铢，以待其贬值时大赚一笔。由于国际游资数目巨大，而且还使用杠杆来放大效应，一般国家都招架不了；而且在狙击泰铢时，还放出大量的谣言动摇人们信心，让大家都相信泰铢会贬值，争先恐后地卖出泰铢。如此几番，泰铢就如同李白笔下的瀑布一般——&quot;飞流直下三千尺&quot;，甚是悲壮。 第一部分 第6节：当前10大热点(6) 最后一步，就是扩大战果，把周边国家也扫荡一空，然后拿着赚来的钱消失在公众视野之外，只剩下受害国叫苦不迭。 对被攻击国来说，国际游资是巨大灾难的缔造者和国家财富的掠夺者，但并不能因此对它全盘否定。我们还是听听索罗斯自己的话吧：&quot;在金融运作方面，说不上有道德还是无道德，这只是一种操作。金融市场是不属于道德范畴的，在这里道德根本不存在，因为它有自己的游戏规则。我是金融市场的参与者，我会按照已定的规则来玩这个游戏，我不会违反这些规则，所以我不觉得内疚或需要负责任。对于亚洲金融风暴，即使我不炒作，它照样会发生。另一方面，我很遵守运作规则。我主张改变某些规则。即使改进和改良会影响到我自己的利益，我也会支持它，因为需要改良的这个规则也许正是事件发生的原因。&quot; 【知识链接】东南亚金融危机时，由于中国大陆地区存在着资本管制，所谓的资本管制就是国外的钱想进来，必须要有国家的批准，所以那些鳄鱼的资金很难进得来，大陆没有受到什么影响。然而出于对这些鳄鱼的恐惧，中国政府在资本账户开放的问题上却越来越小心，逐渐放慢了资本账户开放的步伐。 人民币升值 【点睛】一个翻来倒去的过家家游戏而已，游戏规则是：你买小明家的煎饼果子更便宜了，但同时卖给小明的玩具熊也赚得更少。 【释义】人民币升值是指相对其他货币来说，人民币的购买力增强，主要表现在同样数量的人民币可以换取更多数量的外币。但是人民币升值是相对外国货币来说的，在国内市场无法显现，钱并没有变得更加值钱。 【谈古说今】其实人民币升值早就被提起了，很早以前就有学者提出要进行汇率改革，让人民币升值，然而央行这些专家们却一直到2005年7月才开启汇率改革。自从汇改以来，人民币兑美元节节攀升，就在这个过程中，中国的各个集团的利益都受到不同程度的影响，有些人受益，有些人的利益却遭到损害。这个人民币升值的背后到底有着怎样的利益格局呢？ 最不高兴的应当数中国的出口企业。由于人民币的升值，他们的出口减少了。比如，一双鞋的成本是24元人民币，当8元人民币兑1美元时，成本也就是3美元，现在假如人民币升值到6元兑1美元，那么显然鞋子的成本上升到4美元。所以由于成本的提升，企业的竞争力就下降了，能够出口的产品减少了，所以他们是此轮升值的最大受害者。 不过对于一个普通老百姓却未必是件坏事，因为人民币升值了，你手中的钱也更加值钱了。出个国，留个学都更加便宜了，购买国外的进口产品也花不了那么多钱了，所以你就尽管拍手叫好吧。 第一部分 第7节：当前10大热点(7) 与出口企业一脸愁容形成强烈对比的是进口企业的兴高采烈。由于人民币的升值，进口国外产品用不了那么多钱了，真是爽的不亦乐乎啊，特别我国的很多原材料进口商，像中石化和中国的钢铁企业，每年都需要从外国进口大量的原材料，他们都是受益者。同时中国企业去购买国外的先进技术也用不了那么多钱了，可以加快先进技术和设备的引进。 那么你可能要说，我又没有企业，又不想出国，这个人民币升值对我就没有影响了吧？错！这是一个绝对的侥幸心理，任何一个中国人都逃不了人民币升值的影响。就拿人民币升值使房价上涨的例子来说吧，由于人民币升值，很多资金就希望以人民币的形式来持有，所以就会有大量的资金进入国内。而这些资金总不可能一直持有着一张一张的百元大钞吧，那它就要去投资，要是拿去买房子，房价就要大涨，拿去买股票，股价就要大涨，所以在人民币升值最厉害的07年，楼市股市都在那里飙涨。如果你也跟着投资的话，可能就是这轮涨价的受益者；但也许你是受害者，因为房价高了，你可能发现凭自己的那么一点儿工资只能望楼兴叹了。 所以看来还真得学点经济学，未雨绸缪，知道其中的利害关系，以更好地为自己打算。 第一部分 第8节：消费理财–生活中要懂的25个经济常识(1) 第一讲：消费理财——生活中要懂的25个经济常识 清晨开门七件事，柴米油盐酱醋茶 保险 【点睛】我们深知大局，可惜不能预见未来。 【释义】保险是以契约的形式确立双方经济关系，以缴纳保险费建立起来的保险基金，是一种对保险合同规定范围内的灾害事故所造成的损失进行经济补偿或给付的经济形式。保险可分为社会保险和商业保险，社会保险由政府主导，而商业保险则由被保险人向保险公司购买。 【谈古说今】某兵营曾经流行这样一种游戏：上级军官每年一次召集部下1000人，发给每人一把手枪，并告诉他们，这1000把手枪中只有3把枪有真的子弹，要求他们每人朝自己的脑袋上开一枪，作为奖赏，他可以在余下的一年里吃好喝好，并得到大量的奖金。这样的游戏，每年都要进行一次。各位，如果你是军队中的一员，你敢玩这样的游戏吗？你敢朝自己的脑袋上开一枪吗？每年都开一次？ 其实在生活中，我们所有人每年都在玩这样的游戏，只是我们没有意识到：根据中国人的生命表统计显示，在一年之中，每一千个人都会有三个人因为各种各样的原因死去。有人说千分之三的概率很小，因为1000人之中才只有3人。有人说这个概率很大，因为对个人来说，如果发生了就是100%。 其实大多数人都是厌恶风险的，比如有两种选择，一种是你有90%的概率拥有1000万，10%的概率一分钱没有；或者你可以确定无疑地拥有900万。你选哪个？大多数人都会选择后者，虽然两种方案的期望收益是一样的，但是人们厌恶不确定性，厌恶风险。 正因为人们厌恶风险，所以产生了保险这个行业。如今保险已经成为美国人生活中必不可少的一部分，人寿、医药、房屋、汽车、游船、家具等等都可以保险，这样就能最大程度地消除不确定性，抵御各种潜在风险带来的灾害。但是中国人还没有购买保险的习惯，大多数人认为买保险是一种很晦气的事，不愿意去面对可能的风险。有次中国的珍稀动物金丝猴到日本去展览，日本方面给金丝猴买了一份10亿日元的保险，而护送金丝猴的中国工作人员却一分钱的保险都没有，不得不让人感慨人的命还没有只猴子值钱。 其实人的生命和健康都是无法估价的，只是过去大多数人们处于饥饿或仅能维持温饱的状态，生活本身就很艰难，哪还有心思花钱去买那些看不见摸不着的保险呢？但是随着中国经济的不断发展，越来越多的人富起来之后，就会去想如何使自己辛辛苦苦积攒起来的财富不出差错，不会因为一个地震或一场大火而瞬间消失。所以在中国保险是个朝阳行业，还有很多的潜在市场，未来的保险业还有很大的发展空间。 股票 【点睛】上联：两年千六上六千，心血澎湃下联：一年六千下千六，捶胸顿足横批：疯狂历练。 【释义】股票是一种出资证明，当一个自然人或法人向股份有限公司投资时，便可获得股票作为凭证，并以此来证明自己的股东身份，享受股东所具有的参与企业决策、分享企业利润等权利。 【谈古说今】股份制企业是改革开放以后才在我国出现的一种企业所有制，也就是多个自然人或法人按出资额占有一定比例的股份。这种企业在世界上已经有了将近400年的历史了，它是伴随着企业经营规模的不断扩大与资本不足而产生的。伴随着股份制的发展，股份交易转让的需求出现了，所以有了股票交易市场。股票的买卖，其实和大白菜的买卖有很多相同之处，只是大白菜值多少钱一眼就能看出来，而一家公司的股份值多少钱可不是那么容易发现的，所以就出现了那么多专门靠发现股票价值来吃饭的人。 在股票市场上有这样一群神秘的自然人，他们不是机构，却资金雄厚；他们眼光独特，因为手中的股票常常是翻N倍上涨，他们就是不为人们所知的超级散户！套牢千万散户的资本市场为何会对他们网开一面？下面我们来看超级散户刘元生的生财之道。 刘元生，香港人，持有万科股票达20年，投入400万，按照2008年6月的股价计算，他所持有的万科股票市值已经达到16亿，翻了400倍！这样的收益率不得不令人叹为观止，就连世界投资大师巴菲特最得意的一次投资《华盛顿邮报》，30年也才翻了128倍。 第一部分 第9节：消费理财–生活中要懂的25个经济常识(2) &quot;浮华过后，真金始现。&quot;这句话用在刘元生投资万科最为贴切。刘元生本是香港的一位商人，早在王石创建万科前，他们就已经是商业合作伙伴。王石做录像机生意时，刘元生的公司就为其提供日本货源，两人结下深厚的友谊。1988年12月末，万科共发行2800万股，每股1元，当时万科净资产只有1324万元，为了推销股票王石亲自上阵，在深圳闹市区摆摊，还去过菜市场，跟卖白菜的大娘们一起叫卖。最后还是没有完全卖出，刘元生出于兄弟义气就买了360万股，在之后的年月里又增持了一些。 1991年，万科上市，成为深圳最早的&quot;老八股&quot;之一。以后这么多年的市场沉浮，股票市场的纷纭变幻都没有动摇刘元生的持股信心。如今经过无数次配股，送股，刘元生持有万科的股份已经达到8000多万股，成为第三大流通股股东。如今刘元生已经成为中国市场上最富有的散户。 基金 【点睛】集腋成裘，聚沙成塔，滴水成&quot;金&quot;——基金的投资理念，不是一夜暴富，而是跑赢时间，跑赢货币贬值和通货膨胀。 【释义】基金在广义说是机构投资者的统称，包括信托投资基金、保险基金、退休基金、慈善基金等。狭义的基金主要指证券投资基金，是将众多的投资者的资金集中起来，形成独立资产，由基金管理人管理，以投资组合的方法进行证券投资的一种投资方式。 【谈古说今】买基金还是买股票，很多个人投资者对此总是犹豫不决，一方面承认自己不如那些专门搞投资理财的人专业，另一方面把钱拿给别人去投资自己又不放心。下面看看投资者小刘的基金之路。 小刘和大多数人一样，拿不准自己炒股还是交由基金打理，于是做出一个近乎完美的决定，一半资金交由基金打理，一半用来自己投资，比一比，赛一赛，看谁的收益高。多年的实践，最终证明半个基民远胜半个股民。 2001年9月，股市见顶2245点，随后步入漫漫熊途。不巧，小刘就是在这么一个最高点兴冲冲地入了市。当时基金通乾通过网上申购，上市首日最高价1.05元，最低0.99元，小刘在当天花了2万元，买了两万份，接下来就是痛苦的等待和煎熬。到了2005年9月，基金通乾拦腰截断，跌至0.46元。小刘的基金面值跌得一万都没有了，但他咬咬牙坚持住了，没有卖掉。再后来慢慢开始反弹，小刘在0.5元的价位上又买入了4万份，总共持有6万份，本金4万元左右。之后股市一路走牛，在2006年12月、2007年4月和9月给予了三次分红，每份各分得0.14元、0，16元和0.3元，共得红利3.6万元。此外按照2007年12月1日，每份2.2元计算，市值13.2万元，加上红利，除去本金，净得12.8万元，翻了两倍多。而小刘炒股的业绩相比之下，逊色很多，几经浮沉，虽然最终没有亏钱，但是也没有赚到，而且劳神费力。 第一部分 第10节：消费理财–生活中要懂的25个经济常识(3) 但是能像小刘这样一持有就是六年的人又有多少呢？大多数人都受不了市场的涨涨跌跌，过早出局了。其实投资基金，心态很重要，要以储蓄的理念，不计较短期的波动，才会真正迎来属于自己的春天。 复利 【点睛】复利是世界上第八大奇迹——爱因斯坦 【释义】复利就是将每一期的利息加上本金计算新一期的利息，如此不断循环。计算公式为S=P*（1+i）^n. 【谈古说今】不知大家有没有看过一部叫做《漂流瓶》的电影，是一部很老的片子，讲的是八十年代，有个暴发户看上了一位漂亮的姑娘，想娶这位姑娘，于是跟她说，我有的是钱，你开个价吧。这个姑娘说想娶我很简单啊，我要求不高，你只要给我一个月的钱就可以了，第一天你给我一分钱，第二天你给我两分钱，第三天你给我四分钱，以后每天给我的钱是前一天的两倍，只要坚持到30天，我就嫁给你。大款说一言为定，这太简单了，我现在就都给你吧。于是拿出一个计算器，开始计算，到了第二十天的时候大款开始害怕了，当算到第二十五天的时候，汗就不停地往下滴了，到了第三十天时，大款彻底的崩溃了，因为仅仅一个第三十天，大款就要支付1074万块钱。对于那个时代来说，1000万可是连想都不敢想的数字啊。 从这里我们可以看出复利的威力，虽然刚开始的起点不高，但是经过多次的放大后，将会是一个十分巨大的数字，难怪连爱因斯坦都惊呼，&quot;宇宙间最大的能量是复利，复利是世界的第八大奇迹！&quot;这让我想起了一个真实的故事。1626年，荷属美洲新尼德兰省总督PeterMinuit花了大约24美元从印第安人手中买下了曼哈顿岛。而到2000年1月1日，曼哈顿岛的价值已经达到了约2.5万亿美元。只用24美元就买下了曼哈顿，PeterMinuit无疑占了一个很大的便宜。 可是换个思路想想，或许这位总督并没有占到便宜。如果他拿着这笔钱去投资，按照美国近70年来股市的平均收益率11%来计算的话，到2000年，这24美元将变成23.8万亿美元，远远高于曼哈顿岛2.5万亿的价值。如此看来，PeterMinuit还是吃了大亏了。 复利的惊人能量就是在于它不停地利滚利，每年都有一定比例的增加，从而即使很小的基数在数轮之后也会变得很大。沃伦·巴菲特年收益率23%，几十年之后成为了世界上最富有的投资人。 其实复利就像我们的人生，虽然有时我们的起点不高，可能也没有很好的机会一步登天，但是只要不断地去努力，去追求，每天都能进步一点点，相信终有一天我们会步入成功的殿堂。 财产性收入 第一部分 第11节：消费理财–生活中要懂的25个经济常识(4) 【点睛】经济发展了，时代变化了，人人都可以做回资本家了。 【释义】财产性收入是指通过资本、技术和管理等要素与社会生产和生活活动所产生的收入。包括银行存款、有价证券等动产和房屋、收藏品等不动产所获得的收入。包括出让财产使用权所获得的利息、租金收入，还有财产运营所获得的红利收入。 【谈古说今】&quot;创造条件让更多的群众拥有财产性收入&quot;只是胡锦涛同志在中共十七大报告中的一句话，但是这却是一个重大的突破。原先，那些财产性收入被认为是资本，是用来获取剩余价值用的，是不劳而获，是耻辱，是罪恶，应该被全人类鄙视。但是十七大的这个主题给我们传达了什么信息呢？那就是剩余价值不能只由资本家获取，我们群众也可以并且应该分享。 我们居民的人均可支配收入由四个方面构成的，包括工资性收入、转移性收入、经营性收入、财产性收入。国民收入的绝大部分是工资性收入，约占到总收入的70%，而财产性收入太少了，只有区区的2%，这与发达国家是没法比的。以美国为例，他们民众的财产性收入占到总收入的40%，拥有股票和基金的人占到总人数的90%——怪不得人家那么富裕，40%的收入都是&quot;不劳而获&quot;得来的，再加上工资，当然很有钱了。 根据胡润排行榜，2005年，第100位富豪的资产是17个亿，但是七年前胡润排行榜刚出炉时只有5000万元，中国富豪财富膨胀之快，令人瞠目结舌。根据胡润排行榜的披露，这些富豪绝大部分都拥有上市公司，其中相当一部分涉及房地产。你的工资涨得有这么快吗？你终于知道为什么一直都缺钱花了吗？问题就在于财产性收入。富人们一般都有很多财产性收入，他们拥有股票、地产等，可以让他们的资产为他们牟利，可以通过获取工人的剩余价值致富，而不仅仅是出卖劳动力。所以胡锦涛的意思很明了，你们不要再只依靠工资生活啦，也去和资本家一起分享利润吧。 话虽这么说，事实又是另一回事。你想中国民众傻啊，有利润不去分享，只有富人聪明？当然不是。关键是十个炒股九个亏，买了地产又被套牢，这个市场忽左忽右，让人捉摸不定，这些财产性收入不是搞得你神经崩溃就是倾家荡产，谁还敢去碰啊。所以目前最重要的还是要健全市场体系，让市场变得更加透明更有效率，更加理性也更成熟，能够照顾到中小股东的利益，才能真正像美国那样，大幅增加人民的财产性收入，让经济发展带来的好处全民共享。 大小非 【点睛】百花发时我不发，我若发时都吓杀。 【释义】大小非中的非是指非流通股，也就是不能在证券市场上自由买卖的股票。大非是指占股本比例较大的非流通股，一般占总股本5%以上，小非指则占总股本5%以下的非流通股。 第一部分 第12节：消费理财–生活中要懂的25个经济常识(5) 【谈古说今】大小非是中国证券市场上出现的特有现象，在国外成熟的资本市场上股票都是可以自由流通的。九十年代初期，中国要建立一个股票市场，来达到优化资产配置，提高闲散资金使用效率的目的。但是问题在于，很多大型国企都控制着国家的经济命脉，关乎国家的经济安全，如果把这些企业都变成股票去发行，万一被外国的资本家全买走了，那还了得？最后想出来的解决办法就是：企业70%的股票不流通，剩下的30%在证券市场上流通，这样即使30%全被外国人买走了，控制权也仍在我们手里。 假如某个大型企业有10000万的净资产，将其划分为10000万股，那么每一股的股东就拥有1元钱的净资产。这时在证券市场上发行3000万股，每股10元，便可募集到3个亿的资金。你可能会奇怪为什么一股不是1块钱而能卖到10块钱呢？因为决定股价的不是净资产额，而是预期将来股票收益的折现值。公司有了资金便可以进行大规模的扩张和发展，而股东则由两部分构成，一部分是非流通股股东，另一部分是可流通股股东。 这个设想本来很完美，又能募集到资金，又不失去控制权，但真这么做了，才发现问题很大。由于大部分股权是非流通股，其中的绝大部分由国家控制，那些流通股的股东根本说不上话。这些大股东要是能代表所有股东的利益，好好经营公司倒也罢了，可是偏偏又不是，因为非流通股不能上市套现，所以他们根本不在乎公司在证券市场上的股票价格。可是那些可流通股股东就不一样了，他们投资就是为了股票价格上涨，获取收益，这样就导致不同类型股东之间利益的冲突，这些没有话语权的流通股股东的利益经常受到损害，久而久之就没有人愿意投资了，所以2005以前，中国的证券市场一直比较低迷。 有了问题那就要解决啊，为了提高证券市场的效率，就得让非流通股逐渐地转化成流通股，也就是我们常听到的股权分置改革，至于控股股权问题，只要国家不卖掉手中的股票，别人自然也无法买到。就这样大小非解禁就粉墨登场了，照规定小非在股权分置改革一年后方可流通，大非要在两年后才能流通。 通常非流通股解禁后，大股东就有可能抛售股票进行套现，这往往会造成股价下跌。但是也不是绝对的，那些业绩较好、具有发展前景的公司，在解禁后还有可能股价上涨，因为在解禁前人们对解禁的预期已经使得股价下跌了，解禁后若没有大规模套现行为，股价自然就会回升到原来位置。不过有一点可以肯定，那就是大股东是否套现很大程度上可以看出公司的经营状况，因为他们是这家公司的管理者，是对公司最为了解的人。 第一部分 第13节：消费理财–生活中要懂的25个经济常识(6) 股指期货 【点睛】现在的买卖，交易的可以不是现在的商品，甚至可以不是实实在在的商品。 【释义】股指期货是指以股价指数为标的物的标准化期货合约。双方约定在未来的某个特定时间，按照事先确定的股价指数的大小，进行标的指数的买卖。作为期货交易的一种类型，股指期货交易与普通商品期货交易交易具有基本相同的特征和流程。 【谈古说今】股指期货和普通期货一样具有套期保值的功能，但是如果拿来投机的话也具有风险性，这方面最好的例子莫过于巴林银行的倒闭。 巴林银行是英国的一家老牌银行，始建于1763年，创始人弗朗西斯巴林爵士，由于经营灵活，富于创新，很快在国际金融领域获得巨大成功，就连英国的王室也都是它的客户。由于巴林银行的杰出贡献，巴林家族史无前例地获得了英国王室授予的五个世袭爵位，成就了巴林银行显赫的地位和荣耀。然而这个具有233年历史、在全球范围内掌控270多亿英镑资产的巴林银行，却在1995年，被一个28岁的年轻职员给弄垮了，此人就是因投资日经225指数这个品种的股指期货造成了无法挽回的损失。 此人的名字叫里森，是巴林期货新加坡公司的职员。自1994年下半年起，里森判断日本经济已经走出低谷，将走上复苏阶段，认为日经指数将上涨，于是逐渐买入日经225指数期货。不料1995年1月17日关西大地震后，日本股市反复下跌，里森的投资损失惨重。里森当时认为股票市场对神户地震反映过激，股价将会回升，为弥补亏损，里森一再加大投资，在1月16日~26日再次大规模建买入，以期翻本。其策略是继续买入日经225期货，其日经225期货头寸从1995年1月1日的1080张合约增加到2月26日的61039张。据估计其合约平均买入价为18130点，但是2月23日，日经指数再次急剧下挫，合约收盘价跌至17473点以下，导致累计亏损达到了480亿日元。再加上来自日本政府的债券的空头期货上的损失，巴林银行已经无法招架，只有破产了。 那么为什么当里森遭到亏损时，没有人制止，还让其大规模建仓呢，难道巴林银行的管理层都不管吗？这就不得不说说88888账户了，本来巴林银行设立88888账户是用来冲抵错误的账单的。因为期货公司要执行客户的指令，有时不小心听错了，或明明是准备卖的，手一抖变成买了，这些错误的账单就拿到88888账户上冲销掉。可是这个账户刚设立好，由于某些原因没有用，但也一直没有注销。里森每次出现了亏损都往这个账户里填，而他自己的账户上却永远是保持大额盈利。 具有讽刺意味的是，巴林破产前两个月，在纽约举行的金融成果会议上，250名在世界各地工作的巴林银行工作者还将里森当作英雄，对其报以热烈而持久的掌声，这位英雄却很快就让他们都失去了工作。 第一部分 第14节：消费理财–生活中要懂的25个经济常识(7) 老鼠仓 【点睛】我们要坚持两个凡是：凡是要用公共资金买股票，就一定要为自己的资金服务；凡是要用自己的资金炒股，就一定要有百分之百赚钱的把握。 【释义】老鼠仓是指证券从业人员在用公有资金拉升股价之前，先用私人的资金在低位建仓，待用公有资金拉升到高位后私人仓位率先卖出获利。目前很多基金就存在着老鼠仓现象，由于基金募集的资金数额巨大，能够有效拉升股价，更好地建立老鼠仓。 【谈古说今】2009年4月，证监会对融通基金原基金经理张野可能涉及老鼠仓进行立案调查。最终决定取消张野基金从业资格，没收其违法所得229万元，并处400万元罚款，同时对其实施终身市场禁入。融通基金亦被证监会基金部责令进行为期6个月的整改。 这次老鼠仓事件是继2008年王黎敏老鼠仓案和唐建老鼠仓案之后的又一起有关基金公司的老鼠仓案件。下面我们看看这个老鼠仓操作的细节。 在2008年广州冷机这家上市公司的年报中，前十大流通股股东排名中，融通新蓝筹位列第一，拥有435.89万股。周蔷这个账户位列第七，持有99万股，获利600万左右。根据川化股份2008年的年报显示，流通股前十大股东中，融通新蓝筹位列第三，持有323万股，周蔷账户位列第六，持有138.5万股，估计获利约为500万元。 2009年4月9日，有媒体曝光神秘散户&quot;周蔷&quot;多次领先融通基金买入卖出，怀疑有可能是老鼠仓。证监会很快做出反应，对周蔷这个账户进行彻查，发现周蔷的账户由朱小民控制着，朱小民是一个大户。然而朱小民为什么能每次都先于融通基金买入卖出呢？调查发现，朱小民将账户交由融通基金的基金经理张野操作。短短两年时间，张野利用职务上的便利获取非公开的基金投资与推荐信息，通过网上交易，为朱小民操作周蔷账户，获利达939.84万元。为表示感谢，朱小民给了张野200万元的感谢费。 但是张野所掌管的是一只指数型基金，也就是说，只要平均持有指数所包含的股票就行了，不需要选股，也不需要频繁操作。那么张野又是如何获利的呢？原来他利用自己基金经理职务上的便利，在参加融通公司投资决策委员会会议、基金晨会、投研例会等会议时，获取融通公司旗下基金投资的内幕消息。他的老鼠仓共染指融通基金旗下10只基金中的6只，包括领先成长、动力先锋、巨潮100、新蓝筹等，可谓涉猎广泛。 张野没有职业操守，私建老鼠仓被处罚，自然大快人心，但难道目前建老鼠仓的就只有张野一人么？那些没被发现的老鼠仓如何才能被消灭，中国的基金业何时才能获得基民的信任呢？ 第一部分 第15节：消费理财–生活中要懂的25个经济常识(8) 印花税 【点睛】印花税是一种良税，政府可以用它来拔最多的鹅毛，但听到最少的鹅叫。 【释义】印花税是以经济活动中签订的各种合同、产权转移书据、营业账簿、权利许可证照等凭证文件为对象所征的税。比如甲将其手中的股票转移给乙，就属于产权转移，需要缴纳印花税，这种印花税称为证券交易印花税。 【谈古说今】公元1624年，荷兰政府入不敷出，财政相当困难。当时的统治者是莫里斯，他为了解决财政上的困难，决定增加税收，但是又害怕人民反对——看来不光李世民懂得水能载舟亦能覆舟的道理啊——于是他找到大臣们商量，最终商量的结果是用公开招标的方法来征集好的税收设计方案。印花税就是从千万个应征方案中挑选出来的&quot;良税&quot;。 为什么偏偏选中了印花税了呢？因为在日常生活中，人们经常使用契约、借贷凭证之类的单据，所以税源应该很大。而且老百姓都希望在自己的契约上能盖个政府的公章，那样有政府的承认就保险多了，在发生纠纷时就有法律保障了，所以人们就会主动前来纳税，便于征集。自此以后各国相继效法，印花税逐渐成为世界各国普遍采用的一种税种。 其实印花税不仅仅具有增加政府财政收入的作用，它还是政府调控宏观经济的重要手段。当政府感觉房价涨得太快，交易过于频繁的时候，将房产转让时的印花税调高点，这样炒房的成本高了，交易自然少了。中国的股市自2006年一千点左右开始上涨，到2007年初连续跨过2000点，3000点的整数关口。证监会感觉这太高了，投机的气氛太浓烈，于是发动一场对投资者的风险教育活动，各种风险教育的文章贴满证券监管部门的网站。可惜中国的股民都知道有风险，但他们更知道没有风险就没有收益，仍旧继续买入。到5月底，上证指数已经大步跨过了4000点。政府见一招不成，又来一计。毕竟政府的智囊团可不是吃干饭的，他们很清楚这时该下啥药，下几钱药量。于是2007年5月29日晚上12点整，证监会网上风险教育的文章忽然集体失踪，取而代之的是一则通告：从即日起，证券交易印花税由千分之一上调至千分之三。就这么一句话，5月30日沪深两市一开盘，上千只股票的股价犹如大坝决堤，一泻千里。当日上海交易所内的股票跌去6.5%，深证交易所得股票跌去6.16%，股票的涨跌比例是1：14，一万亿的市值一天之内蒸发殆尽，也就是所有的投资者一天之内共损失了一万亿，这次大跌被广大投资者称为证券市场上的&quot;五卅惨案&quot;。证监会用这种近乎惨烈的方式给广大的投资者上了一堂风险教育课。 道·琼斯指数 第一部分 第16节：消费理财–生活中要懂的25个经济常识(9) 【点睛】道琼斯指数就像华尔街的温度计一样，反映股票市场整体的涨落。 【释义】道琼斯指数又称股票价格平均指数，是世界历史上最为悠久的股票指数。按照行业类别共分为工业股票价格平均指数、运输业股票价格平均指数、公用事业股票价格平均指数和平均价格综合指数四种。通常人们所说的道琼斯指数一般是指道琼斯工业股价平均指数。 【谈古说今】道琼斯指数是世界上最早的股票指数，由道琼斯公司的创始人查理斯·道开始编制的。在当时已经有多家报纸开始每天公布主要股票的价格变化情况，但是单看那些数字很难明白市场整体的走势。仅仅读过小学的查尔斯·亨利·道通过编制股票价格平均指数，用非常简便的方法天才般地解决了这个问题。其计算公式为：股票价格平均数=入选股票的价格之和/入选股票的数量。 1897年，道琼斯股票价格平均指数开始分为工业与运输业两大类，其中道琼斯工业平均指数最初包含12种股票，这些股票的发行公司都是本行业具有重要影响的著名公司，具有很强的代表性。为了保持这些特点，道琼斯公司对其编制的股票价格平均指数所选用的股票经常予以调整，更具活力和代表性的公司股票去代替那些已失去代表性的公司的股票。1928年10月1日起其样本股增加到30种并保持至今。 但是由于道琼斯工业股票价格平均指数是一种成分股，只包含30种股票，仅为上市交易的股票中的一小部分，而且未将近年来发展迅速的服务型行业的公司包括在内，所以其代表性也经常受到人们的质疑。相对来说另外一种股票价格指数标准·普尔则更具有代表性。标准·普尔指数是由美国标准普尔公司于1923年开始编制，最初选了230种股票，到1957年扩大到500种并保持至今。其中有90%在纽约证券交易所上市，还包括其他交易市场的一些股票，所以它的代表性要比道琼斯指数广泛些。但是从实用性角度，大多数投资者还是喜欢道琼斯指数。 【知识链接】上证综指是以上海证券交易所挂牌的全部股票为计算范围，以发行量为权数加权综合股价指数，全面地反映了证券市场上的股票价格总体变化情况。深圳综合指数也是一样，他们都是中国股市的温度计和经济的晴雨表。 私募基金 【点睛】少数富人以钱生钱的游戏。 【释义】私募基金是指通过非公开发行的方式，面向少数特定的投资者募集资金的基金。私募基金是相对于受政府主管部门监管的、向不特定投资人公开发行的公募基金而言的。由于监管环境宽松，信息披露不严格，所以私募基金的操作更为灵活，市场嗅觉更为灵敏，投资回报也相对较高。 第一部分 第17节：消费理财–生活中要懂的25个经济常识(10) 【谈古说今】私募基金一般是向特定的投资者发行募集的，进入门槛比较高，在国内至少是50万，一般都是100万甚至更高。但是一支基金的人数一般比较少，最多只能有200人，所以一般面向的都是一些资金实力较为雄厚的投资者。公募基金可以在市场上做广告来吸引大众认购，相对门槛也较低，一般1000元左右即可认购。但是由于认购的人多，公募基金的整体资金规模非常的大，基金管理者就靠收取资金的管理费为生。而私募一般都不设管理费，他们的赚钱手段就是盈利的分成，而且管理人一般都要以自有的资金认购一定的基金份额，当基金发生亏损时就先用自有的资金弥补亏损，所以管理人的利益与投资的利益能很好地结合在一起，对管理人是很好的激励。再加上监管环境比较宽松，不像公募那样要定期披露，还要规定持股比例的上下限等，所以私募一般的收益率都会高于公募，而且嗅觉灵敏，手法灵活。精准、暴利、神秘成了私募的代名词。 纵观国际市场，虽然没有私募这么一个名词，但是一般的对冲基金本质上就是私募，鼎鼎大名的量子基金、老虎基金都属于此类。而面向大众投资者的共同基金就是我们常说的公募基金。在1995-2000年间表现最好的10只对冲基金的平均收益率达到53.6%，而表现最好的10只共同基金平均收益率只有36%；表现最差的十只对冲基金平均收益率为-7.7%，而相应的共同基金为-19.8%。所以可以看出在美国也是一样，私募基金的平均收益率高于公募基金。 但是针对私募的法律法规还不是很完善，已经成为国内私募行业发展的最大瓶颈，私募的存在一般都是通过很多变通的方式，比如投资人一起出资组建一个投资公司，再委托个管理人，然后用自有资金投资，但这样要双重征税，而且手续麻烦。要是各个投资人将账号和密码告诉管理人，让其操作又属于代客理财，需要受到较严厉的监管和信息披露。总之，政策的缺失仍是私募人的一块心病。 负利率 【点睛】如果说通货膨胀是彪悍的带头大哥，那么负利率就是尾随其后的提鞋小弟。 【释义】负利率指通货膨胀率高于银行的存款利率，导致最终的实际利率为负的情况。 【谈古说今】当通货膨胀率高过银行利率时，居民在银行的存款所收到的利息不足以抵消物价上涨造成的损失，就会导致财富缩水。在负利率年代，最开心的是企业和政府，因为他们是主要的借款者。由于实际利率为负，他们还款的实际金额比当初借的时候还要少。而最苦的是老百姓，因为他们是社会的主要存款者，他们把钱借给了企业和政府，到期收到的还款比借出时还要少。所以负利率本质上就是将老百姓的财富转移到企业和政府手中，是一种看不见的剥削和掠夺。 第一部分 第18节：消费理财–生活中要懂的25个经济常识(11) 眼看钱放在银行里变得不值钱了，大多人就会想着把钱拿出去投资，这就相当于逼着老百姓去投资。对于那些有理财意识和能力的人来说倒还好，可是对于那些以前整天将钱存银行里勤俭持家的人来说可就是赶鸭子上架了，搞不好财越理越少。 负利率基本上都是通货膨胀导致的，那可能有人会问央行直接加息使存款利息高于通货膨胀率不就行了嘛？你要知道当存款利息上调时，最痛苦的是银行了，中国的几大国有银行没有其他的业务本领，只能靠存贷款利率差来赚钱。这要是把存款利率上调了，可就要了他们的老命，弄不好再多些坏账，让你政府去擦屁股吧。所以要上调的话就存款利率和贷款利率一起上调吧，但是你知道贷款的都是谁吗？他们主要是房地产商，还有很多大型国企，那些人牛啊，要是触犯了他们的利益必然会遭到强烈的抵抗和反对。什么会使投资环境恶化啊，会不利于经济健康发展啊，什么理由都出来了。所以你发现从2007年初开始，一直到2008年11月，连续22个月居民的存款利率一直是负的，这样负利率的过程是一个财富再分配的过程。 总之，负利率的社会影响很不好，它不但是财富再分配的过程，而且会扭曲资金的成本，使过多的资金涌入股市，造成股市的虚假繁荣，不利于中国证券市场的长期健康发展。 经纪人 【点睛】一群拥有政府颁发的执照，并且更加专业的黄牛。 【释义】经纪人指证券、商品或其他品种交易双方的中间人。在投资领域内经纪人可以为一家证券经营机构法人或经注册与证券公司合作的个人。经纪人不拥有所交易品种，只是作为买卖双方的代理进行交易并根据服务收取佣金。 【谈古说今】各行各业都存在着经纪人，文艺圈里存在着明星经纪人，地产领域有房产经纪人，投资领域有证券交易经纪人。他们不单单是撮合买卖双方达成交易，更是本行业的专家，能够理性地对业务进行估值，并为客户提供专业的咨询和建议。 照着上面的分析，撮合交易的达成，再从中抽取一部分佣金，很容易让我们想起&quot;黄牛&quot;。是的，其实经纪人和黄牛有很多相同之处，只是黄牛没有执业资格，而经纪人是通过国家工商行政管理机关的考核和批准，取得经纪执业证书的专业&quot;黄牛&quot;。在欧美国家和香港地区，经纪人的地位非常高，很多客户直接找到经纪人，然后就将自己的财产委托给经纪人打理。所以如果能遇到优秀的经纪人，无疑相当于挖到了一座金矿。而且行业里的经纪人也都十分看重自己的名声，因为这是他们的立命之本。 在国内，这个行业还不是很成熟，还没有出现一批专业化的证券经纪人队伍。现在一般是某券商为扩展自己的业务，招聘大量的销售人员，这些销售人员就会自称为经纪人。实际上，如果按照国际通行定义，他们算不上经纪人。因为首先他们不独立，必须挂靠券商，通过券商的平台进行交易，而真正的经纪人是可以选择任何一个客户喜欢的券商进行交易的，他们与券商之间没有太多的利益关联。其次，目前国内的券商销售人员素质明显跟不上，他们大多数是从事证券行业1~2年的年轻人，时间稍长点就俨然是&quot;资深人士&quot;，最主要的工作是为券商拉客户过来开户，他们与经纪人唯一的相同点就是靠交易佣金吃饭。最后一点，也是最关键的一点，就是券商一般都会禁止销售人员为客户提供交易的操作意见。因为他们很不专业，如果照其建议进行操作，后果可能非常悲惨。 第一部分 第19节：消费理财–生活中要懂的25个经济常识(12) 目前国内券商们的通行做法就是人海战术，他们的理念是招的越多就会有越多的人为自己卖命，为自己卖命的人越多就意味着客户越多。成本也不高，除了极低的保底工资，销售人员的收入主要是佣金提成，而若连续几个月没有达到规定的业务量就会被开除走人。这样很难形成专业、成熟的经纪人队伍。令人欣慰的是，国家目前已经开始行动了，规定证券经纪人必须要通过证券从业资格证的考试，要有相关的知识，这对经纪人队伍的规范有着重要的作用。 消费券 【点睛】谁说伪钞不来劲，有我大家都高兴。 【释义】消费券是一种专用券，一般是由政府发放，用来在经济低迷时，增加居民的购买力和消费欲望，从而达到刺激消费，振兴经济的目的。消费券有时还限定所能购买的商品种类和地点，具有不可兑现、一次性使用、不找零的特点。 【谈古说今】2009年春节前后，杭州市政府发放了一个亿的带有红利性质的居民消费券，主要面向企业退休人员、特困户、残疾人和在校中小学生等一些传统意义上的弱势群体，受益对象达132万人。 消费券的面值为20元，使用期三个月，过了使用期，消费券的适用范围就会大大缩小，三个月内可在100家店使用，过期后，可能只能在20家店使用。消费券使用范围很广，包括文化娱乐、交通、体育、购买本地产家电、旅游产品等五大类。 对于市民来说，平白无故多了些消费券，可以拿去买东西，自然欣喜万分，而对于企业来说，可以消化库存，增加营业收入，加快资金流转，自然也甚是高兴，同；由于产品需求的增加，企业自然会增加产量，提高开工率，这又促进了当地的就业，杭州市政府的如意算盘打得可谓是相当的高明。 然而问题总是有的，就在推出消费券的同时，很多学者就提出质疑： 一是这个资金从何处来？一般政府资金都是通过税收获得的，所以消费券最终还是市民来买单，只不过换了种形式而已。 二是如何确保在确定受益企业名单时做到公正？因为一般消费券都规定消费的地点、时间和物品，那么在确定消费地点，消费物品时就很有可能出现腐败行为，给政府的权力寻租提供了机会。 三是这是不是存在地方保护主义的倾向呢？因为一般受益的都是本地的企业和商家，所以就有贸易保护主义的倾向，对周边的公司和企业就很不公平。 四是这小小的消费券真的可以刺激消费，增加就业么？由于消费券只具有短期功效，所以很少有企业会愿意去扩大产能，增加雇员的。 当然，问题是存在的，但是在2008年，金融危机席卷全球，使得一直是拉动中国经济增长动力之一的出口受到严重的影响，作为出口重地的杭州自然也不能幸免，所以在这样的背景下杭州市政府采取了发放消费券的政策，希望通过拉动内需来振兴经济的尝试还是值得我们去鼓励的。 第二部分 第20节：投资管理–企业经营要懂的22个经济常识(1) 第二讲：投资管理——企业经营要懂的22个经济常识 看谈笑间，樯橹如何灰飞烟灭 天使投资 【点睛】你烧青春我烧钱。 【释义】天使投资又称风险投资，是指投资公司在企业的起步阶段对其进行投资以获得企业的部分股权，然后通过企业的上市或者股份转让实现退出盈利的投资方式。这对投资人的眼光、资源、资本运作能力有很高的要求。 【谈古说今】天使投资在国内起步较晚，20世纪90年代末才出现一些本土的天使投资基金。近年来伴随着中国经济的快速发展，市场容量的快速扩大，中国已经成为天使投资基金的种子基地了。目前国内的投资基金主要有本土的弘毅投资、联想投资、鼎晖投资等，还有外来的红杉资本、IDG风险投资、高盛、摩根和软银亚洲。大名鼎鼎的蒙牛乳液、分众传媒、南孚电池、盛大集团、阿里巴巴、如家连锁酒店等上市公司都是这些风投的杰作。它们以几倍，十几倍甚至几十倍的收益率创造着一个又一个资本界的神话。下面让我们来揭示软银亚洲投资盛大猛赚16倍的全国过程。 1999年，陈天桥创建盛大，注册资金50万，购买固定资产30万，手里只有20万，眼看就要关门歇业。 1999年底，中华网CEO叶克勇，作为天使投资人，投资盛大300万美元。陈天桥把它拿来扩大规模，发展动漫，一份钱没赚到。 2000年末，互联网泡沫破灭，中华网看陈天桥不行了，第二年撤资，按照协议留给陈天桥30万美金。 2001年，韩国游戏代理商ACTOZ来到上海，将一款二流网络游戏介绍给陈天桥运营。陈天桥利用仅有的30万美金，签了合同。然后空手套白狼，先试用了中国电信的带宽和浪潮戴尔的服务器。 2001年9月8日，游戏上线，供玩家免费公测，玩家人数飙升，让人目瞪口呆。 2001年11月8日，开始收费，在线人数突破40万。 2002年，营业收入超过6个亿。天使投资人纷纷找上门来，要求投资，最终软银亚洲胜出。 2002年，由于《传奇》运营的收入大出所料，韩国游戏代理商Actoz要求分享利润，陈天桥不干，两方关系恶化，对于游戏的漏洞，韩方不管不问。9月份纠纷达到高潮。 2002年11月，软银亚洲顶着压力与满身官司的盛大签订投资条款书，出资4000万美元，占有股份21.5%。 2002年12月，软银亚洲周志雄赴韩会见Actoz的CEO，凭借软银亚州在韩国的影响力，搞定了Actoz，软银亚洲还帮助盛大梳理业务，重组业务。 2004年4月，盛大于纳斯达克上市，软银亚洲全身而退，套现5.6亿美金，两年时间投资的资金翻了14倍。 第二部分 第21节：投资管理–企业经营要懂的22个经济常识(2) 怎么样，很刺激吧，心脏不好的人可承受不起，他能让人登上山峰也能让人瞬间跌落谷底，似乎像是一场赌博游戏。但玩好这场游戏可不仅是靠运气那么简单。独到的眼光、熟练的资本运作能力、丰厚的资源等等都是你玩赚这场天使投资游戏的必要砝码。 买壳上市 【点睛】资本市场版的借尸还魂术。 【释义】买壳上市是指一家非上市公司通过购买一家已经上市的公司一定量的股票来获得对该公司的控股权，然后再通过增发股份向公众筹集资金来反向收购自己的业务及资产，从而实现间接上市的目的。 【谈古说今】如果你想在某个BBS上发表帖子，可是又没资格申请帐号怎么办呢？你可能会冲朋友要个帐号，也就俗称的小马甲，然后就可以获得浏览贴子、发表文章的一切权利了。在这里这个小马甲即代表一种在这个论坛上的权利和资格。同样的道理，一个企业或许由于建立时间不到三年，或许因为盈利能力没有达到上市标准，或者是其他种种原因，反正就是想上市但不够格，那该怎么办呢？买壳上市就是一个很好的法子。 从上面我们已经得知企业买壳上市的目的和原因，那么如何玩转这样一个看似很复杂的资本游戏呢？下面我们以2006年安华农保借壳锦州六路的案例来给大家好好分析一下买壳上市的过程。 安华农保是于2004年12月建立的经营政策性农业保险业务的全国性保险公司。到2006年，总共成立时间两年不到，所以按照证监会至少成立三年才能上市的要求，它没有上市的资格，&quot;买壳上市&quot;在这里就发挥了它的威力。 首先是控股锦州六路。安华农保和锦州六路的大股东中国石油锦州石油化工公司达成协议，收购其手中全部的锦州六路的股权，从而达到了控股锦州六路的目的。 第二步就是资产置换。这时安华农保成了大股东后已经有了话语权，他可以把锦州六路和保险不相关的资产卖掉，然后再利用锦州六路这个上市公司向市场配股筹集资金来购买安华农保下的资产，这样就OK了。 安华农保的资产就借助锦州六路这么一个壳上市了。最后只要把上市公司的名字改掉，变成安华农保就万事大吉了。 看来，买壳上市比直接的公开发行方便实用得多，那为什么大家不全部去买壳上市呢？——哦，原来它也是有缺点的： 首先，壳资源是有限的。只有那些经营不善，股价很低的上市公司才能成为壳资源，这样的壳资源才不会费太多的钱。其次，它的融资额度很小，一般比较适合小型公司。最后，财务风险很大，因为收购壳公司需要大笔资金，成本较高。所以有条件的大企业还是会选择公开发行上市的方式来进行融资。 第二部分 第22节：投资管理–企业经营要懂的22个经济常识(3) 兼并重组 【点睛】你的就是我的，我的还是我的。 【释义】兼并重组指在市场机制的作用下，一个企业通过产权交易获得其他企业的产权，并企图获得其控制权的经济行为。 【谈古说今】兼并重组是经济生活中永恒的主题。在我们的思维中，一般都是大鱼吃小鱼，有实力的企业兼并较弱的企业。然而这并不一定适用于香港超级富豪李嘉诚。在李嘉诚的发家史上，用旗下的长江实业收购巨无霸和记黄埔就是其最负盛名的一场兼并，这也是世界华商史上一次了不起的收购，这场收购战役的成功为李嘉诚问鼎华商首富宝座立下了汗马功劳。 和记黄埔是由两部分组成，一部分是和记洋行，一部分是黄埔船坞。和记洋行成立于1860年，到二战之后几经重组落入当时香港四大家族之一的祈德尊家族之手。黄埔船坞的历史可追溯到1843年，到20世纪初已经颇具规模，拥有维修和建造万吨巨轮的能力，已然是香港三大船坞之一。在香港70年代初，祈德尊家族控制的和记洋行通过一系列眼花缭乱的收购兼并控制了黄埔和其他300家公司，而且打算筹集资金发展地产，然而过度的扩张使得它债台高筑，逐年亏损。1975年8月，为了充实资本，和记洋行以三分之一股权的代价获得汇丰1.5亿港元的注资。汇丰于1977年将其改组为和记黄埔有限公司。 李嘉诚收购战役的序幕也自此拉开。尽管汇丰物色了卫理来打理这家巨型上市公司，但是集团亏空太大，短时间内很难有起色。这一切都被李嘉诚看在眼里，此时在他心中已经有了收购的计划，大鱼吃小鱼的历史即将在李嘉诚手中被颠覆。令人惊讶的是李并未立马收购和记黄埔，而却着手收购起当时香港最大的货运港九龙仓，控股九龙仓的怡和这时候坐不住了，马上作出了反收购的反应。但是以怡和的流动资金也未必能购得足够的股票以保证绝对的控股地位，于是找了香港第一财团汇丰来帮忙，汇丰大班沈弼受人之托忠人之事，亲自出马奉劝李嘉诚放弃收购，希望他能不看僧面看佛面，卖个面子。此时的李嘉诚却秘密会见香港船王包玉刚，他深知一代船王对货运港的渴望，提出了一个一石三鸟的交易，李嘉诚将九龙仓股票转给包玉刚，而包玉刚则将和记黄埔的1000万股股票给了李嘉诚，并帮助李嘉诚收购和记黄埔，到这时李嘉诚才露出了真正的目的，而此时他的收购等于成功了一半。 接下来，李嘉诚以虚打实，放弃收购九龙仓，给了汇丰面子，汇丰自然会回报一份人情，与此同时船王包玉刚也正凭借其与汇丰深厚的关系在其中斡旋，李嘉诚仅以7.1元每股就获得汇丰手中9000万股和记黄埔的股票，是当时市价的一半！而且汇丰还同意李嘉诚只要先付20%的定金，相当于用2400万美金作定金购得十多亿美金的资产。这样一来，加上从船王包玉刚那里购得的股票，李嘉诚共持有和记黄埔39.6%的股权，从而达到了成功控股的目的。李嘉诚旗下的长实资产仅6.93亿，却控制了62亿港元的和记黄埔，成为香港第一个控得洋行的华人。消息传出，整个香港轰动了，各路媒体纷纷报道，李嘉诚的事业也从此飞速发展。 第二部分 第23节：投资管理–企业经营要懂的22个经济常识(4) 在整个收购过程中，李嘉诚展示出了超凡的精明。九龙仓是一间家族企业，想收购必然会受到家族势力的顽强抵抗，代价会很大，而和记黄埔作为一间公众公司，只要照顾好各方利益，就可以兵不刃血的拿下，他是把骨头留给包玉刚啃，而把肉留给自己吃。可见兼并重组可能毁掉一家公司，也会使一家公司快速发展，关键就是看收购的水平和收购后资产整合的能力了。 坏账损失 【点睛】只有等退潮的时候才知道谁在裸泳。 【释义】坏账损失是指企业确定不能收回的各种应收款项，可能是因为债务人死亡、破产或者无法偿还。一般主要的坏账损失包括企业的应收账款、银行贷款等。 【谈古说今】一般企业在销售过程中都是先把货发给经销商，然后经销商会说：&quot;哎呀，你看现在东西不是还没卖出去嘛，手里没钱啊，我等等就给你货钱啊。&quot;企业为了能够销售更多的产品也就默许了，等等再拿钱，就这样形成了应收账款。可是忽然间这个经销商跑了，或者没钱还了，那完蛋了，钱收不回来就形成了坏账损失，要从当年的盈利里面扣除的。 这是一般企业的生存之道，可是中国不愧为地大物博，啥人都有，啥事也都有。在九十年代中期，格力空调的崛起之路上，营销总监董明珠带领仅仅23人的营销队伍，抗衡别的空调厂家的千人队伍，并将格力空调做到国内的空调界老大，销售额远超竞争对手，更为神奇的是竟然没有一分钱的坏账损失！ 神奇！太神奇了！所以行里的人都称，&quot;董姐走过的路，连草都长不出来！&quot;甚至还有人特意坐飞机到格力总部看看董明珠到底是个什么样的女人。你可能很疑惑就算她再厉害也不可能做到一分钱坏账损失也没有吧？其实答案很简单，那就是先给钱，再拿货！反了，反了，这世界上哪有这么做生意的，买你东西还搞得就跟求你一样！可是历史告诉我们，没有什么是不可能的。董明珠的做法就是每个省发展一些一级经销商，然后一级经销商可以再发展二级经销商，每一级经销商的利润空间和价格都有严格的规定，要想获得更多的利润，就必须发展更多的经销商，就这样格力的经销商队伍迅速扩大，渗透力变强。就像你看到的那样，就23个营销人员，所以节约了很多经费，而这些节约下来的经费大部分返还给经销商，这样经销商能够获得更多的利润，自然趋之若鹜。即使在空调业最困难的1996年，格力销售也增长了17%。 并且董明珠的做法就是发展自己的经销网络，不依赖任何一家大的经销商。这样就保证了不会受制于经销商，自然说先付钱再拿货就有底气了。像目前中国的家电企业都会选择依靠国美这样的经销渠道，而国美为了超越竞争对手，招揽更多的客户，就会压低这些厂商的价格，更狠的是占用着巨额的货款就是不付钱，完全挟持厂商，使得厂商利润空间相当有限。而格力有自己的经销渠道，你国美再牛，我不甩你照样活，相反你要卖我的产品，你就得照我的规矩办事。 第二部分 第24节：投资管理–企业经营要懂的22个经济常识(5) 寻租理论 【点睛】对&quot;有钱就是有权&quot;这句话的深刻诠释。 【释义】租金指经济租金，在经济学里指一种生产要素的所有者获得收入中，超过这种要素应该获得的平均利润部分。寻租就是对这部分超额利润的追求。寻租是对既得利益进行分配的活动。有的官员利用手中的权力为个人捞好处，有的企业贿赂官员为本企业得到项目等，都是寻租行为。 【谈古说今】大家知道每个城市都有出租车，但并不是说你有一辆小汽车就可以去开出租，还要有政府部门颁发的牌照，否则就是非法运营，也就是传说中的黑车。既然有黑车的存在，就说明市场远远没有饱和，也就是开出租会获得超过一辆车子能够获得的平均利润。在这里，牌照就是经济租金，出租车公司可能会游说政府不要增加出租车牌照的数量，这样自己就能获得最大的利润，这个过程就是寻租的过程。当然政府限制出租车的数量可能还有他自己的理由，比如便于管理什么的，但是出租车公司对政府的影响不容忽视。 在纽约共有11787个出租车牌照，而且这个数字在50年的时间里一点都没有变化，很吃惊吧？五十年来，纽约的人口、交通、道路发生了巨大的变化，但是出租车数量不变，莫非纽约政府先知先觉，知道需要设立多少牌照供以后几十年用？当然不是，90年代后期，纽约一张牌照的价值已经超过20万美元。出租车公司会拼命阻止政府增加牌照，否则牌照租金的价格就会下降，但是由于市场需求增大而供给不变，打的的价格就下不来，最终受害的是整个社会。我们可以看到，在这个寻租的过程中，并没有给社会创造新的价值，但却为出租车公司带来了利润。 这种权利寻租倒还可以让人理解，因为它至少还是在法律规定的范围内，而且牌照管制也是光明正大的，人们都能知道并且接受的事。但是有时人的手中若是有了权力，就会想极力地出租出去以获取租金，即使那已经超过他的职权范围并构成犯罪，往往也在所不惜。 周正毅，大家都比较熟悉，作为曾经的上海首富风云一时，但是最终因为经济犯罪被判三年，可是周正毅的三年牢狱生涯，过的并不比正常人差。他每天能够享用&quot;四菜一汤&quot;，能打手机，还能抽上熊猫牌香烟，而且每次到上海监狱总医院看病，该院都会收到命令，停止门诊，专门为周正毅一人服务。多高的规格的啊，这个首富就是不一样，坐牢都风光。然而根据有关部门的调查，在周正毅及其亲属等三人在上海市看守所羁押期间，身为看守所所长的黄坚，接受周正毅亲属贿赂共计人民币49万余元，另有港币、金银首饰若干，并为周正毅等人在羁押期间的生活和对外联系提供了方便。黄坚啊黄坚，你没有把握好力度吧，那么迫不及待地想把自己的权力出租出去，到最后只能落个身败名裂。 第二部分 第25节：投资管理–企业经营要懂的22个经济常识(6) 管理者收购（MBO） 【点睛】从打工仔到老板的质变。 【释义】所谓管理者收购，即目标公司的管理者或经理层利用外部融资资本来购买本公司的股权，从而改变本公司所有者结构、控制权结构和资产结构，进而达到重组本公司并获得预期收益的一种收购行为。完成MBO之后，昔日的管理者就变成今日的股东了。 【谈古说今】MBO是流行于欧美国家七八十年代的一种企业收购方式，当时欧美国家步入企业兼并收购的高峰期。经过MBO之后，管理层掌握了他们所服务的公司的股权，往往会提高企业运作的效率和盈利能力。 很多在国外运行良好的机制，一放到中国来就不行了。九十年代，为了提高企业的运作效率，很多国有企业进行了MBO，结果却是大量国有资产流失，企业性质改变。为什么会有如此的差别呢？因为国外公司不管谁拥有都是属于私人的，你要收购我的公司必须要出足价钱，不然没得商量。但是在中国，国有企业名为国有，实际上无人所有。很多管理层就占了这个便宜，在收购前故意把企业弄得不成样子，折腾来折腾去，反正也没什么人管。国家看看这企业不卖不行了，就贱卖了吧，能卖多少是多少，就这样很多国有企业被管理层很便宜地收到自己的门下，并且美其名曰：帮助国家解决问题资产，提高企业运作效率。 由于以上种种原因，国资委下发了禁令，紧急叫停了国有企业的MBO。但是这有用吗？马克思曾经教导我们，一旦有适当的利润，资本家就会大胆起来；有百分之五十的利润，它就铤而走险；为了百分之百的利润，它就敢践踏一切人间法律。所以在利益的驱动下，还是有很多人变相进行着MBO，下面看下2004年初宇通客车变相MBO的例子。 宇通客车是在原郑州客车厂的基础上改制而成的股份有限公司，于1997年在上海交易所上市，总经理汤玉祥。宇通客车的管理层为了收购这家国企，2001年在上海设立了宇通创业投资有限公司，法人代表汤玉祥，注册资本12053.8万元。随后宇通客车第一大股东郑州宇通集团的所有者郑州国有资产管理局，宣布与汤玉祥的公司达成协议，转让其宇通客车的股份，并且收了汤的公司给的股权转让金。但是上报到财政部，并没有得到批准。但是股权转让的钱已经付了啊，汤玉祥就对郑州国有资产管理局提起诉讼，判决结果当然是对郑州国有资产管理局手中的宇通客车的股权进行拍卖，所得钱款还给汤玉祥的公司，最终这部分股权为汤所拍得。宇通客车的股权就这样通过司法拍卖的方式被变相收购了。 对于这次收购，以汤玉祥为代表的800多名管理人员哪来一个多亿购买股份成了人们关注的焦点，按说作为管理者不会有那么多钱。原来在2000年后，管理层就进行了薪酬改革，将原先高级管理人员的报酬从50-60万元每年提高到每年250万元，而且在与郑州国有资产管理委员会达成协议转让股份后，先后两次10股派送6元，这种大比例的分红也为其收购筹措了5000多万元的资金，也就是说借棍打腿，用上市公司的钱去收购它。最后还被查出财务造假，对宇通客车的资产进行了虚减，反正就这样稀里糊涂的，宇通客车就摇身一变成了私营企业。 第二部分 第26节：投资管理–企业经营要懂的22个经济常识(7) 诸如此类的收购案例还有很多，而且每个案例的收购手段都会有所创新，中国人的智慧在这时候可谓彰显无疑啦。 要约收购 【点睛】从&quot;你可以卖给我吗&quot;到&quot;我一定要买你&quot;的转变。 【释义】要约收购是指收购方公开向全体股东发出要约来收购目标公司的股票，达到控制目标公司的目的。要约收购包含部分自愿要约和全面强制要约两种类型。部分自愿要约是指收购者根据目标公司的总股本确定预计收购的股份比例，在该比例范围内向目标公司所有股东发出收购要约。当收购的股份达到一定的比例，一般为30%，如要继续增持股份，则要向所有股东发出全面收购要约。 【谈古说今】2008年9月3日，中国最大的果蔬汁生产商中国汇源果汁集团有限公司发表公告称，可口可乐旗下全资附属子公司向汇源果汁所有股东发出收购要约，拟以179.2亿港元收购汇源果汁全部已发行股本。可口可乐提出的价格相当于每股12.2港元，较汇源停牌前溢价1.95倍，收购要约的期限为200天，也就是截止到2009年3月23日。如果此次收购成功，汇源将成为可口可乐全资子公司退出股票交易市场。 在这里可口可乐即向汇源果汁的所有股东提出了全面收购要约，是典型的要约收购。这次收购是今年来最大的一起外资全资并购中国企业的交易。由于汇源果汁在国内饮料市场的龙头地位，这次收购引起了社会各界的广泛关注。此次收购的完成将可能成就可口可乐在中国饮料市场的垄断地位，所以收购要想成功还需要经过中国监管部门的批准。 对于这次收购，汇源的大部分股东都是赞成的，因为可口可乐提出了让股东们无法回绝的价格，本来只有4元的股票可以卖到12.2元，何乐而不为呢？——可见金钱与爱国原是不能两全的。遗憾的是，2009年3月18日，商务部就本次收购案反垄断审查做出了最终裁决，认为可口可乐收购汇源公司将会对竞争产生不利影响，一锤否决了此次收购。 【知识链接】协议收购是相对要约收购来说的，是指收购者在证券交易所之外以协商的方式与被收购公司的股东签订收购其股份的协议，从而达到控制该上市公司的目的。协议收购一般只涉及大股东之间的交易，所以手续较为简便，收购成本也较低。相对而言，要约收购是在所有股东都平等获得信息的基础上自主做出选择，是更加市场化的规范的收购模式，有利于杜绝各种内幕交易，更加有利于保障中小股东的利益。 首次公开募股（IPO） 【点睛】性能优良的亿万富翁孵化机。 【释义】IPO是Initialpublicoffering的缩写，即首次公开募股，指某公司首次向社会公众公开招股的发行方式。公司进行IPO，不但可以得到资金用来扩大业务，而且成为一间公众公司之后，还能很方便地从二级市场募集资金，为公司的做大做强提供了保障。 第二部分 第27节：投资管理–企业经营要懂的22个经济常识(8) 【谈古说今】一个企业从小到大，慢慢发展，一般遇到的最大问题就是资金。资金是企业的血液，没有资金企业很难发展。所以在企业很小还没有上市资格的时候，一般企业家都会寻求风险投资前来投钱，等到慢慢发展壮大后，就需要从更多的人手里筹钱，这时IPO就是一个很有效的方式。 不少企业创办人在IPO之后，一夜成为亿万富翁，比如2007年的女首富杨惠妍。 杨惠妍旗下的碧桂园诞生于1992年，至今已经营造了十多个超大规模综合社区。碧桂园集团创建于1997年，是全国最大的综合性房地产开发企业之一。2007年4月，在香港证券交易所上市，首次IPO创内地房地产企业规模最大纪录，总共出让16.87%的股权，募集到129亿港元的资金。公司大股东杨惠妍以25岁的年龄变身中国最年轻首富，她拥有碧桂园58.19%的股份，其身家在上市之初达到了600亿元，远超前任首富张茵。这也让素来低调的碧桂园成为一个新的财富神话。 不少人可能很难明白这到底是怎么一回事，下面我将其分解开来，让大家看看这个首富是怎么炼出来的。原先碧桂园是一家家族房地产企业，其中杨惠妍、杨贰珠、苏汝波、张耀垣、区学铭分占70%、12%、6%、6%及6%的股权。杨惠妍是最大股东，其他几个人都是亲戚朋友，也是在一起创业的元老。上市后，总共卖出16.87%的股份，五个股东所占的总份额被稀释到83.13%，其中杨惠妍所占份额被稀释到为58.19%。他们为什么要让出股份呢？原来这些股份是卖出去的，别人要拿钱来认购，这样钱就流入了企业。碧桂园总共募集到129亿，有了这笔钱它就可以进行扩张了。那么杨惠妍是如何成为首富的呢？其实她并不是真的有那么多钱，而是按照香港交易所里碧桂园的股价，她手里的股票值600亿元。 说到IPO，就不得不说说打新股。由于害怕股票卖不掉IPO失败，一般企业公开发行的股价不会很高，在市场交易后总是会上涨，这已成为了惯例。既然如此稳赚不赔，那为什么不在上市前就买了呢？所以就有了打新股。打新股也就是在股票公开交易之前，从杨惠妍他们手中把股票先买过来。由于赚钱机会很大，自然不会让你那么轻易申购到。像碧桂园在香港上市，就有3330亿港元去申请购买他们的股票，但是最终只有129亿元的资金申购到了，而且从申购到最终出结果这段时间你的资金是没有利息的哦。但是碧桂园一上市就飙涨41.3%，如果能申购到新股的话还是蛮幸运的。 产业链条 【点睛】环环相扣，心手相连，你是最重要的。 【释义】产业链条就是生产制造以及除去生产制造以外的6个环节，这其余的6个环节分别是产品开发、原料采购、仓储物流、订单处理、批发管理和终端零售，也就是常说的6+1。 第二部分 第28节：投资管理–企业经营要懂的22个经济常识(9) 【谈古说今】企业成败的关键是什么？低廉的成本？先进的技术？其实，这些对企业来说都是很重要的，但最重要的莫过于对产业链的控制。中国的企业大多数都是做的生产制造这个环节，也就是6+1中的1，而这个1却是利润最低、最容易受到冲击、也是最脆弱的环节。 福建晋江是我国最大的运动服、运动鞋生产大本营，号称&quot;中国运动服之都&quot;。同时，晋江被称为鞋业加工厂，世界上每五双鞋就有两双产自晋江。晋江共有贴牌企业3000多家，但是他们以往的毛利率只有10%左右。这些贴牌企业的出口价格一般为5美元/双，但国外企业一转手就能销售到40美元/双。人民币的升值，新劳动法的出台，金融危机导致的需求减缓，这一切都带来成本的极大上涨，目前很多贴牌企业已经处于亏损的边缘了。 我们看到再低廉的成本也有上涨的那天，再先进的技术也会有被淘汰的时候，只有那些控制了整个产业链的企业才能获得最高的利润，拥有抵抗风险的能力。 与这些企业不同，在晋江还有个叫做安踏的企业，即使在2008年金融危机这样恶劣的经济环境下，它的利润率也一直保持在33.2%。它成功的关键就是经营思路的转变，从单纯的加工制造到对整个产业链的经营。耐克，阿迪达斯如今已经不再做生产制造了，它们所有的产品都是交由东莞的企业代为加工，然而他们却控制着整个产业链的6，利润最高的部分。照这样看来，转变观念，加大对产业链的整合与控制，才是目前中国企业突破重围，重获生机的关键所在。 第二部分 第29节：金融经济–关心民生要懂的25个经济常识(1) 第三讲：金融经济——关心民生要懂的25个经济常识 家事国事经济事，事事关心 二元经济 【点睛】必须有两个轮子才能算得上自行车，一个控制方向，一个提供动力。 【释义】二元经济是指发展中国家的经济是由两个不同的经济部门组成，一个是以农业为主的传统部门，一个是以技术较先进的工业、服务业为主的现代部门。传统部门的劳动生产率较低，存在大量的隐性失业，容纳了绝大部分劳动力。现代部门劳动生产率较高，但是容纳的劳动力较少。 【谈古说今】一般在二元经济中，以农业为主的传统部门存在着大量的隐性剩余劳动力，之所以说是隐性的是因为他们也下田干活，种种庄稼，算不上是失业，但是如果没有他们，农业生产可以照样干下去，所以又叫剩余劳动力。二元经济并不是一个稳定的经济形式，谁不想进城里工作呢，那里工资高，生活条件好。所以你会看到无论是经过多年学习有一定知识和技能的高校学生，还是文化水平不高的农民兄弟，都纷纷地往城市挤，这样发展的最终结果就是二元经济的逐渐解体，最后发展成为发达的一元经济。如今美国、日本等发达国家早就不存在二元经济了，这些发达国家的农民比例基本上都不会超过10%。 &quot;鲁冠球，你要好好干，争当世界冠军。&quot;这是李鹏总理接见鲁冠球时所说的鼓励的话。鲁冠球素有商界常青树之称，2003年，他和他的家族以194亿元的资产控制额荣登中国内地资本市场控制榜第一家族，他也是排行榜上控制上市公司数量最多的人之一。然而这位最受尊敬的第一代企业领袖之一却是农民出身，并且至今还操着浓重的浙江乡音，只有初中文化的他向世人展示了一个农民的传奇故事。1969年7月，他带领6个农民，以4000元起家，创办企业，发展成资产超百亿元、员工31800多名的万向集团。这仅仅只是中国几十年发展的一个缩影，在中国富豪排行榜上，前100个差不多都是半文盲农民出身，这些草根阶层不但自己奋斗从一介农民变成城市里的佼佼者，而且他们创办的企业还带动无数人完成了由乡下到城市的转变。正是在这样的转变过程中，中国不断地前进，二元经济中传统的农业部门人数逐渐减少，由改革开放初期的80%已经减少到现在60%左右了。 但是有一群人却在默默地承受着转变过程中的阵痛，他们就是农民工兄弟。中国的国情就是人太多，那么多人守着几亩薄田简直是一种浪费，所以很多剩余的劳动力就想找到新的出路，城市成为他们唯一的选择。但是由于本身没有什么特殊的技能和知识，替代性很强，而且供给又很丰富，所以他们的工资永远是城市里最低的一族。也正是这样的低工资，无福利、无保险才导致中国产品的廉价，才吸引了更多的外来投资，而出口和投资无疑是中国经济增长的根本。可以这么说，中国经济的快速发展是建立在这些受苦受累的民工血汗上的，这是中国为发展付出的代价。这也就是为什么很多学者都说二元经济是中国发展的动力的原因了。 地下经济 【点睛】经济就像比基尼，暴露出的那部分固然重要，但没暴露的那部分才更是要命。 【释义】地下经济也称非正规经济，是一种国民经济中未向政府申报登记，经济活动脱离政府法律法规约束，且不向政府纳税的经济成分。地下经济是当前世界范围内的一种普遍现象，被国际社会公认为&quot;经济黑洞&quot;，当前世界的产出中约有23%的比例是地下经济。 【谈古论今】费尔南多生活在秘鲁的利马，像很多大学生一样，他在空闲的时间也开出租车。他一走出校门，就在自己的挡风玻璃上贴上&quot;出租车&quot;字样。开出租所得的收入用来支付学费，至于这些收入，他是不需要申报的。 利马的一位经济学教授说：&quot;这些司机没有运营证，没有劳动合同，也没有社会保险，他不给乘客收据，也不申报收入，自然就不用缴纳税收。在秘鲁有60%以上的劳动者都是在非正规经济部门工作的，比如流动商贩、车夫、印刷工、理发员等。&quot; 第二部分 第30节：金融经济–关心民生要懂的25个经济常识(2) 从事地下经济活动的劳动者得不到必要的劳动保护，也无法享受医疗保险和退休金等社会保障服务，那为什么人们非要在非正规经济部门工作呢？光明正大地在正规经济部门工作，不用提心吊胆，享受政策保障多好啊？！ 其实最主要的原因是人口压力和就业压力过大，很多人无法在正规的经济部门得到工作机会，只能通过非正规的渠道自谋生路。在秘鲁正规经济已经不能满足人们的需求。每年有近35万人要进入劳动力市场。在这些新的劳动者当中，有年轻人，他们刚刚进入社会；还有妇女，她们也在寻找工作机会。打个比方，一个城市出租车的牌照就那么多，想再进入基本上不可能，政府既然不给机会，只好自己去寻找机会了。 其次，由于进入正规经济部门的成本太高，很多人不得不从事地下经济的工作。德索托是秘鲁自由和民主研究所的所长，他出版的《另一条道路》专门对地下经济作了描述。他在书中列举了一个他和他同事所做的被人们奉为经典的实验：他们试图在秘鲁首都利马建立一个服装厂。为获得营业执照，他们奔波了近300天，2次对政府主管部门的官员使用贿赂手段。后来，他们到纽约注册了一个同样规模的服装厂，所有的手续仅用4个小时就办妥了，而且不必向政府主管部门行贿。同样他们想在秘鲁注册个运输公司，至少需要2年时间，即使是办个小商亭也要43天后才能得到营业执照，并支付600美元的各种费用。如此高的&quot;合法性&quot;成本逼得很多人只得进入非正规经济部门。 最后，还有很多经济活动是违法的，比如说贩卖毒品，从事色情服务等。他们不被抓起来就赶快烧香拜佛吧，还想让他们到工商部门注册呢？窗户都没有，更别说门了！ 经济一体化 【点睛】实现经济一体化就像上天堂，每个人都想去，但都不想去得太早。 【释义】经济一体化指各国彼此开放，商品、资本和劳务能够自由流动，不存在任何的贸易壁垒，形成相互联系、相互依赖的有机整体。 【谈古说今】自二战之后，伴随着国际贸易的发展，经济一体化逐渐成为了共同的选择，各国都在促进本国与他国的贸易问题上不遗余力，各种地区性的经济共同体也纷纷建立，像目前比较有影响的有欧洲联盟，北美自由贸易区，亚太经合组织，中国-东盟自由贸易区。八十年代之后，这种一体化逐渐扩展到全球，各个国家的经济政治联系更加紧密了，人们不禁要问为什么要推进经济一体化，它到底有什么益处呢？ 先说个反面的例子，在明朝虽然郑和多次组织巨大的船队下西洋，但是统治者却不愿与外国人进行贸易，因为他们认为中国乃是泱泱大国，什么都不缺，并不需要和别人贸易，在清朝时期，情况也差不多，然而就是这样什么都不缺的泱泱大国却最终远远地落在了后面。当时的统治者实行的是完全的贸易壁垒，将整个世界挡在门外，也就没办法接受先进的技术了，落后是必然的结果。由此可以充分看出贸易壁垒的弊端，它使整个国家固步自封，无法跟上世界发展的潮流从而被先进和发达所抛弃。 第二部分 第31节：金融经济–关心民生要懂的25个经济常识(3) 由于你生产你有优势的产品，我生产我有优势的产品，然后我们俩做交易，这样降低了各自的生产成本，得到成本降低的收益，从而参与的国家实现互利共赢。经济一体化放宽了资本、产品流通的限制，扩大了各个国家的市场，从而获得更多的潜在收益。自由贸易还会使得技术交流变得更加方便，从而使得每个国家的技术进步能够得到分享，共同促进生产力的发展。 尽管经济一体化拥有诸多益处，但是否实行完全的经济一体化还要根据国情。完全的经济一体化是要有一定的条件的，因为各个地区的经济结构不一样，经济发展状况，技术水平都不同，如果忽然之间放开所有的市场，会对某些经济体造成毁灭性的打击。比如中国大豆就远远不是美国大豆的竞争对手，他们大规模生产，拥有优良的品种，先进的技术，低廉的成本，所以当我们一下开放大豆市场时，美国大豆一夜之间占据了中国整个大豆市场。国家一看这样下去那还了得，不得不紧急叫停大豆市场的完全开放，这样中国生产大豆的农民才能继续生存下去。所以经济一体化虽然好处很多，但是也要视具体情况而定，不能盲目开放，一下子消除所有的贸易壁垒。 但是总的来说，经济一体化是大势所趋，是一个全球浪潮，违背这个浪潮和趋势的国家就会被踢到历史的垃圾堆里。 城市化 【点睛】丑小鸭进化成白天鹅的漫长过程。 【释义】城市化是由农业为主的传统乡村社会向以工业和服务业为主的现代城市社会逐渐转变的历史进程。在这个进程中，农村人口逐渐转变为城镇人口，经济结构从以农业为主逐渐转变到以工业和服务业为主。 【谈古说今】1978年，我国设市城市193个，人口超过100万的有13个。2007年，设市城市达到656个，100万以上人口城市达到117个，其中出现了像上海、北京、深圳、广州等人口超过1000万的城市数个。在短短三十年中，中国的城市化进程逐渐加快，形成了珠三角、长三角、环渤海三大城市群，占全国土地面积6.3%，人口25.5%，实现全国GDP的46.5%，出口的77.9%，为中国的经济发展做出了卓越的贡献。 然而问题总是伴随着成就而来，据专家估计，到2025年，城市将新增人口3.5个亿，其中流动人口占2.4个亿，所谓的流动人口大多是农民工，这些人处于社会的底层，拿着微薄的工资，受到不平等的待遇，没有基本生活保障，已经成为中国城市化进程中急需解决的问题。下面我们来看一个真实的故事：一个民工的流水账。 这个民工主要帮一个公司干干杂活，都是那些办公室里白领不愿干的活，比如搬搬东西，送送水之类，基本上靠一根扁担，两根绳过活。下面是他的流水账： 第二部分 第32节：金融经济–关心民生要懂的25个经济常识(4) 房租：50元（6个民工合租一间贫民区的小房间） 管理费：20元（街道收的，包括10元的暂住费） 餐费：110元（早饭1元，午饭3元，基本上是只管饱的那种，晚饭自己做） 买菜：27元（6人轮流买菜） 买米：15元 日用：30元 买烟：20元（2块钱一包的那种，几天抽一包） 通讯费：17元（很大一部分用来给公司回电话） 交通费：3元（基本上都是靠走） 给儿子生活费：200元（儿子在县里上高中） 给老婆买衣服：20元（明显是打了折的地摊货） 寄回家：150元（存起来供儿子以后上大学用） 给母亲看病：50元 意外支出：60元（为了抢活，乱闯红灯被罚10元，走路不小心碰到一小伙，被讹诈50元。） 像这样的民工，保守估计，在上海，广州，深圳这样的大城市，至少每个城市有200万以上，而这样的生活标准应该是中等吧。这是一群被忽视的人群，一群没有享受到城市化带来的好处的人群，需要我们的政府多加关注。 金融深化 【点睛】从青涩走到成熟，这是必经的阶段。 【释义】金融深化指政府放弃对金融市场和金融体系的过度干预，放松对利率和汇率的严格管制，使利率和汇率成为反映资金供求和外汇供求对比变化的信号，从而有利于增加储蓄和投资，促进经济增长。 【谈古说今】目前我国政府对金融体系的干预是非常严重的。首先外汇就存在管制，任何个人不能自由地到国外去进行投资，人民币汇率的高低也是由央行控制着，每年甚至每个月商业银行能够贷出去多少钱有时都要由政府规定。这样管制过于严格会导致很多没有效率的市场行为，汇率不能真正地反应市场上对两种货币的供求，贷款也不能反映企业对资金的渴望程度。 2009年1月1日起，中国与东盟间的贸易实施第三次降税，关税水平降到2.8%，远低于9.8%的我国关税的平均水平。在此后不到14天，正在广西壮族自治区召开的&quot;两会&quot;传出消息，中国人民银行南宁中心支行已将对越贸易人民币结算试点调研报告递交人民银行总部，中国与东盟之间在2009年上半年率先开启人民币试点。 这个人民币试点是什么意思呢？就是现在各东盟国家不是与我们进行的贸易很多嘛，而现在贸易大多使用第三方货币——美元。这个试点开始以后呢，就是说结算货款就不再用美元，而是用我们的人民币了，这样人民币国际化就向前迈出了一步。现在广州、深圳、珠海、东莞、上海五城已经开始人民币贸易结算业务的试点活动了。除此之外，中国还与巴西签订协议，以后咱俩贸易就用我家或你家的货币，不再用美元了。 第二部分 第33节：金融经济–关心民生要懂的25个经济常识(5) 其实国家之所以这么做，主要就是要把人民币推向世界。以前我们总是把人民币管的太死了，人家想来投资都不行，这样长久下去不利于提高我们的国际竞争力，也无法成为一个强大的国家。 通货膨胀 【点睛】通货膨胀是能把你手里的雪糕变成冰棍的小恶魔。 【释义】通货膨胀是一种货币的发行量超过经济中的需求量，从而产生货币贬值、物价上涨的经济现象。 【谈古说今】2008年，人们最常说的一句话就是：&quot;钱越来越不经花了！&quot;其实就是通俗版的通货膨胀的释义。打个比方，本来一顿饭只要5块钱就能吃好了，而现在却要7块钱，本来一斤猪肉只要8元，现在要10元，这就是通货膨胀。人们不禁深思，为什么会有通货膨胀，它从何而来。下面是通货膨胀的几种成因。 第一种情况是需求拉动型通货膨胀。由于在一定的时间里面，商品的供给基本上就是那么多，所以当对这种商品的需求忽然变得很大，超过供给的时候，自然是供不应求，买的多卖的少，厂家一兴奋价格也就涨了，于是物价自然就上升了。中国有句老话：物以稀为贵，道理跟这个有异曲同工之妙。 第二种情况就是成本推动型通货膨胀。这种通货膨胀，主要是由于原材料价格的上涨造成的。如在七十年代石油价格快速上涨，全球经历了一次严重的通货膨胀，美国甚至一度达到两位数，是二战以来的最高值。 在国民党执政后期，曾经有一个农民挑着两个筐子的钱去商店买东西，有事走开一会，等回来以后发现两堆钱在地上，装钱的筐子被偷了。很讽刺吧？可是却是真实发生过的，甚至是有过之而无不及，因为在当时出现了非常罕见的恶性通货膨胀。这种通货膨胀一般也只有在战争年代或动荡时期才会出现。一般我们生活中出现最多的都是些比较轻微的通货膨胀，在1%~5%之间，此时人们感觉不到物价的变化。稍微严重点的会在5%以上，人们能普遍感觉到身边的餐馆都在不停地提价。 那么我们应该如何去应付通货膨胀呢？轻微的通货膨胀其实并不需要担心，他们只是悄无声息的存在着，对我们的生活不会产生什么影响。实际上，轻微的通货膨胀一定程度上说对经济的发展还是有利的。但是对于严重的通货膨胀，我们就必须要采取行动，钱是肯定不能存到银行了，实际利率为负数，那点利息还不够贬值呢。最好都换成其他货币，比如美元，日元什么的，要是没办法换，就去买黄金，或者一些收藏品，这样可以避免物价严重上涨带来的损失。 产能过剩 【点睛】食欲很旺，但却消化不良，世间最痛苦的事莫过于此了。 第二部分 第34节：金融经济–关心民生要懂的25个经济常识(6) 【释义】产能也就是生产能力，指在一定时间内，企业参与生产的全部固定资产在既定的组织技术条件下，能够生产的产品数量。 【谈古说今】目前，中国许多行业，如钢铁、焦炭、煤炭、汽车、航空等都存在着产能过剩的情况。 以钢铁产业为例，前几年，由于中国城市化进程的加快、世界经济的繁荣等原因，对钢铁的需求量逐渐增大，钢铁价格一路上涨。国内的企业基本上都是投入重资购买设备，扩大产能。然而随着2008年世界性金融危机的到来，全球需求大幅放缓，导致前几年刚刚投资的产能用不上，全国大中型钢铁公司普遍亏损。 在这样背景下，一幕幕悲剧不断上演。2008年11月10日，江苏不锈钢巨头兴利来特钢有限公司董事长包存林猝死。 关于不锈钢巨头包存林死因众说纷纭，企业对外的公告是因病猝死，但是大多数人认为是因企业资金链断裂，包走投无路自杀身亡。54岁的包存林一直身体很好，从前没有生过什么病，所以猝死的可能性极小。在他去世前一周，他就有过轻生的念头，当时吞下大把的安眠药，被送往医院，最终醒了过来。之后家人为防不测，对他严加看守，可悲剧还是发生了。 1999年，包存林和一个广东的老板合伙开了一个钢铁厂，当时规模很小，占地只有16亩。 2003年，产品远销世界30多个国家和地区，旗下的&quot;长利&quot;牌不锈钢获得江苏省名牌产品的称号。 2004年，实现产值2.2亿元，利税4000万元。 2005年，为了做大做强，包存林新征328亩土地扩建，新上的680热连轧生产线等，投产后年产出可达5~10亿元。 2007年，全球金融危机爆发，并且开始向实业蔓延。 2008年，全球对钢铁需求快速下降，国内大部分钢铁企业停产或部分停产，产值下降近六成。 包存林就是因为扩张太快而导致如今的境地。为了扩张，他从银行贷款4.2亿元，眼看就要到了还款期限，而自己在整个行业产能过剩、企业没有销售额的情况下，手中已无资金，最终在强大的压力面前，选择了不归路。 逝者已逝，生者如斯。那些在创业道路上艰难跋涉的企业家们在推动中国经济发展的进程中做出了自己的贡献，值得我们去憧憬和爱戴。但是我们更应该去反思，在盲目投资，一味扩张的道路上，我们还能走多远？ 第三部分 第35节：炒股不得不知的经济常识(1) 下篇：经济思维篇 第一讲：炒股不得不知的经济常识 价值投资 【点睛】专情要比多情幸福10000倍，所以要与喜欢的公司白头偕老。 【释义】价值投资是在20世纪30年代，由本杰明·格雷厄姆提出，并在后来由巴菲特发扬光大的投资方式。如今价值投资风靡全球，被投资者奉为圣典。价值投资的精髓就是投资于那些股票价格远低于其内在价值的公司，并且长期持有，享受公司成长带来的好处。 【谈古说今】价值投资之所以会受到全球投资者如此的爱戴，与巴菲特通过价值投资成为全球首富是分不开的。从1965年~1994年，巴菲特的投资业绩平均每年增值22.9%，高于道·琼斯指数近12个百分点。也就是说如果谁在1965年投资巴菲特公司1万美元的话，到1994年，他就可以得到900万美元的回报：谁若选择了巴菲特，谁就坐上了发财的火箭。巴菲特凭借着对价值投资深入的理解和把握，成为了世界上最伟大的投资家。 2000年之前，全球的投资者都热衷去购买互联网公司的股票，那时互联网还是一个新概念，人们都看好它的潜力。所以在美国纳斯达克市场上，一只营业额2个亿，亏损1个亿的互联网公司股票的价格往往要是一个拥有10个亿营业额，1个亿稳定收益的传统公司股票价格的好几倍，就因为它与互联网相关。而巴菲特却没有投资于任何一只互联网公司的股票，当问到为什么他不投资时，巴菲特只用了一句话就回答了：&quot;因为对这些公司不了解，所以不投资。&quot;巴菲特没有赶上这次财富盛宴，在2000年公布的年报中，显示巴菲的投资业绩有所下滑，从1999年的盈利28.3亿美元跌到2000年的15.57亿美元，质疑之声开始出现。然而世界上没有不灭的泡沫，2000年之后，互联网泡沫破灭，全球投资者都蒙受了巨额损失，原本高高在上的股价，在没有盈利预期的情况下，跌得分文不值，股市里充斥着凄惨的悲号。此时巴菲特的业绩却逆势上涨，显示出价值投资强大的生命力。 其实价值投资的理念并不复杂，真正的价值投资者从来不去预测股市的底，更不会去预测哪里是顶，他们买卖股票的唯一原则就是这只股票的价格低于其内在价值，投资它并长期持有就会获得高于市场平均的收益。他们选择股票的标准就是安全边际准则，也就说如果明天交易市场就关门了，这个公司股票还值得买吗？如果值得那就买吧。价值投资者不像那些股票投机者，他们不需要一夜暴富，而追求的是一种稳定的长期的高收益，是用复利来赚钱。巴菲特每年的收益率也就20%多点，并不算高，但是人家牛在能够每年都获得这个收益。价值投资看重的另外一个方面就是长期持有，巴菲特说过，购买一只股票期待它第二天上涨是愚蠢的。平均下来，他所投资的每只股票持有期达到8年。 说起价值投资每个人都知道，但是能够真正数十年如一日坚持下来的人却寥寥无几，一般的投资者也没有巴老那样独到的眼光和良好的心态。大多数人都将技术分析和价值投资结合起来，寻找一个中间点，进行自己的股票买卖。 套期保值 【点睛】不求一夜暴富，但求守住利润。 第三部分 第36节：炒股不得不知的经济常识(2) 【释义】套期保值是指把期货市场当作转移价格风险的场所，利用期货合约来规避未来的不确定性风险。比如某公司想在未来三个月买入100吨大豆，但是又害怕价格会上涨，所以就在期货市场上买入100吨大豆，三个月后成交，这样价格就被锁定了，大豆价格的波动就与其没有关系了。 【谈古说今】2008年10月21日，中信泰富发布公告称，公司为了对冲西奥洲铁矿项目面对的货币风险，签订若干杠杆式外汇买卖合约而引致亏损，实际已亏损8.07亿港元。至10月17日，仍在生效的杠杆式外汇合约按公平价定值亏损147亿港元。该巨亏事件令香港证券界震惊，在复牌后短短一周内中信泰富的股价跌去七成。最终一手打造中信泰富的荣智健宣布离职，跟随荣智健20余载的范鸿龄也宣布辞去中信泰富总经理的职位。 一般大型企业在进行数额巨大的海外收购时，由于付款时间较长，而且不是一次性付清，所以必须要考虑到本币与外币之间汇率的波动产生的风险。为了锁定成本，一般企业都会进行外汇的期货交易。但是明明是希望可以套期保值的，怎会造成如此大的亏损呢？下面我们看看这份套期保值合约的背后。 中信泰富在澳大利亚建了一个铁矿石项目，需要从澳大利亚和欧洲购买设备和原材料，你去买东西不可能拿着港元去吧，人家要的是澳元和欧元。所以中信泰富就需要拿他的港元或者美元先去兑换成澳元和欧元，然后再拿去该买啥买啥。2008年年初，中信泰富用0.85美元可以换到1澳元，但是到了6月份就需要0.93美元了，也就是说澳元升值了，这样中信泰富就需要更多的美元去换成澳元。他们想这样不行，不确定太大，为了规避这个风险，他们就利用起套期保值了。具体是怎么操作的呢？他们与其他几家投行签订一份合约，合约规定，在2010年10月份之前，按照0.87美元换1澳元的价格分月从这些投行手中换取总额为90亿的澳元。这样即使澳元再升值，中信泰富也不用怕了，他们可以每个月按固定的0.87美元的价格去买入澳元，成本也就锁定了。 但是天公不作美，2008年受到金融危机的影响，澳元前所未有的大肆贬值，到2008年11月份，只需要0.65美元就能买到1澳元了，而中信泰富还要用0.87美元的价格每个月从这些人手中购入澳元。相当于每购1澳元亏损0.22美元，总共要购入将近90亿澳元，浮动盈亏达到将近20亿的美元，所以有了上面的一幕。 很多人可能会问，这不是套期保值么，反正购买90亿澳元要花的美元还是刚开始预期的那么多，只看美元的话没啥亏损啊？事实上，原本中信泰富在澳洲的投资，未来20年也只需要26亿澳元左右，他们却买了90亿澳元，这已经不再是套期保值，而是投机了。否则单单的套期保值的话，所遭到的损失肯定在可承受的范围之内。原来天堂与地狱只是一步之遥。 第三部分 第37节：教你避开经济陷阱(1) 第二讲：教你避开经济陷阱 胜者的诅咒 【点睛】想要战胜对手，那是要付出代价的，被诅咒就是其中的一种。 【释义】胜者的诅咒指在拍卖的过程中最终的获胜者，可能由于对标的价值的评价太过于乐观，从而支付的价格超过其实际价值，也就是说虽然在拍卖中获胜，但却做了亏本的买卖。 【谈古说今】对于拍卖，大多数人的第一印象就是有个人在台上叫卖，下面的人举牌子出价，谁出的最高谁就得到拍卖品。其实现实生活中拍卖远远比这要复杂很多，分为很多种类，也有很多不同形式，我们只来简单地看下两种类型拍卖——个人价值拍卖和共同价值拍卖。 个人价值拍卖最典型的是艺术品的拍卖。一件艺术品值多少钱，对于不同的人来说是不一样的，有人就是非常喜欢某个画家的画，他就愿意出那么多的钱，所以这类物品不存在出价高于其价值的情况。但是共同价值拍卖就不一样了，比如对一块地皮进行拍卖，这块地皮就值那么多钱，某个开发商如果出价过高，他就会亏本。在这种情况下就会出现胜者的诅咒。 1996年5月，美国的联邦通讯委员会（FederalCommunicationsCommission，简称FCC）决定拍卖一部分由蜂窝电话、个人数字化助手以及其他通讯工具所使用的无线频谱。在这次拍卖的过程中，胜者的诅咒得到了完美的体现。至于这些频谱的价值非常的不确定，人们对于运营后到底能够带来多少收入只能靠自己的判断和预期。但是它确是实实在在的共同价值拍卖，谁要是出价过高就会导致最终的亏损。在这次拍卖中，最大的投标人NextWave个人通讯公司出价42亿美元一举拿下63个经营许可证，可谓是本次拍卖的最大赢家。可是他真的是赢家吗？1998年1月，NextWave发现自己已经入不敷出，经营困难，只好申请了破产保护。此后他手中拍卖得来的牌照由于没足够的钱付款，大多又被FCC收了回去。 胜者的诅咒产生最多的行业是地产行业。据统计，在所有的拍卖案例中，有26%的比例最高价出价是次高价的4倍多，77%的案例中，最高价超过次高价的2倍。绝大多数时候，投资者都是无法获得预期的利润的。全球华人首富李嘉诚在经历无数次土地拍卖后，总结出一句经典的名言：不要用买古董的心态去买地。这句话虽然朴实，但却处处体现出杜绝胜者的诅咒的思想。 事实上，公司或资产的收购可以看成一个人的拍卖，即使如此人们表现得依然不怎么样，很多公司愿意以很高的溢价收购别的公司，之后才发现并非如自己想象中的那样。20世纪八九十年代，日本人很有钱，到全球各地去收购别人的资产。1988年，三菱以14亿美元买下洛克菲勒中心，结果大亏880亿日元；1990年，松下以61亿美元的价格买下环球电影公司，之后也贱卖给希格拉姆公司；索尼买下哥伦比亚电影公司，结果亏损达34亿美元。 第三部分 第38节：教你避开经济陷阱(2) 胜者的诅咒无处不发挥着它的魔力，所以最明智的做法还是像经济学家建议的那样，更保守地报价。 庞氏骗局 【点睛】上联：拆东墙，补西墙，墙墙不倒；下联：借新债，还老债，债债不还；横披：庞氏骗局。 【释义】庞氏骗局是一种古老而又常见的投资诈骗，这种骗术是由投机商查尔斯·庞齐&quot;发明&quot;的。它一般是以高资金回报率为许诺来骗取投资者投资，再用后来的投资者的投资去偿付前期投资者。目前全世界的范围内，每年仍然会有很多的投资者因庞氏骗局而倾家荡产。 【谈古说今】查尔斯·庞齐是一个意大利人，在1903年移民到美国。在美国干过各种工作，曾经还因为走私，在加拿大蹲过一段时间监狱。后来他发现赚大钱最快的方法就是搞金融，于是在1919年来到了波士顿，并刻意隐瞒了自己的历史。 他设计了一个投资计划，向美国大众兜售，宣称只要购买欧洲的某种邮票再到美国来卖就会赚大钱，并且故意把这种交易弄得非常复杂。这样还不足以吸引大量的投资，于是他又宣布凡是投资的人在45天之内都可以获得50%的回报，并且确实兑现了：第一批投资者的确得到了50%的收益率。此后一年的时间里差不多有4万的波士顿市民，疯狂地对庞齐进行投资，那些投资者大多是怀揣发财梦的穷人。庞齐很快住上了20个房间的别墅，买了100多套昂贵的西装，还给情人买了无数的首饰，摇身一变成了顶级富翁。 然而纸是包不住火的，当他无法募集到更多的钱给以前的投资者作为回报时，他的骗局破产了，无数人的财产就这样顷刻间灰飞烟灭。庞齐被判了五年的刑期，历史上也出现了专门以其名字命名的骗术——庞氏骗局。 从此之后，庞氏骗局在世界各地不断上演，并衍生出许多变种，方法也越来越隐蔽，因而从来不乏上钩的鱼儿。有史以来最大的一起诈骗案——麦道夫巨额诈骗案，涉案资金高达500亿美元，其诈骗方法也是庞氏骗局。 伯纳德·麦道夫是一个传奇人物，他是纳斯达克市场董事会主席，身兼美国证监会顾问的职务，一直以来都被看作华尔街的奠基人。他在1990年成立了一家资产管理公司，并通过自己的关系网募集资金，通过自己的客户介绍客户，迅速有了不小的规模。从表面看来，该基金不断做着购买大盘增长基金和定额认股权等生意，并且每月能够保证有1%的收益，一直被人们当做稳健的投资品种。就这样20年风雨无阻，他保证了每年10%-15%的收益率，就连2008年美国标准普尔指数下降37.7%的情况下，还同样保持了这个增长率，令人不得不叹服。 但是随着危机的深化，更多的投资者希望能够持有现金，对麦道夫投资的人越来越少，最终资金链出现问题，终于东窗事发。2009年6月29日，麦道夫被纽约南区联邦法院判处150年监禁。这次庞氏骗局最大的受害者名单上甚至有着汇丰、法国巴黎银行、西班牙金融大鳄桑坦银行等国际顶级银行，这些拥有丰富专业经验的受害者，完美地诠释了华尔街的多面性。若不是这次金融危机的出现，麦道夫的庞氏骗局或许还将继续演绎下去。 第三部分 第39节：教你避开经济陷阱(3) 沉没成本 【点睛】不要为泼掉的牛奶而哭泣，在你哭泣的时候也许错过了星星！ 【释义】沉没成本指由过去的决策导致的，不能由现在或将来的任何决策所改变的成本。经济学家认为，理性的经济人在做接下来的决策时应该根据未来的投入与产出，而不会去考虑沉没成本。 【谈古说今】以前有一位老人，来城里看望儿子。儿子给他买了很多东西，其中有一双鞋子令他爱不释手。坐在回乡的火车上，他不停地把玩这双心爱的新鞋子，自豪地告诉邻座的人，这是他儿子孝顺他的礼物。忽然间老人一不小心，一只鞋子滑落到窗外。还在高谈阔论的旅客一时间一片肃静，大家都看得出老人有多喜欢这双鞋子，可是……出乎大家意料的是，老人随即将另一只鞋也拿起来，用力扔出窗外。旁边的乘客大惑不解，问他为什么要把另一只鞋也丢掉，老人说：这只鞋子对我来说已经没有用了，但如果一个人正好从铁路旁经过，他就可以得到一双鞋，而不是一只鞋。 这个老人不但非常的善良可爱，还能深刻领会沉没成本的意义。虽然老人非常喜欢那双鞋子，但是当他不小心把其中一只丢到窗外时，这双鞋子就对他就没有任何意义了，他再做决策时就不该再考虑这双鞋子的价值了。将鞋子丢出窗外，可以减轻自己对所犯错误的后悔情绪，还因为做了件好事而心情愉悦，何乐不为？ 在我们的生活中，也会见到许多有关沉没成本的现象。一般在淡季，国内的很多航空公司都处于亏损状态，但是你却发现他们依然在运行，为什么呢？因为航空公司大部分的成本是购买飞机建设飞机场等硬件设施，每次飞行所带来的成本是很小的。而这些硬件设施一旦投入就无法挽回，即使你说现在不飞了，那也没有办法使已有的投资收回，所以对于航空公司来说，继续飞行是最优的策略。 所以人们在做一件事的时候，应该学会忽略沉没成本，专注于未来的成本和收益。 【知识链接】沉没成本谬误是指人们在做决策时总是考虑沉没成本而导致的不理性行为。比如说小张买了一张电影票，等他去看电影时，忽然发现这部影片根本就不是自己喜欢的，如果是电视里免费放的，他根本就不会去看，而是去做其他事情。但是由于不甘心浪费了电影票，所以还是强迫自己去看完。这样他不但损失了电影票的钱，而且还浪费了时间，这就是沉没成本谬误。 第三部分 第40节：经济生活中不得不说的怪现象(1) 第三讲：经济生活中不得不说的怪现象 纳什均衡 【点睛】当鹦鹉学会说&quot;供给&quot;与&quot;需求&quot;时，这个世界就多了一位经济学家，但要成为现代经济学家，必须要多学一个词&quot;纳什均衡&quot;。 【释义】假设有N个人参与一场博弈，每个人都拥有自己可供选择的策略，而纳什均衡是指这样的一种策略组合，在这种策略组合下没有人能够通过单方面改变自己的策略而获得更高的支付。 【谈古说今】有这样一个小故事，曾经有两个小偷A和B一起去偷东西，但是很不幸，由于技术不精，在作案过程中被警察抓住了。警方将两个人分别关在两个房间里分别进行审问。这时A、B都有抵赖和招供两个选择，如果他们都选择抵赖的话，警方由于证据不足，最多只能关他们一年。但是如果都坦白的话，有了证据他俩都会被判8年。如果其中一个坦白，另一个抵赖，坦白的一方由于破案有功，会被当场释放，而抵赖的一方则要被关十年。你知道最终他们会如何选择吗？下面我们看看A与B所获得的支付： A╲B 坦白 抵赖 坦白 -8，-8 0，-10 抵赖 -10，0 -1，-1 其中-1表示关一年，-8表示关八年。从图表里我们可以看到，整体来说，都抵赖是最优选择，总共只需要关两年。可会出现这个结果吗？答案是不会。 首先看A，如果B选择坦白，那么他也应该选择坦白，这样只要关八年，否则都要关十年；如果B选择抵赖，那么他还是应该选择坦白，因为这样他就可以直接回家啦，不用关一年了。所以无论B怎么选择，A都应该选择坦白。这个分析对B来说也是一样，他也应该选择坦白，所以最终他们两个肯定都会被关八年，多么可怜啊，这就是人们著名的&quot;囚徒困境&quot;。 以上他们的策略组合&quot;坦白，坦白&quot;就是一个纳什均衡，因为在这个策略组合下，任何一个人都无法通过单方面的改变自己的策略而获得更好的结果，所以纳什均衡虽然不一定是最有效率的结果，但却是最稳定的结果。两个人都抵赖虽然是最有效率的，但是却不是一个稳定的策略组合。 价格歧视 【点睛】在商业经济里，人是有三六九等的。 【释义】价格歧视是指一家厂商或企业在同一时间对同一产品或服务索取两种或两种以上的价格。价格歧视分为三个等级，一级价格歧视是针对每一个不同的消费者收取不同的价格；二级价格歧视是针对不同的购买量收取不同的价格；三级价格歧视是针对不同的市场收取不同的价格。 【谈古说今】价格歧视看上去好像很神秘，其实它无时无刻不在我们身边。你走进大卖场，会发现一袋液态奶需要2元，而一盒装有12袋的液态奶却只要20元，这就是一种价格歧视，即你要为同样的商品支付不同的价格。一般电影院会对学生和老人打对折，这样支付能力低的学生和老人也可以去看电影，电影院既不会失去这部分客户，又能对其他客户收取较高费用。 第三部分 第41节：经济生活中不得不说的怪现象(2) 还有当你开着法拉利，带着劳力士，路过一个路边商店，问老板一件衣服多少钱，他可能会说，1000块。但是如果你骑了辆除了铃儿不响哪里都响的自行车，穿着皱巴巴的衬衫，跑去问那个老板同样的衣服多少钱，你得到的答案可能就是100元了。这也是一种价格歧视，商店根据顾客对价格不同的敏感程度收取不同的价格。所以价格歧视在我们生活中无处不在、无时不有。 最能体现价格歧视的例子当属机票的价格。不要说头等舱、商务舱和经济舱的座位标价悬殊，就连相邻的两个座位价格都可能相差一倍——这就是航空公司的价格歧视，它通过对人群进行甄别，然后对不同群体收取不同的费用来实现自己的利润最大化。 一般如果你提前两周或一个月去预定机票，价格会比即买即走要低得多。因为提前订票的大都是经常看报寻找优惠活动的闲人，把这些人甄别出来，就可以用低廉的价格来吸引他们。但是对那些说走就要走的忙人，价格不是最重要的因素，时间才是最宝贵的。这样的客户群体，收费当然要高啦。经济舱和头等舱的道理也一样。 节俭悖论 【点睛】节俭悖论是以店老板的观点来考虑一切问题的。 【释义】节俭悖论最早是由凯恩斯提出的，指节俭对于个人来说可能是件好事，可以增加个人财富，但是如果整个国家的人都节俭，那么将会使每个人都变得很贫穷。 【谈古说今】有个很古老的故事，说本来有一窝蜜蜂繁荣兴隆，每只蜜蜂都整天大吃大喝。后来一个哲人教导它们说，不能如此挥霍浪费，应该厉行节约。蜜蜂们听了哲人的话，觉得很有道理，于是迅速贯彻落实，个个争当节约模范。但结果出乎预料，整个蜂群从此迅速衰败下去，一蹶不振了。 看上去很不可思议，为什么每个人都节俭就会使整个国家很贫穷呢？原因很简单，因为每个人都很节俭，那么大多数企业生产的产品就会卖不出去，只有倒闭，职工也只有下岗，于是就没有收入，所以就会导致整个国家的人都很贫穷。20世纪30年代资本主义的大萧条就是一个生动的例子，人们由于担心经济恶化，都攒着钱不消费，留以后花，可越是这样，危机扩展得越快，最终造成一场大的经济浩劫。 下面我们来看看数学推导： Y=C+I 其中Y表示Yield即国民生产总值，C表示Consume即消费，I表示Investment即投资。 也就是说人们生产的国民生产总值卖给了两部分人，一部分被人们消费了，另外一部分就是被企业拿去投资了。所以当消费C变小时，国民生产总值Y自然就变小了。 相信大家都听过一个口号叫做&quot;消费即是爱国&quot;，这样的口号一提出就遭到无数人的批评，认为这真逗，简直就是无稽之谈。我们且不谈这个口号是否正确，从经济学的角度来看，它有一定的合理的地方，那就是在经济萧条企业开工率不足时，多消费可以使企业收入增加，增加就业。 第三部分 第42节：经济生活中不得不说的怪现象(3) 那么我们应该为爱国而扩大消费吗？我们敬爱的温家宝总理说：&quot;不能简简单单地说消费就是爱国。&quot;因为消费是根据自己的需要和条件来确定的，如果有钱了，不用说大家也都会去消费。所以，只要建立一个完善的社会保障体系，确保群众花钱没有后顾之忧，不用喊口号，消费自然也会起来。 外部性 【点睛】通俗来说，前人栽树后人乘凉，是一种正的外部性；竭泽而渔则是一种负的外部性。 【释义】外部性指社会成员从事经济活动时，其成本与后果不完全由该人承担，给无辜的第三方带来成本或者收益。可分为外部经济与外部不经济。外部经济指企业或个人的活动给第三方带来收益，反之，外部不经济指给无辜的第三方带来成本。 【谈古说今】一日，某可怜虫沐浴更衣，烧炉焚香，穿戴整齐，背着小书包自习去了。遍地找寻，发现一空旷少人的自习室，悠悠然地，开始看书。 10分钟不到，一对小情侣开始旁若无人地大声讨论所谓的问题，四周的同志们实在受不了，纷纷夺门而去。就剩可怜虫一人，坚持着，坚持着，最后，实在忍无可忍了，大吼一声：&quot;前面第一排的男生女生，要讨论声音能够否小点！&quot;.男生女生首异之，扭头看到位于最后一排的可怜虫孤身一人，遂强烈鄙视之，唾弃之，而后辱骂之。其中女生说了句：&quot;不想听我们讨论，你有本事换个教室去啊！&quot; 那只可怜虫坚持自己的立场，汲汲教化之，&quot;你们大声探讨你们的问题，将教室10人赶走了9人，剩下我一人，你们的行为从社会道德角度讲，是没公德心；从经济学角度来说，是将私人的收益凌驾在公共成本之上。&quot;. 以上的小故事就是说明了一个负外部性的问题，那对小情侣从事的经济活动就是进行问题的讨论。在这个过程中，他们获得了收益，因为他们弄懂了问题，解决了疑问。而且大声的讨论可以使对方听的更清楚，效率更高。但是这样的效率却有着严重的负外部性，因为他们严重地影响了那些无辜第三者的学习效率，从而导致两个人的小收益和10个人的大损失，从整体来看，无疑是低效率的。 外部性是我们生活中常见的现象，邻居家的花园可以让你赏心悦目，给你带来了正的外部性。不远处的工厂发出嗡嗡的噪音和乌黑的气体，让你的生活质量下降，给你带来了负的外部性，等等。 外部性会造成严重的低效率，但并不是没有解决的办法。在上面的例子中，只要出台并实施教室使用规则，规定教室中不能进行讨论，那就没问题了。或者规定教室里自修的人有权利进行讨论，而如果谁不想别人讨论的话，可以通过支付一定的金额让他闭嘴。这会提高效率，但是这种效率的提高也是有成本的，规则出台就必须要有人去监督实施，就需要成本。在这个例子中，这个成本远远大于所能获得的总体收益，所以你在大学教室里永远看不到这么一个监督员，此时只能靠学生自己的道德和修养了。 第三部分 第43节：用经济学原理来看待生活，增进福利(1) 第四讲：用经济学原理来看待生活，增进福利 稀缺性 【点睛】稀缺性在&quot;共产主义社会&quot;里面将是个考古词汇，让我们共同期待那美好的一天到来吧！ 【释义】稀缺性也叫有限性，是指相对于人们的无穷欲望而言，经济资源或者说生产满足人们需要的物品和劳务的资源总是不足的。任何物品想要成为商品必须具有稀缺性的特点，空气对人虽然重要，但是却无法成为商品，因为它随手可得。 【谈古说今】在经济学里，有个很古老的故事，为什么钻石比水贵？按照用途来说，钻石永远无法和水相比，水是人类的生命之源，离开了水人类就无法生存，可是离开了钻石，人们的生活几乎不会出现任何困难。经济学的开山鼻祖亚当·斯密回答了这个问题，就是因为稀缺性。由于钻石很稀少，物以稀为贵，人们为了能够获得钻石愿意出很高的价钱，可是对于水，到处都是，人们可以很轻易地得到，自然就不值钱了。 其实具有稀缺性的东西不仅仅是钻石，只要是人们都想得到，但供应却有限的物品都具有稀缺性。或许每个女孩子都做过白雪公主的梦，然而在传说里的白马王子怎么都等不来的严酷现实面前，不禁会去想为什么没有我的白马王子？答案是白马王子也具有稀缺性，不能人手一份。 考察男人是否稀缺，无外乎考察才貌与财富的数种排列组合，有才貌，意味着这个男人有人力资源可待开发，他或许现在穷困潦倒，但前程不可限量；有财富，意味着这个男人已经提前进入资本年代，将省却你们许多创业的艰辛。 有才兼有财，位列好男人第一等； 有财却没才，屈尊位列第二等； 有才而没财，只能是第三等； 才财同时缺失，从经济学的角度，就暂且先不列入稀缺男人的行列了吧…… 有人可能会说财有那么重要么？难道爱情非要和财联系在一起？虽然没有财的爱情也有，但时间不会长久。财代表着一种权利，一种驾驭稀缺性的权利，一种获得稀缺性资源的权利。有了财之后，你可以去买钻石，去买轿车，去买房子，去买市场上你想要的一切。对于这种获得稀缺性资源的权利，应该没有人会厌恶吧。 比较优势 【点睛】如果让牛郎织布，织女下田——嘿嘿，恐怕他们就得饿死了！这个美好的童话也就不存在了——这就是比较优势的威力！ 【释义】如果一个国家在本国生产一种产品的机会成本低于在其他国家生产该产品的机会成本的话，则这个国家在生产该种产品上就拥有比较优势。简单地说就是一个国家相对另一个来说更善于生产某种产品，则在此产品上具有比较优势。 第三部分 第44节：用经济学原理来看待生活，增进福利(2) 【谈古说今】去过庙的人都知道，一进庙门，首先是弥勒佛，笑脸迎客，而在他的北面，则是黑口黑脸的韦陀。但相传在很久以前，他们并不在同一个庙里，而是分别掌管不同的庙。 弥勒佛热情快乐，所以来的人非常多，但他什么都不在乎，丢三落四，没有好好管理账务，所以依然入不敷出。而韦陀虽然管账是一把好手，但成天阴着个脸，太过严肃，搞得人越来越少，最后香火断绝。 佛祖在查香火的时候发现了这个问题，就将他们俩放在同一个庙里，由弥勒佛负责公关，笑迎八方客，于是香火大旺。而韦陀铁面无私，锱铢必较，则负责财务，严格把关。在两人的分工合作下，庙里一派欣欣向荣。 这个故事说明了什么呢？弥勒佛在吸引客人方面具有比较优势，而韦陀则在管理账务上具有比较优势，如果他们两个能够合作，对两个人都有好处。就像两个民族，一个是以放牧为主的游牧民族，一个是以经营农业为主的民族。如果这两个民族能够进行贸易的话，无疑会使双方都受益，因为可以发挥各自的比较优势。作为游牧民族，他们要是想吃米饭、馒头啥的，总不能在自家的草原上挖个坑，来种水稻或小麦吧，就算你把坑挖了，又没有很发达的灌溉系统，到头来能不能收获还是个大问题。对于以经营农业为主的民族也一样，他们可以拿自己的产品去换肉吃，而把自家的田拿来种水稻或小麦，养活更多的人。 1957年，毛泽东提出钢铁产量要在15年的时间内超过英国，并于第二年召开著名的北戴河会议，自此在全国范围内开展了规模空前的大炼钢铁运动。全国上下红红火火搞了好一阵子，但是最终倒在奋斗的征途中。为什么会这么悲惨呢？就是因为比较优势。在当时我国生产力水平很落后，要钱没钱，要技术没技术，而钢铁产业正是资金和技术密集型的产业，所以很难快速地发展起来。我国人口众多、劳动力资源丰富，纺织业等人力密集型产业才是我们最擅长的。用自己的短处去和别人的长处比，无疑会碰得头破血流。所以你看在改革开放后，在市场的主导下，最先发展起来的都是人力资源密集型的行业，经过一段时间的资本和技术积累才会慢慢过渡到资金、技术密集性产业。 附录——名家名企经济常识 克鲁格曼 入选理由：2008年诺贝尔经济学奖获得者，2009年5月周游中国，并引发热烈讨论。 研究领域：国际贸易、国际金融、货币危机与汇率变化理论。 主要贡献：成功地预言过亚洲金融危机，开辟了国际贸易新的研究范式。 人生轨迹： 1953年，保罗·克鲁格曼出生于美国中产阶级家庭。他在纽约的郊区长大，从约翰·F·肯尼迪高中毕业后，进入麻省理工学院学习经济学，之后在诺德豪斯的推荐下，攻读了博士学位。在完成博士论文以后，去了耶鲁大学任教。 第三部分 第45节：用经济学原理来看待生活，增进福利(3) 1978年7月，写了一篇关于垄断竞争贸易模型的论文，并在国民经济研究局的暑期研讨会上宣读，从此一举成名。1982年，刚从瑞典的国际会议上回来就被邀请到华盛顿任职，担任经济顾问团国际经济学首席经济学家，并于1983年主笔了总统经济报告。但是华盛顿之行并不愉快，主要是因为他性格过于耿直，难以胜任政府工作。 1987年，克鲁格曼写出一系列高质量的论文，比如《第三世界债务减免》、《欧洲货币体系的作用》、《贸易集团化》等，并因此获得了约翰·贝茨·克拉克奖。1988年出版了《期望减少的年代》一书，在美国引起极大的反响。他与奥伯斯法尔德合著的《国际经济学》成为各大学的标准教材。 1996年克鲁格曼出版了《流行国际主义》一书，大胆预言了亚洲金融危机，该书在短短两年内就重印了八次，总印数达120万。亚洲金融危机的爆发使克努格曼成为焦点中的焦点，其名气传遍了全球，在国际上的影响力与日俱增。 2008年10月13日，瑞典皇家科学院宣布，将2008年诺贝尔经济学奖授予美国经济学家保罗·克鲁格曼，用来表彰其在贸易模式上所做的分析工作和对经济活动的定位。 主要著作与经济思想： 其主要出版物为《期望减少的一代》、《国际经经济学》、《流行国际主义》等。他独自开创了国际贸易领域的垄断竞争理论，在李嘉图的比较优势理论基础上向前迈了一步。他的主要进步就是将完全竞争市场之外的市场模式，如寡头垄断的市场引入国际贸易模型，从而解释了许多传统贸易理论无法解释的贸易现象。 他还是经济地理理论的主要开创者，经济地理主要研究一些地区怎样和如何实现专业化，产业群如何给公司和经济带来好处等。 花旗集团 入选理由：花旗集团是当今世界资产规模最大、利润最多、全球连锁性最高、业务门类最齐全的金融服务集团。 主要职责：它在全球一百多个国家，为2亿客户，包括个人、机构、企业和政府部门，提供信贷、投资银行、经纪、保险、资产管理等广泛的金融产品服务。 发展历程： 花旗银行是一家古老的银行，1812年7月16日，华盛顿政府的第一任财政总监塞缪尔·奥斯古德上校与纽约的一位商人合伙创办了纽约城市银行——今日花旗银行的前身。纽约城市银行的英文名是CityBankofNewYork，这也就是为什么如今的花旗叫CityBank的原因。 20世纪初，改名为&quot;纽约国民银行&quot;的花旗银行开始积极发展海外业务，1902年，该行在伦敦开设了第一家分行，此后走上了国际化的道路。并且通过一些兼并和收购，逐渐发展壮大，到了1977年，花旗银行率先将大规模ATM机引入银行系统，用较低的成本大大地扩展了网络，从而一举成为美国最多的信用卡发行者。 第三部分 第46节：用经济学原理来看待生活，增进福利(4) 然而今天的花旗集团是由旅行者集团和花旗公司在1998年合并而来。在合并以前，旅行者集团和花旗银行是旗鼓相当的金融巨头，业务范围包括投资银行、商业信贷、融资服务等领域。1998年的旅行者与花旗的合并是美国有史以来最大的一次并购，并购之后花旗从世界500强第58位的排名一跃升至16位。合并后的花旗集团成为了一个金融巨人，能为世界上任何一个地区的客户提供任何的金融产品，这种竞争力是其他金融集团所无法比例的。从此花旗成为盈利能力最强的企业，具有强大的抗风险能力。 中国印象： 花旗集团在中国的历史可追溯至1902年5月，是首家在中国开业的美国银行。如今，花旗银行已是中国顶尖外资银行，为客户提供最广泛的金融产品。目前，花旗银行分别在北京、上海、广州、深圳和天津设立企业与投资银行分行；在上海和北京设立个人银行营业网点；在厦门和成都设有代表处；中国区总部也设在上海。 金融危机中的表现： 然而随着2008年全球金融危机的扩张，花旗集团损失惨重，和美国其他众多银行一样，资产负债表极为难看，美国政府对其进行注资580亿美元之后掌握了其34%的股份，对其进行了国有化。如今的花旗要想走出困境，还有很漫长的路要走。 国际货币基金组织（IMF） 入选理由：作为世界上两大金融机构之一，一直在国际经济活动中扮演着非常活跃的角色，尤其是在各种金融危机或经济危机之中。 主要职责：监察各国的货币汇率和贸易情况、提供技术和资金协助，确保全球金融制度正常运作，同时还在各成员国的经济发生危机之前进行预警。 组织架构： 国际货币基金组织是按照在布雷顿森林会议上签订的协议，于1945年12月27日成立的。1947年3月1日，正式运作。1947年11月15日成为联合国的专门机构，在经营上有其独立性。 临时委员会被看作国际货币基金组织的决策和指导机构。该委员会由24名董事组成，每个董事代表一个或数个国家。基金组织设有五个地区部门：非洲、亚洲、欧洲、中东和西半球，还设有12个职能部门：行政管理、中央银行业务、汇兑和贸易关系、对外关系、财政事务等。 国际货币基金组织的议事规则很有意思，实行加权投票表决制。每个成员国都有250票的基本投票权，这是相同的。差别在于加权投票权，加权投票权和各国所缴纳资金的份额成正比。目前IMF的投票权基本上都掌握在美国、日本和欧盟手里。美国目前在IMF中有16.8%的投票权，由于重大事项需要有85%的票额同意，所以美国实际上是拥有一票否决权的。 第三部分 第47节：用经济学原理来看待生活，增进福利(5) 中国印象： 中国是该组织创始国之一。1980年4月17日，该组织正式恢复中国的代表权。中国自1980年恢复在货币基金组织的席位后单独组成一个选区并派一名执行董事。1991年，该组织在北京设立常驻代表处。目前中国在国际货币基金组织的投票权已经增加到3.72%，位居世界第六。 金融危机中的表现： 一直以来，IMF在国际经济事务中都扮演着积极的角色，当某个经济体发生危机时，IMF会给受害国提供一定量的贷款，并增强人们对该经济体的信心。但是近年来，IMF在金融危机的预警上变得很迟钝。在亚洲金融危机爆发前，IMF还认为泰国的经济状况良好。并且IMF在给受害国贷款时往往会附加很多条件，比如进行经济改革、减少政府管制、进行自由贸易等，基本上都是华盛顿共识那一套，这些措施有时会给实施国带来灾难性的影响。 面对2008年影响全球的金融危机，IMF显得难以应付。首先在监管上就存在弊端，IMF一直都是把发展中国家的金融体系、汇率问题作为监管的重点，而对发达国家的金融安全却视而不见。另外在救援力度上也显得力不从心，由于本身的资金量有限，很难形成有效的大规模救援，只能眼看危机不断蔓延和扩大。此次金融危机，使要求对IMF进行改革的呼声变得越来越强烈。 世界银行 入选理由：世界银行作为两大国际金融机构之一，为国际经济的不断发展做出了卓越的贡献。战后帮助欧洲实现了复兴，如今又在帮助发展中国家走出困境。 主要职责：曾经帮助欧洲实现复兴，如今主要为发展中国家提供低息、无息贷款和捐赠，帮助他们建设教育、农业和工业基础设施等。 组织架构： 1946年6月25日世界银行开始运行，1947年5月9日它批准了第一笔贷款，向法国贷款2.5亿美元。世界银行具体包括五个机构，分别为：国际复兴开发银行，国际开发协会，世界金融公司，多边投资担保机构，国际投资争端解决中心。一国的政府可以决定它愿意成为哪些组织的成员，目前总共有184个成员政府，其中每个机构有140~176个成员政府不等。世界银行集团所有的机构都由24个成员组成的董事会领导，每个董事代表一个国家或一组国家。 和国际货币基金组织一样，世界银行业使用加权表决系统。每个国家拥有的表决权是不一样的，具体由两部分组成，一部分是基本表决权，这部分每个国家是相同的，另外一部分是加权表决权，这部分则根据成员国缴纳的会员费不同而不同。2004年11月1日，美国拥有16.4%的表决权，日本拥有7.9%的表决权，德国4.5%，英国4.3%，法国4.3%。由于任何重要决议都要有85%以上的表决权同意，所以美国实际上拥有一票否决权。世界银行的行长基本上都是美国人，其他国家即使欧洲也都没有机会。北京大学经济学教授林毅夫在2008年2月4日被任命为世界银行的高级副行长和首席经济学家，这是到目前为止中国人在世行里担任的最高职务。 中国印象： 1980年4月，邓小平会见世界银行行长麦克纳马拉，向其解释中国的改革开放政策，欢迎世界银行开展同中国的合作。同年5月12日，中国正式恢复在世界银行的合法席位。世界银行对中国的第一笔贷款是用来帮助中国的大学发展的，此后世界银行支持项目几乎遍及中国的各省、市、自治区和国民经济的各个部门，项目主要集中在交通、城市发展、农村发展、能源等领域。 金融危机中的表现： 世界银行的任务就是帮助发展中国家发展经济，使更多的人脱离贫困，但是2008年的金融危机使很多已经脱贫的人重新回到了贫困状态。所以世界银行启动紧急措施，加大对发展中国家的支持力度。2008年隶属世界银行的国际开发协会承诺与世界上最贫困的国家合作，三年内提供420亿美元的支持；同时世界银行旗下的国际复兴开发银行提供的贷款也由07年的135亿美元增加到350亿美元；世界银行旗下的国际金融公司也将在三年内提供300亿美元的资金帮助发展中国家进行基础设施建设。相信在这些措施的帮助下，发展中国家会尽快从危机中走出来，实现经济的快速发展。","categories":[{"name":"金融","slug":"金融","permalink":"http://yoursite.com/categories/金融/"},{"name":"投资","slug":"金融/投资","permalink":"http://yoursite.com/categories/金融/投资/"}],"tags":[]},{"title":"ORACLE 锁管理","slug":"软件开发/系统架构/数据存储/Oracle/ORACLE 锁管理","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:15:09.763Z","comments":true,"path":"passages/软件开发/系统架构/数据存储/Oracle/ORACLE 锁管理/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/数据存储/Oracle/ORACLE 锁管理/","excerpt":"","text":"ORACLE锁的管理ORACLE里锁有以下几种模式: 0：none 1：null 空 2：Row-S 行共享(RS)：共享表锁 3：Row-X 行专用(RX)：用于行的修改 4：Share 共享锁(S)：阻止其他DML操作 5：S/Row-X 共享行专用(SRX)：阻止其他事务操作 6：exclusive 专用(X)：独立访问使用 数字越大锁级别越高, 影响的操作越多。 查询语句锁级别一般的查询语句如select … from … ;是小于2的锁, 有时会在v$locked_object出现。select … from … for update; 是2的锁。 当对话使用for update子串打开一个游标时，所有返回集中的数据行都将处于行级(Row-X)独占式锁定，其他对象只能查询这些数据行，不能进行update、delete或select…for update操作。 修改语句锁级别insert / update / delete … ; 是3的锁。 没有commit之前插入同样的一条记录会没有反应,因为后一个3的锁会一直等待上一个3的锁, 我们必须释放掉上一个才能继续工作。 locked_mode为2,3,4不影响DML(insert,delete,update,select)操作,但DDL(alter,drop等)操作会提示ora-00054错误。 有主外键约束时 update / delete … ; 可能会产生4,5的锁。 创建索引锁级别创建索引的时候也会产生3,4级别的锁。 DDL语句锁级别DDL语句时是6的锁。 以DBA角色, 查看当前数据库里锁的情况可以用如下SQL语句： 1234select object_id,session_id,locked_mode from v$locked_object;select t2.username,t2.sid,t2.serial#,t2.logon_time from v$locked_object t1,v$session t2 where t1.session_id=t2.sid order by t2.logon_time; 如果有长期出现的一列，可能是没有释放的锁。我们可以用下面SQL语句杀掉长期没有释放非正常的锁：alter system kill session &#39;sid,serial#&#39;; 如果出现了锁的问题, 某个DML操作可能等待很久没有反应。 当你采用的是直接连接数据库的方式，也不要用OS系统命令 $kill process_num 或者 $kill -9 process_num来终止用户连接，因为一个用户进程可能产生一个以上的锁, 杀OS进程并不能彻底清除锁的问题。 记得在数据库级别用alter system kill session &#39;sid,serial#&#39;;杀掉不正常的锁。 ORACLE 锁 ORACLE数据库是现今数据库领域应用最广泛的，同时它也是一个庞大的系统，全面了解它、玩转它不但需要一定的理论知识，更需要开发经验与工程经验。本人是ORACLE一爱好者，以下是本人对ORACLE锁的一些经验，希望能与大家共同分享。 ORACLE锁具体分为以下几类： 1. 按用户与系统划分，可以分为自动锁与显示锁 自动锁：当进行一项数据库操作时，缺省情况下，系统自动为此数据库操作获得所有有必要的锁。 显示锁：某些情况下，需要用户显示的锁定数据库操作要用到的数据，才能使数据库操作执行得更好，显示锁是用户为数据库对象设定的。 2.按锁级别划分，可分为共享锁与排它锁 共享锁：共享锁使一个事务对特定数据库资源进行共享访问——另一事务也可对此资源进行访问或获得相同共享锁。共享锁为事务提供高并发性，但如拙劣的事务设计+共享锁容易造成死锁或数据更新丢失。 排它锁：事务设置排它锁后，该事务单独获得此资源，另一事务不能在此事务提交之前获得相同对象的共享锁或排它锁。 3.按操作划分，可分为DML锁、DDL锁DML锁又可以分为，行锁、表锁、死锁 行锁：当事务执行数据库插入、更新、删除操作时，该事务自动获得操作表中操作行的排它锁。 表级锁：当事务获得行锁后，此事务也将自动获得该行的表锁(共享锁),以防止其它事务进行DDL语句影响记录行的更新。事务也可以在进行过程中获得共享锁或排它锁，只有当事务显示使用LOCK TABLE语句显示的定义一个排它锁时，事务才会获得表上的排它锁,也可使用LOCK TABLE显示的定义一个表级的共享锁(LOCK TABLE具体用法请参考相关文档)。 死锁：当两个事务需要一组有冲突的锁，而不能将事务继续下去的话，就出现死锁。 如事务1在表A行记录#3中有一排它锁，并等待事务2在表A中记录#4中排它锁的释放，而事务2在表A记录行#4中有一排它锁，并等待事务; 1在表A中记录#3中排它锁的释放，事务1与事务2彼此等待，因此就造成了死锁。死锁一般是因拙劣的事务设计而产生。死锁只能使用SQL下:alter system kill session “sid,serial#”；或者使用相关操作系统kill进程的命令，如UNIX下kill -9 sid,或者使用其它工具杀掉死锁进程。 DDL锁又可以分为：排它DDL锁、共享DDL锁、分析锁 排它DDL锁：创建、修改、删除一个数据库对象的DDL语句获得操作对象的 排它锁。如使用alter table语句时，为了维护数据的完成性、一致性、合法性，该事务获得一排它DDL锁。 共享DDL锁：需在数据库对象之间建立相互依赖关系的DDL语句通常需共享获得DDL锁。如创建一个包，该包中的过程与函数引用了不同的数据库表，当编译此包时，该事务就获得了引用表的共享DDL锁。 分析锁：ORACLE使用共享池存储分析与优化过的SQL语句及PL/SQL程序，使运行相同语句的应用速度更快。一个在共享池中缓存的对象获得它所引用数据库对象的分析锁。分析锁是一种独特的DDL锁类型，ORACLE使用它追踪共享池对象及它所引用数据库对象之间的依赖关系。当一个事务修改或删除了共享池持有分析锁的数据库对象时，ORACLE使共享池中的对象作废，下次在引用这条SQL/PLSQL语句时，ORACLE重新分析编译此语句。 4.内部闩锁 内部闩锁：这是ORACLE中的一种特殊锁，用于顺序访问内部系统结构。当事务需向缓冲区写入信息时，为了使用此块内存区域，ORACLE首先必须取得这块内存区域的闩锁，才能向此块内存写入信息。","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"数据存储","slug":"软件开发/系统架构/数据存储","permalink":"http://yoursite.com/categories/软件开发/系统架构/数据存储/"},{"name":"Oracle","slug":"软件开发/系统架构/数据存储/Oracle","permalink":"http://yoursite.com/categories/软件开发/系统架构/数据存储/Oracle/"}],"tags":[]},{"title":"ORACLE 回滚段管理","slug":"软件开发/系统架构/数据存储/Oracle/ORACLE 回滚段管理","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:15:05.965Z","comments":true,"path":"passages/软件开发/系统架构/数据存储/Oracle/ORACLE 回滚段管理/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/数据存储/Oracle/ORACLE 回滚段管理/","excerpt":"","text":"[TOC] 回滚段管理一直是ORACLE数据库管理的一个难题，本文通过实例介绍ORACLE回滚段的概念，用法和规划及问题的解决。 回滚段概述回滚段用于存放数据修改之前的值（包括数据修改之前的位置和值）。回滚段的头部包含正在使用的该回滚段事务的信息。一个事务只能使用一个回滚段来存放它的回滚信息，而一个回滚段可以存放多个事务的回滚信息。 回滚段的作用 事务回滚：当事务修改表中数据的时候，该数据修改前的值（即前影像）会存放在回滚段中，当用户回滚事务（ROLLBACK）时，ORACLE将会利用回滚段中的数据前影像来将修改的数据恢复到原来的值。 事务恢复：当事务正在处理的时候，例程失败，回滚段的信息保存在重做日志文件中，ORACLE将在下次打开数据库时利用回滚来恢复未提交的数据。 读一致性：当一个会话正在修改数据时，其它的会话将看不到该会话未提交的修改。而且，当一个语句正在执行时，该语句将看不到从该语句开始执行后的未提交的修改（语句级读一致性）。当ORACLE执行SELECT语句时，ORACLE依照当前的系统改变号（SYSTEM CHANGE NUMBER-SCN）来保证任何前于当前SCN的未提交的改变不被该语句处理。可以想象：当一个长时间的查询正在执行时，若其它会话改变了该查询要查询的某个数据块，ORACLE将利用回滚段的数据前影像来构造一个读一致性视图。 事务级的读一致性ORACLE一般提供SQL语句级（SQL STATEMENT LEVEL）的读一致性，可以用以下语句来实现事务级的读一致性。 SET TRANSACTION READ ONLY；或：SET TANNSACTION SERIALIZABLE； 以上两个语句都将在事务开始后提供读一致性。需要注意的是，使用第二个语句对数据库的并发性和性能将带来影响。 回滚段的种类 系统回滚段：当数据库创建后，将自动创建一个系统回滚段，该回滚段只用于存放系统表空间中对象的前影像。 非系统回滚段：拥有多个表空间的数据库至少应该有一个非系统回滚段，用于存放非系统表空间中对象的数据前影像。非系统回滚段又分为私有回滚段和公有回滚段，私有回滚段应在参数文件的ROLLBACK SEGMENTS参数中列出，以便例程启动时自动使其在线（ONLINE）。公有回滚段一般在OPS（ORACLE并行服务器）中出现，将在例程启动时自动在线。 DEFERED回滚段：该回滚段在表空间离线（OFFLINE）时由系统自动创建，当表空间再次在线（ONLINE）时由系统自动删除，用于存放表空间离线时产生的回滚信息。 回滚段的使用分配回滚段：当事务开始时，ORACLE将为该事务分配回滚段，并将拥有最少事务的回滚段分配给该事务。事务可以用以下语句申请指定的回滚段： 1SET TRANSTRACTION USE ROLLBACK SEGMENT rollback_segment 事务将以顺序，循环的方式使用回滚段的区（EXTENTS），当当前区用满后移到下一个区。几个事务可以写在回滚段的同一个区，但每个回滚段的块只能包含一个事务的信息。 例如（两个事务使用同一个回滚段，该回滚段有四个区）： 事务在进行中，它们正在使用回滚段的第三个区； 当两个事务产生更多的回滚信息，它们将继续使用第三个区； 当第三个区满后，事务将写到第四个区，当事务开始写到一个新的区时，称为翻转（WRAP）； 当第四个区用满时，如果第一个区是空闲或非活动（使用该区的所有事务完成而没有活动的事务）的，事务将接着使用第一个区。 回滚段的扩张（EXTEND）当当前回滚段区的所有块用完而事务还需要更多的回滚空间时，回滚段的指针将移到下一个区。当最后一个区用完，指针将移到第一个区的前面。回滚段指针移到下一个区的前提是下一个区没有活动的事务，同时指针不能跨区。当下一个区正在使用时，事务将为回滚段分配一个新的区，这种分配称为回滚段的扩展。回滚段将一直扩展到该回滚段区的个数到达回滚段的参数MAXEXTENTS的值时为止。 回滚段的回收和OPTIMAL参数OPTIMAL参数指明回滚段空闲时收缩到的位置，指明回滚段的OPTIMAL参数可以减少回滚段空间的浪费。 创建回滚段 语法：123456CREATE [PUBLIC] ROLLBACK SEGMENT rollback_segment [TABLESPACE tablespace] [STORAGE ([INITIAL integer[K|M]] [NEXT integer[K|M]] [MINEXTENTS integer] [MAXTENTS &#123;integer|UNLIMITED&#125;] [OPTIMAL &#123;integer[K|M]|NULL&#125;]) ] 注： 回滚段可以在创建时指明PRIVATE或PUBLIC，一旦创建将不能修改。 MINEXTENTS 必须大于等于2 PCTINCREASE必须是0 OPTIMAL如果要指定，必须大于等于回滚段的初始大小（由MINEXTENTS指定） 建议： 一般情况下，INITIAL=NEXT 设置OPTIMAL参数来节约空间的使用 不要设置MAXEXTENTS为UNLIMITED 回滚段应创建在一个特定的回滚段表空间内 例：1234CREATE ROLLBACK SEGMENT rbs01 TABLESPACE rbs STORAGE ( INITIAL 100K NEXT 100K MINEXTENTS 10 MAXEXTENTS 500 OPTIMAL 1000K); 使回滚段在线 当回滚段创建后，回滚段是离线的，不能被数据库使用，为了使回滚段被事务利用，必须将回滚段在线。可以用以下命令使回滚段在线： 123ALTER ROLLBACK SEGMENT rollback_segment ONLINE; 例： ALTER ROLLBACK SEGMENT rbs01 ONLINE； 为了使回滚段在数据库启动时自动在线，可以在数据库的参数文件中列出回滚段的名字。例如在参数文件中加入以下一行： ROLLBACK_SEGMENT=(rbs01,rbs02) 修改回滚段的存储参数 可以使用ALTER ROLLBACK SEGMENT命令修改回滚段的存储参数（包括OPTIMAL，MAXEXTENTS）。 语法：1234567 ALTER ROLLBACK SEGMENT rollback_segment [STORAGE ([NEXT integer[K|M]] [MINEXTENTS integer] [MAXEXTENTS &#123;integer|UNLIMITED&#125;] [OPTIMAL &#123;integer[K|M]|NULL&#125;]) ] 例： ALTER ROLLBACK SEGMENT rbs01 STORAGE (MAXEXTENTS 1000); 回收回滚段的空间 如果指定了回滚段的OPTIMAL参数，ORACLE将自动回收回滚段到OPTIMAL指定的位置。用户也可以手动回收回滚段的空间。 语法：12345 ALTER ROLLBACK SEGMENT rollback_segment SHRINK [TO integer [K|M]]; 说明： 如果不指明TO integer的数值，ORACLE将试图回收到OPTIMAL的位置。 例： ALTER ROLLBACK SEGMENT rbs01 SHRINK TO 2M; 使回滚段离线 为了达到以下两个目的将要回滚段离线： 1.阻止新的事务使用该回滚段； 2.该回滚段必须删除。 语法： 123 ALTER ROLLBACK SEGMENT rollback_segment OFFLINE; 例： ALTER ROLLBACK SEGMENT rbs01 OFFLINE; 说明： 如果有事务正在使用该回滚段，运行该命令后，回滚段的状态将是PENDING OFFLINE。事务结束后，状态将改为OFFLINE，可以通过V$ROLLSTAT查询回滚段的状态。 删除回滚段 当回滚段不再需要或要重建以改变INITIAL，NEXT或MINEXTENTS参数时，可以将其删除。要删除回滚段，不许使该回滚段离线。 语法： DROP ROLLBACK SEGMENT rollback_segment;例： DROP ROLLBACK SEGMENT rbs01; 查询回滚段的信息 所用数据字典：DBA_ROLLBACK_SEGS 可以查询的信息：回滚段的标识(SEGMENT_ID)、名称(SEGMENT_NAME)、所在表空间(TABLESPACE_NAME)、类型(OWNER)、状态(STATUS)。 例： SQL&gt;SELECT segment_name,tablespace_name,owner,status FROM dba_rollback_segs; 回滚段的统计信息 数据字典：V$ROLLNAME,V$ROLLSTAT 例：123 SELECT n.name,s.extents,s.rssize,s.optsize,s.hwmsize,s.xacts,s.status FROM v$rollname n,v$rollstat s WHERE n.usn=s.usn; 回滚段的当前活动事务 数据字典：V$SESSION,V$TRANSACTION 例： 123SELECT s.username,t.xidusn,t.ubafil,t.ubablk,t.used_ublk FROM v$session s,v$transaction t WHERE s.saddr=t.ses_addr; USERNAME XIDUSN UBAFIL UBABLK USED_UBLK ——- ——– ———– ———– ———– SYSTEM 2 2 7 1 SCOTT 1 2 163 1 2 rows selected. 回滚段的数量规划 对于OLTP系统，存在大量的小事务处理，一般建议： 数量多的小回滚段；每四个事务一个回滚段；每个回滚段不要超过十个事务。 对于批处理，一般建议： 少的大回滚段；每个事务一个回滚段。 回滚段的问题及解决方法 问题一：事务要求的回滚段空间不够，表现为表空间用满（ORA-01560错误），回滚段扩展到达参数MAXEXTENTS的值（ORA-01628）。 解决方法：向回滚段表空间添加文件或使已有的文件变大；增加MAXEXTENTS的值。 问题二：读一致性错误（ORA-01555 SNAPSHOT TOO OLD） 解决方法：增加MINEXTENTS的值，增加区的大小，设置一个高的OPTIMAL值。","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"数据存储","slug":"软件开发/系统架构/数据存储","permalink":"http://yoursite.com/categories/软件开发/系统架构/数据存储/"},{"name":"Oracle","slug":"软件开发/系统架构/数据存储/Oracle","permalink":"http://yoursite.com/categories/软件开发/系统架构/数据存储/Oracle/"}],"tags":[]},{"title":"Oracle基础","slug":"软件开发/系统架构/数据存储/Oracle/Oracle基础","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:15:13.264Z","comments":true,"path":"passages/软件开发/系统架构/数据存储/Oracle/Oracle基础/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/数据存储/Oracle/Oracle基础/","excerpt":"","text":"Oracle的体系结构Oracle 中两个比较容易混淆的词，实例(instance)和数据库(database) 数据库：物理操作系统文件或磁盘的集合。 实例：一组Oracle后台进程/线程以及一个共享内存区，这些内存由同一个计算机上运行的线程/进程所共享。 两者之间的关系：实例是一组后台进程和共享内存。数据库是磁盘上存储的数据集合。实例“一生”只能装载并打开一个数据库。数据库可以由一个或多个实例（使用RAC）装载和打开。 Oracle有一个很大有内存块称为系统全局区(SGA)，有一组“附加到”SGA的进程，附加机制因操作系统而异，在unix中是多进程，在windows中是单进程多线程。 Oracle的文件数据文件数据库由一个或多个表空间构成。表空间是Oracle中的一个逻辑存储容器，位于存储层次体系的顶层，包括一个或多个数据文件 Oracle的存储层次如下： 数据库由一个或多个表空间组成 表空间由一个或多个数据文件组成。这些文件可以是文件系统中的cooked文件、原始分区、ASM管理的数据库文件、或集群文件系统上的文件。表空间包含段 段(TABLE、INDEX等)由一个或多个区段组成。段在表空间中，但可以包含这个表空间中多个数据文件中的数据。 区段是磁盘上一组连续的块。区段只在一个表空间中，而且总是在该表空间内的一个文件中。 块是数据库最小的分配单位，也是数据库使用的最小I/O单位 索引索引数据结构选择B+树而不是其他数据结构的原因主要是因为数据是保存在硬盘上而不是内存中，所以减少磁盘IO次数才是提升效率的关键","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"数据存储","slug":"软件开发/系统架构/数据存储","permalink":"http://yoursite.com/categories/软件开发/系统架构/数据存储/"},{"name":"Oracle","slug":"软件开发/系统架构/数据存储/Oracle","permalink":"http://yoursite.com/categories/软件开发/系统架构/数据存储/Oracle/"}],"tags":[]},{"title":"大数据","slug":"软件开发/系统架构/数据存储/大数据/大数据","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:15:25.262Z","comments":true,"path":"passages/软件开发/系统架构/数据存储/大数据/大数据/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/数据存储/大数据/大数据/","excerpt":"","text":"关系型数据库遵循ACID规则事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性： A (Atomicity) 原子性原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。 C (Consistency) 一致性一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。 I (Isolation) 独立性所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。 D (Durability) 持久性持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。 RDBMS vs NoSQLRDBMS 高度组织化结构化数据 结构化查询语言（SQL） (SQL) 数据和关系都存储在单独的表中。 数据操纵语言，数据定义语言 严格的一致性 基础事务 NoSQL 代表着不仅仅是SQL 没有声明性查询语言 没有预定义的模式 键 - 值对存储，列存储，文档存储，图形数据库 最终一致性，而非ACID属性 非结构化和不可预知的数据 CAP定理 高性能，高可用性和可伸缩性 CAP定理（CAP theorem）在计算机科学中, CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer’s theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点: 一致性(Consistency) (所有节点在同一时间具有相同的数据) 可用性(Availability) (保证每个请求不管成功或者失败都有响应) 分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类： CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。 CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。 AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。 NoSQL的优点/缺点优点: 高可扩展性 分布式计算 低成本 架构的灵活性，半结构化数据 没有复杂的关系 缺点: 没有标准化 有限的查询功能（到目前为止） 最终一致是不直观的程序 BASEBASE：Basically Available, Soft-state, Eventually Consistent。 由 Eric Brewer 定义。CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。BASE是NoSQL数据库通常对可用性及一致性的弱要求原则: Basically Availble –基本可用 Soft-state –软状态/柔性事务。 “Soft state” 可以理解为”无连接”的, 而 “Hard state” 是”面向连接”的 Eventual Consistency –最终一致性 最终一致性， 也是是 ACID 的最终目的。","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"数据存储","slug":"软件开发/系统架构/数据存储","permalink":"http://yoursite.com/categories/软件开发/系统架构/数据存储/"},{"name":"大数据","slug":"软件开发/系统架构/数据存储/大数据","permalink":"http://yoursite.com/categories/软件开发/系统架构/数据存储/大数据/"}],"tags":[]},{"title":"Mongodb","slug":"软件开发/系统架构/数据存储/大数据/Mongodb","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-25T03:02:39.869Z","comments":true,"path":"passages/软件开发/系统架构/数据存储/大数据/Mongodb/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/数据存储/大数据/Mongodb/","excerpt":"","text":"MongoDBMongoDB文档模型的好处MongoDB是文档型数据库，是Schema Free的 1、json形式在MongoDB中，开发人员可以直接将一个json数据存储进MongoDB，这对于开发人员来说是非常友好额； 2、读写性能高在关系型数据库中，我们经常会进行join、子查询等关联性需求，这时候往往会带来较多的随机IO，而在MongoDB中，我们可以通过合理的数据模型设计来将很多的关联需求通过内嵌、反范式的方式实现，减少了随机IO； 3、schema freeMongoDB的数据模型是灵活的，无需为了Online DDL而操心，不同的document也可以有不同的结构。 MongoDB的可以通过内嵌来减少联合查询的需求，可以通过反范式来减少随机IO Document ValidationMongoDB 3.2推出了Document Validation，Document Validation, MongoDB官方想表达”schema free but you may need some rules phone字段为string类型或者email字段要匹配”@mongodb.com”结尾，或者status为”Unknown”或者”Incomplete” 1234567db.createCollection(&quot;contacts&quot;, &#123; validator: &#123;$or: [ &#123; phone: &#123;$type:&quot;string&quot;&#125;&#125;, &#123; email: &#123;$regex:/@mongodb\\.com$/&#125;&#125;, &#123; status: &#123;$in:[&quot;Unknown&quot;,&quot;Incomplete&quot;]&#125;&#125; ]&#125;&#125;) 多了一个validationLevel参数，我们可以在设置validation的时候指定我们的validationLevel级别： 默认级别是strict，对该collection已有的和以后新增的document都进行validation验证； 可以设置为moderate，仅对已经存在的document进行validation限定； 同时还有validationAction参数来指定当有不符合validation规则的数据进行update或者insert的时候， 我们mongodb实例如何进行处理。 默认级别为error，mongodb将拒绝这些不符合validation规则的insert和update。 可以设置为warn，mongodb会在日志中记录，但是允许这类insert和update操作。 MongoDB ACID事务支持MongoDB对原子性（Atomicity）的支持Mongodb的原子性是单行/文档级原子性 对于关系型数据库的多行、多文档、多语句原子性目前Mongodb是不支持的 可以通过建模让mongodb支持多文档原子性，MongoDB不是范式而是反范式的设计，通过大表和小表可以把相关的数据放到同一个文档中去。然后通过一条语句来执行操作 MongoDB最新的4.0版本开始支持多文档事务，MongoDB的多文档事务仅适用于使用WiredTiger存储引擎的服务器，且当前仅支持单个副本集。4.2版本将带来分片集群支持。 MongoDB对一致性（consistency）的支持MongoDB的可调一致性，也就是可以自由选择强一致性或最终一致性，如果你的应用场景是前台的方式可以选择强一致性，如果你的应用场景是后台的方式（如报表）可以选择弱一致。在NoSQL中，通常有两个层次的一致性：第一种是强一致性，既集群中的所有机器状态同步保持一致。第二种是最终一致性，既可以允许短暂的数据不一致，但数据最终会保持一致。 CAP首先我们来了解一下什么是CAP理论，其核心是：一个分布式系统不可能同时很好的满足 一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。 一致性(Consistency) ：所有节点在同一时间具有相同的数据； 可用性(Availability) ：保证每个请求不管成功或者失败都有响应； 分区容错性(Partition tolerance) ：系统中任意信息的丢失或失败不会 影响系统的继续运作，即可靠性。 而MongoDB通过复制集和分片技术很好的满足了CP原则。 要保证数据强一致性，最简单的方法是令写操作在所有数据节点上都执行成功才能返回成功，也就是同步概念。而这时如果某个结点出现故障，那么写操作就成功不了了，需要一直等到这个节点恢复。也就是说，如果要保证强一致性，那么就无法提供7×24的高可用性。 而要保证可用性的话，就意味着节点在响应请求时，不用完全考虑整个集群中的数据是否一致。只需要以自己当前的状态进行请求响应。由于并不保证写操作在所有节点都写成功，这可能会导致各个节点的数据状态不一致。 CAP理论导致了最终一致性和强一致性两种选择。当然，事实上还有其它的选择，比如在Yahoo的PNUTS中，采用的就是松散的一致性和弱可用性结合的方法。但是我们讨论的NoSQL系统没有类似的实现，所以我们在后续不会对其进行讨论。 MongoDB对隔离性（isolation）的支持在关系型数据库中，SQL2定义了四种隔离级别，分别是READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。但是很少有数据库厂商遵循这些标准，比如Oracle数据库就不支持READ UNCOMMITTED和REPEATABLE READ隔离级别。而MySQL支持这全部4种隔离级别。每一种级别都规定了一个事务中所做的修改，哪些在事务内核事务外是可见的，哪些是不可见的。为了尽可能减少事务间的影响，事务隔离级别越高安全性越好但是并发就越差；事务隔离级别越低，事务请求的锁越少，或者保持锁的时间就越短，这也就是为什么绝大多数数据库系统默认的事务隔离级别是RC。MongoDB在3.2之前使用的是“读未提交”，这种情况下会出现“脏读”。但在MongoDB 3.2开始已经调整为“读已提交”。 下面说说每种隔离级别带来的问题： READ-UNCOMMITTED（读尚未提交的数据）在这个级别，一个事务的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为“脏读（dirty read）”。这个级别会导致很多问题，从性能上来说，READ UNCOMMITTED不会比其他的级别好太多，但却缺乏其他级别的很多好处，除非真的有非常必要的理由，在实际应用中一般很少使用。 READ-COMMITTED（读已提交的数据）在这个级别，能满足前面提到的隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫“不可重复读（non-repeatable read）”，因为两次执行同样的查询，可能会得到不一样的结果。 REPEATABLE-READ（可重复读）在这个级别，保证了在同一个事务中多次读取统一记录的结果是一致的。MySQL默认使用这个级别。InnoDB和XtraDB存储引擎通过多版本并发控制MVCC（multiversion concurrency control）解决了“幻读”和“不可重复读”的问题。通过前面的学习我们知道RR级别总是读取事务开始那一刻的快照信息，也就是说这些数据数据库当前状态，这在一些对于数据的时效特别敏感的业务中，就很可能会出问题。 SERIALIZABLE（串行化）在这个级别，它通过强制事务串行执行，避免了前面说的一系列问题。简单来说，SERIALIZABLE会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。实际应用中也很少在本地事务中使用SERIALIABLE隔离级别，主要应用在InnoDB存储引擎的分布式事务中。 MongoDB对持久性（durability）的支持在传统数据库中（单机）的表现为服务器任何时候发生宕机都不需要担心数据丢失的问题，因为有方式可以把数据永久保存起来了 MongoDB同样是使用数据进来先写日志（日志刷盘的速度是非常快）然后在写入到数据库中的这种方式来保证数据的持久性，如果出现服务器宕机，当启动服务器时会从日志中读取数据。不同的是传统数据库这种方式叫做“WAL” Write-Ahead Logging（预写日志系统），而MongoDB叫做“journal”。此外MongoDB在数据持久性上这点可能做的更好，MongoDB的复制默认节点就是三节点以上的复制集群，当数据到达主节点之后会马上同步到从节点上去。 MongoDB 集群mongodb的集群搭建方式主要有三种，主从模式，Replica set模式，sharding模式, 三种模式各有优劣，适用于不同的场合，属Replica set应用最为广泛，主从模式现在用的较少，sharding模式最为完备，但配置维护较为复杂 高可用（多副本Replication)Mongodb的Replica Set即副本集方式主要有两个目的，一个是数据冗余做故障恢复使用，当发生硬件故障或者其它原因造成的宕机时，可以使用副本进行恢复。另一个是做读写分离，读的请求分流到副本上，减轻主（Primary）的读压力。 Mongo 副本集是多个mongod实例，一般为3个，一个primary二个Secondary.Primary 把所有的数据修改存入operation log(oplog), Secondaries异步复制 Primary的oplog把数据修改入自己的数据集。如果Primary不可用，Secondary会开始一个选举，选出一个新的Primary. 一个 primary实例. 两个secondary 实例. 两个 secondaries 都可以通过选举成为 primary. 还有另外一种创建副本集的方式，如果Primary和Secondary的个数是偶数个，可以加一个Arbiter做为仲裁节点，它不保存数据。加入Arbiter的目的是为了维护quorun机制来相应其他实例的heartbeat和election请求。Arbiter不保存数据，所以是非常轻量，可以不用独立的服务器。 一个 primary实例. 一个secondary 实例. secondary 都可以通过选举成为 primary. 一个 arbiter. arbiter在选举中只能投票，不能成为实例节点. 选举机制MongoDB节点之间维护心跳检查，主节点选举由心跳触发。MongoDB复制集成员会向自己之外的所有成员发送心跳并处理响应信息，因此每个节点都维护着从该节点POV看到的其他所有节点的状态信息。节点根据自己的集群状态信息判断是否需要发起选举。 Quorom 机制，是一种分布式系统中常用的，用来保证数据冗余和最终一致性的投票算法。每个实例和其他实例同步Heartbeat和vote。 一种非常常用的选举 leader 的方式是“Majority Vote”（“少数服从多数”），但 Kafka 并未采用这种方式。这种模式下，如果我们有 2f+1 个 Replica（包含 Leader 和 Follower），那在 commit 之前必须保证有 f+1 个 Replica 复制完消息，为了保证正确选出新的 Leader，fail 的 Replica 不能超过 f 个。因为在剩下的任意 f+1 个 Replica 里，至少有一个 Replica 包含有最新的所有消息。这种方式有个很大的优势，系统的 latency 只取决于最快的几个 Broker，而非最慢那个。Majority Vote 也有一些劣势，为了保证 Leader Election 的正常进行，它所能容忍的 fail 的 follower 个数比较少。如果要容忍 1 个 follower 挂掉，必须要有 3 个以上的 Replica，如果要容忍 2 个 Follower 挂掉，必须要有 5 个以上的 Replica。也就是说，在生产环境下为了保证较高的容错程度，必须要有大量的 Replica，而大量的 Replica 又会在大数据量下导致性能的急剧下降 Server选择算法MongoDB drivers使用Server选择算法来决定哪个副本集中的成员来读写，Mongo可以控制读写分离，虽然默认是从Primary读写。Server的选择在每次读写操作时发生，在配置里由read preference 和 localThresholdMS 决定。Multi-document 事物包含读操作必须使用read preference 为 primary. 水平扩展(分片Sharding)当MongoDB复制集遇到下面的业务场景时，就需要考虑使用分片-存储容量需求超出单机磁盘容量；-活跃的数据集超出单机内存容量，导致很多请求都要从磁盘读取数据，影响性能；-写IOPS超出单个MongoDB节点的写服务能力。 shard: 可以是一个副本集或单独的mongod进程，保存分片后的集合数据. mongos: 如果每个分片都包含部分集群数据，那么还需要一个接口连接整个集群。这就是mongos。mongos进程是一个路由器，将所有的读写请求指引到合适的分片上。如此一来，mongos为客户端提供了一个合理的系统视图.mongos是轻量级且非持久化的，第一次启动或者关掉重启就会从 config server 加载配置信息，以后如果配置服务器信息变化会通知到所有的 mongos 更新自己的状态，这样 mongos 就能继续准确路由。 config servers: 持久化了分片集群的元数据，改数据包括：每个数据库，集合和特定范围数据的位置；一份变更记录，保存了数据在分片之间进行迁移的历史信息.配置服务器中保存的元数据是某些特定功能和集群维护是的重中之重。举例来说，每次有mongos进程启动，它都会从配置服务器中获取一份元数据的副本。没有这些数据，就无法获得一致的分片集群视图。在生产环境通常有多个 config server 配置服务器来提高可用性。 MongoDB 分片在collection级别, collection中的数据分布在多个shard上. 块(chunk): MongoDB将数据拆分为chunk，每个chunk都是collection中的一段连续的数据记录，为防止一个chunk变的越来越大，当一个chunk增加到特定大小时，会被自动拆分为两个较小的chunk。 Sharding 策略Hashed Sharding: 哈希分片根据shard key计算hash值。每个chunk安排了一个hash过的shard key值范围 Ranged Sharding: 范围分片是根据shard key的值的范围把数据分布不同的shard上。 读写路由请求如果包含了shard key或着包含shard key为前缀，mongos能够把查询定位到特定的shard集。这种定位的查询方式比广播到所有的shard性能高了很多。如果查询不包含shard key，mongos会执行一个广播操作，查询所有的shards。这种分散和聚合的查询消耗更多的时间 Chunk自动均衡(拆分与迁移)MongoDB将数据拆分为chunk，每个chunk都是collection中的一段连续的数据记录，为防止一个chunk变的越来越大，当一个chunk增加到特定大小时，会被自动拆分为两个较小的chunk。所有自动均衡和移动都是基于Chunk 为了使得数据相对平均的分布到所有的shard上，Mongodb有一个balancer运行在后台来自动调整chunks在多个shard中的分布。 分片机制的重点是块的拆分（spliting）与迁移（migration） 首先，考虑一下块拆分的思想。在初始化分片集群时，只存在一个块，这个块的范围涵盖了整个分片集合。那该如何发展到有多个块的分片集群呢？答案就是块大小达到某个阈值是就会对块进行拆分。默认的块的最大块尺寸时64MB或者100000个文档，先达到哪个标准就以哪个标准为准。在向新的分片集群添加数据时，原始的块最终会达到某个阈值，触发块的拆分。这是一个简单的操作，基本就是把原来的范围一分为二，这样就有两个块，每个块都有相同数量的文档。 块的拆分是个逻辑操作。当MongoDB进行块拆分时，它只是修改块的元数据就能让一个块变为两个。因此，拆分一个块并不影响分片集合里文档的物理顺序。也就是说拆分既简单又快捷。 设计分片系统时最大的一个困难就是保证数据始终均匀分布。MongoDB的分片集群是通过在分片中移动块来实现均衡的。我们称之为迁移，这是一个真实的物理操作。 迁移是由名为均衡器（balancer）的软件进程管理的，它的任务就是确保数据在各个分片中保持均匀变化。通过追踪各分片上块的数量，就能实现这个功能。虽然均衡的触发会随总数据量的不同而变化，但是通常来说，当集群中拥有块最多的分片与拥有块最少的分片的块数相差大于8时，均衡器就会发起一次均衡处理。在均衡过程中，块会从块较多的分片迁移到块较少非分片上，直到两个分片的块数大致相等为止。 读写分离官网中建议不使用向从节点取数据。原因： 1、 所有的从节点拥有与主节点一样的写入负载，读的加入会增加其负载2、 对于分片的集合，在平衡器的关系下，数据的返回结果可能会缺失或者重复某部分数据。3、 相对而言，官方建议使用shard来分散读写请求。 使用的场景； 1、 异地的分布式部署2、 故障切换，在紧急情况下向从节点读数据 支持五种 read preference模式：1.primary：主节点，默认模式，读操作只在主节点，如果主节点不可用，报错或者抛出异常。2.primaryPreferred：首选主节点，大多情况下读操作在主节点，如果主节点不可用，如故障转移，读操作在从节点。3.secondary：从节点，读操作只在从节点，如果从节点不可用，报错或者抛出异常。4.secondaryPreferred：首选从节点，大多情况下读操作在从节点，特殊情况（如单主节点架构）读操作在主节点。5.nearest：最邻近节点，读操作在最邻近的成员，可能是主节点或者从节点，关于最邻近的成员请参考。 总结：副本集不是为了提高读性能存在的，在进行oplog的时候，读操作时被阻塞的。提高读取性能应该使用分片和索引，它的存在更多是作为数据冗余，备份。尤其当主库本来就面临着大量的写入压力，对于副本集的节点，也同样会面临写的压力。 基于对write concern、read concern、read reference的理解，我们可以得出以下结论。 默认情况（w：1、readconcern：local）如果read preference为primary，那么是可以读到最新的数据，强一致性；但如果此时primary故障，那么这个时候会返回错误，可用性得不到保证默认情况（w：1、readconcern：local）如果read preference为secondary（secondaryPreferred、primaryPreferred），虽然可能读到过时的数据，但能够立刻得到数据，可用性比较好writeconern：majority保证写入的数据不会被回滚; readconcern：majority保证读到的一定是不会被回滚的数据若（w：1、readconcern；majority）即使是从primary读取，也不能保证一定返回最新的数据，因此是弱一致性若（w: majority、readcocern：majority），如果是从primary读取，那么一定能读到最新的数据，且这个数据一定不会被回滚，但此时写可用性就差一些；如果是从secondary读取，不能保证读到最新的数据，弱一致性。 创建Shardingcreate folder 7001/data/dbcreate folder 7002/data/dbcreate folder 7003/data/db Start each member of the replica set with the appropriate options ~/Work/Develop/mongodb-linux-4.0.5/bin/mongod –replSet “rs0” –bind_ip localhost –port 7001 –dbpath ~/Work/Develop/mongodb-linux-4.0.5/7001/data/db –logpath ~/Work/Develop/mongodb-linux-4.0.5/7001/log/mongo.log &amp; ~/Work/Develop/mongodb-linux-4.0.5/bin/mongod –replSet “rs0” –bind_ip localhost –port 7002 –dbpath ~/Work/Develop/mongodb-linux-4.0.5/7002/data/db –logpath ~/Work/Develop/mongodb-linux-4.0.5/7002/log/mongo.log &amp; ~/Work/Develop/mongodb-linux-4.0.5/bin/mongod –replSet “rs0” –bind_ip localhost –port 7003 –dbpath ~/Work/Develop/mongodb-linux-4.0.5/7003/data/db –logpath ~/Work/Develop/mongodb-linux-4.0.5/7003/log/mongo.log &amp; Connect a mongo shell to one of the mongod instances ~/Work/Develop/mongodb-linux-4.0.5/bin/mongo –port 7001 Initiate the replica set. rs.initiate( { _id : “rs0”, members: [ { _id: 1, host: “localhost:7001” }, { _id: 2, host: “localhost:7002” }, { _id: 3, host: “localhost:7003” } ]}) View the replica set configuration, Create and populate a new collection rs.conf()rs.status() 12345678910use testvar bulk = db.test_collection.initializeUnorderedBulkOp();people = [&quot;Marc&quot;, &quot;Bill&quot;, &quot;George&quot;, &quot;Eliot&quot;, &quot;Matt&quot;, &quot;Trey&quot;, &quot;Tracy&quot;, &quot;Greg&quot;, &quot;Steve&quot;, &quot;Kristina&quot;, &quot;Katie&quot;, &quot;Jeff&quot;];for(var i=0; i&lt;1000000; i++)&#123; user_id = i; name = people[Math.floor(Math.random()*people.length)]; number = Math.floor(Math.random()*10001); bulk.insert( &#123; &quot;user_id&quot;:user_id, &quot;name&quot;:name, &quot;number&quot;:number &#125;);&#125;bulk.execute(); db.getCollection(“test_collection”).find() Restart the Replica Set as a Shard Restart secondary members with the –shardsvr option ~/Work/Develop/mongodb-linux-4.0.5/bin/mongod –replSet “rs0” –shardsvr –bind_ip localhost –port 7002 –dbpath ~/Work/Develop/mongodb-linux-4.0.5/7002/data/db –logpath ~/Work/Develop/mongodb-linux-4.0.5/7002/log/mongo.log &amp; ~/Work/Develop/mongodb-linux-4.0.5/bin/mongod –replSet “rs0” –shardsvr –bind_ip localhost –port 7003 –dbpath ~/Work/Develop/mongodb-linux-4.0.5/7003/data/db –logpath ~/Work/Develop/mongodb-linux-4.0.5/7003/log/mongo.log &amp; Step down the primary, Restart the primary with the –shardsvr option rs.stepDown() ~/Work/Develop/mongodb-linux-4.0.5/bin/mongod –replSet “rs0” –shardsvr –bind_ip localhost –port 7001 –dbpath ~/Work/Develop/mongodb-linux-4.0.5/7001/data/db –logpath ~/Work/Develop/mongodb-linux-4.0.5/7001/log/mongo.log &amp; Deploy Config Server Replica Set and mongoscreate folder 7001/configdb/dbcreate folder 7002/configdb/dbcreate folder 7003/configdb/db Deploy the config servers as a three-member replica set 12345~/Work/Develop/mongodb-linux-4.0.5/bin/mongod --configsvr --replSet configReplSet --bind_ip localhost --port 6001 --dbpath ~/Work/Develop/mongodb-linux-4.0.5/6001/data/configdb --logpath ~/Work/Develop/mongodb-linux-4.0.5/6001/log/mongoconfig.log &amp;~/Work/Develop/mongodb-linux-4.0.5/bin/mongod --configsvr --replSet configReplSet --bind_ip localhost --port 6002 --dbpath ~/Work/Develop/mongodb-linux-4.0.5/6002/data/configdb --logpath ~/Work/Develop/mongodb-linux-4.0.5/6002/log/mongoconfig.log &amp;~/Work/Develop/mongodb-linux-4.0.5/bin/mongod --configsvr --replSet configReplSet --bind_ip localhost --port 6003 --dbpath ~/Work/Develop/mongodb-linux-4.0.5/6003/data/configdb --logpath ~/Work/Develop/mongodb-linux-4.0.5/6003/log/mongoconfig.log &amp; Connect a mongo shell to one of the config servers and run rs.initiate() to initiate the replica set. ~/Work/Develop/mongodb-linux-4.0.5/bin/mongo –port 6001 rs.initiate( { _id : “configReplSet”, configsvr: true, members: [ { _id: 1, host: “localhost:6001” }, { _id: 2, host: “localhost:6002” }, { _id: 3, host: “localhost:6003” } ]}) Start a mongos instance start the mongos specifying the config server replica set name followed by a slash / and at least one of the config server hostnames and ports ~/Work/Develop/mongodb-linux-4.0.5/bin/mongos –configdb configReplSet/localhost:6001,localhost:6002,localhost:6003 –bind_ip localhost –port 6000 –logpath ~/Work/Develop/mongodb-linux-4.0.5/log/mongos.log &amp; Add Initial Replica Set as a ShardThe following procedure adds the initial replica set rs0 as a shard. Connect a mongo shell to the mongos ~/Work/Develop/mongodb-linux-4.0.5/bin/mongo localhost:6000/admin Add the shard Add a shard to the cluster with the sh.addShard method: sh.addShard( “rs0/localhost:7001,localhost:7002,localhost:7003” ) Add Second Shard Start each member of the replica set with the appropriate options. ~/Work/Develop/mongodb-linux-4.0.5/bin/mongod –replSet “rs1” –bind_ip localhost –port 8001 –dbpath ~/Work/Develop/mongodb-linux-4.0.5/8001/data/db –logpath ~/Work/Develop/mongodb-linux-4.0.5/8001/log/mongo.log &amp; ~/Work/Develop/mongodb-linux-4.0.5/bin/mongod –replSet “rs1” –bind_ip localhost –port 8002 –dbpath ~/Work/Develop/mongodb-linux-4.0.5/8002/data/db –logpath ~/Work/Develop/mongodb-linux-4.0.5/8002/log/mongo.log &amp; ~/Work/Develop/mongodb-linux-4.0.5/bin/mongod –replSet “rs1” –bind_ip localhost –port 8003 –dbpath ~/Work/Develop/mongodb-linux-4.0.5/8003/data/db –logpath ~/Work/Develop/mongodb-linux-4.0.5/8003/log/mongo.log &amp; Connect a mongo shell to one of the mongod instances ~/Work/Develop/mongodb-linux-4.0.5/bin/mongo –port 8001 Initiate the replica set. rs.initiate( { _id : “rs1”, members: [ { _id: 1, host: “localhost:8001” }, { _id: 2, host: “localhost:8002” }, { _id: 3, host: “localhost:8003” } ]}) Connect a mongo shell to the mongos ~/Work/Develop/mongodb-linux-4.0.5/bin/mongo localhost:6000/admin Add the shard Add a shard to the cluster with the sh.addShard method: sh.addShard( “rs1/localhost:8001,localhost:8002,localhost:8003” ) Shard a Collection Connect a mongo shell to the mongos ~/Work/Develop/mongodb-linux-4.0.5/bin/mongo localhost:6000/admin Enable sharding for a database. Before you can shard a collection, you must first enable sharding for the collection’s database. Enabling sharding for a database does not redistribute data but makes it possible to shard the collections in that database sh.enableSharding( “test” ) Create an index on the shard key Before sharding a non-empty collection, create an index on the shard key use testdb.test_collection.createIndex( { number : 1 } )db.test.insert( { test : “mvc” } ) Shard the collection In the test database, shard the test_collection, specifying number as the shard key. Run in mongos use testsh.shardCollection( “test.test_collection”, { “number” : 1 } ) The balancer redistributes chunks of documents when it next runs. As clients insert additional documents into this collection, the mongos routes the documents to the appropriate shard. Confirm the shard is balancing. Run in mongos use testdb.stats()db.printShardingStatus() 常用命令~/Work/Develop/mongodb-linux-4.0.5/bin/mongodump –host 127.0.0.1 –port 27017 –db stockminingnew –out ~/Work/Develop/mongodb/dbdump mongodump -h 127.0.0.1:27017 –db stockminingnew –out ~/Work/Develop/mongodb/dbdump mongodump -h 127.0.0.1:27017 –db stockminingnew –out ~/Work/Develop/mongodb/dbdumpmongorestore -h 127.0.0.1:27017 -d stockminingnew /home/oliver/mongo/dbdump","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"数据存储","slug":"软件开发/系统架构/数据存储","permalink":"http://yoursite.com/categories/软件开发/系统架构/数据存储/"},{"name":"大数据","slug":"软件开发/系统架构/数据存储/大数据","permalink":"http://yoursite.com/categories/软件开发/系统架构/数据存储/大数据/"}],"tags":[]},{"title":"Sql优化","slug":"软件开发/系统架构/数据存储/Oracle/Sql优化","date":"2019-05-24T14:06:47.000Z","updated":"2019-05-24T15:15:16.309Z","comments":true,"path":"passages/软件开发/系统架构/数据存储/Oracle/Sql优化/","link":"","permalink":"http://yoursite.com/passages/软件开发/系统架构/数据存储/Oracle/Sql优化/","excerpt":"","text":"[TOC] ####（1）选择最有效率的表名顺序(只在基于规则的优化器中有效)： Oracle的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表(基础表 driving table)将被最先处理，在FROM子句中包含多个表的情况下,你必须选择记录条数最少的表作为基础表。如果有3个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表。 （2）WHERE子句中的连接顺序：Oracle采用自下而上的顺序解析WHERE子句,根据这个原理,表之间的连接必须写在其他WHERE条件之前, 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾。 （3）SELECT子句中避免使用‘*’：Oracle在解析的过程中, 会将‘*’依次转换成所有的列名, 这个工作是通过查询数据字典完成的, 这意味着将耗费更多的时间。 （4）减少访问数据库的次数：Oracle在内部执行了许多工作: 解析SQL语句, 估算索引的利用率, 绑定变量 , 读数据块等。 （5）在SQLPlus , SQLForms和Pro*C中重新设置ARRAYSIZE参数, 可以增加每次数据库访问的检索数据量 ,建议值为200。（6）使用DECODE函数来减少处理时间：使用DECODE函数可以避免重复扫描相同记录或重复连接相同的表。 （7）整合简单,无关联的数据库访问：如果你有几个简单的数据库查询语句,你可以把它们整合到一个查询中(即使它们之间没有关系)。 （8）删除重复记录：最高效的删除重复记录方法 ( 因为使用了ROWID)例子： 12DELETE FROM EMP E WHERE E.ROWID &gt; (SELECT MIN(X.ROWID) FROM EMP X WHERE X.EMP_NO = E.EMP_NO); （9）用TRUNCATE替代DELETE：当删除表中的记录时,在通常情况下, 回滚段(rollback segments ) 用来存放可以被恢复的信息. 如果你没有COMMIT事务,ORACLE会将数据恢复到删除之前的状态(准确地说是恢复到执行删除命令之前的状况) 而当运用TRUNCATE时, 回滚段不再存放任何可被恢复的信息。当命令运行后,数据不能被恢复.因此很少的资源被调用,执行时间也会很短。（TRUNCATE只在删除全表适用,TRUNCATE是DDL不是DML）。 （10）尽量多使用COMMIT：只要有可能，在程序中尽量多使用COMMIT, 这样程序的性能得到提高,需求也会因为COMMIT所释放的资源而减少，COMMIT所释放的资源: a. 回滚段上用于恢复数据的信息。b. 被程序语句获得的锁。c. redo log buffer 中的空间。d. Oracle为管理上述3种资源中的内部花费。 （11）用Where子句替换HAVING子句：避免使用HAVING子句, HAVING 只会在检索出所有记录之后才对结果集进行过滤。这个处理需要排序,总计等操作. 如果能通过WHERE子句限制记录的数目，那就能减少这方面的开销。(非oracle中)on、where、having这三个都可以加条件的子句中，on是最先执行，where次之，having最后，因为on是先把不符合条件的记录过滤后才进行统计，它就可以减少中间运算要处理的数据，按理说应该速度是最快的，where也应该比having快点的，因为它过滤数据后才进行sum，在两个表联接时才用on的，所以在一个表的时候，就剩下where跟having比较了。在这单表查询统计的情况下，如果要过滤的条件没有涉及到要计算字段，那它们的结果是一样的，只是where可以使用rushmore技术，而having就不能，在速度上后者要慢如果要涉及到计算的字段，就表示在没计算之前，这个字段的值是不确定的，根据上篇写的工作流程，where的作用时间是在计算之前就完成的，而having就是在计算后才起作用的，所以在这种情况下，两者的结果会不同。在多表联接查询时，on比where更早起作用。系统首先根据各个表之间的联接条件，把多个表合成一个临时表后，再由where进行过滤，然后再计算，计算完后再由having进行过滤。由此可见，要想过滤条件起到正确的作用，首先要明白这个条件应该在什么时候起作用，然后再决定放在那里。 （12）减少对表的查询：在含有子查询的SQL语句中,要特别注意减少对表的查询。例子： 12SELECT TAB_NAME FROM TABLES WHERE (TAB_NAME,DB_VER) = ( SELECT TAB_NAME,DB_VER FROM TAB_COLUMNS WHERE VERSION = 604) （13）通过内部函数提高SQL效率：复杂的SQL往往牺牲了执行效率。能够掌握上面的运用函数解决问题的方法在实际工作中是非常有意义的。 （14）使用表的别名(Alias)：当在SQL语句中连接多个表时, 请使用表的别名并把别名前缀于每个Column上。这样一来,就可以减少解析的时间并减少那些由Column歧义引起的语法错误。 （15）用EXISTS替代IN、用NOT EXISTS替代NOT IN：在许多基于基础表的查询中,为了满足一个条件,往往需要对另一个表进行联接。在这种情况下, 使用EXISTS(或NOT EXISTS)通常将提高查询的效率。在子查询中,NOT IN子句将执行一个内部的排序和合并。无论在哪种情况下,NOT IN都是最低效的 (因为它对子查询中的表执行了一个全表遍历)。为了避免使用NOT IN ,我们可以把它改写成外连接(Outer Joins)或NOT EXISTS。 例子： 12345（高效）SELECT * FROM EMP (基础表) WHERE EMPNO &gt; 0 AND EXISTS (SELECT ‘X' FROM DEPT WHERE DEPT.DEPTNO = EMP.DEPTNO AND LOC = ‘MELB') (低效)SELECT * FROM EMP (基础表) WHERE EMPNO &gt; 0 AND DEPTNO IN(SELECT DEPTNO FROM DEPT WHERE LOC = ‘MELB') （16）识别‘低效执行’的SQL语句：虽然目前各种关于SQL优化的图形化工具层出不穷,但是写出自己的SQL工具来解决问题始终是一个最好的方法： 123456789SELECT EXECUTIONS , DISK_READS, BUFFER_GETS, ROUND((BUFFER_GETS-DISK_READS)/BUFFER_GETS,2) Hit_radio, ROUND(DISK_READS/EXECUTIONS,2) Reads_per_run, SQL_TEXT FROM V$SQLAREA WHERE EXECUTIONS&gt;0 AND BUFFER_GETS &gt; 0 AND (BUFFER_GETS-DISK_READS)/BUFFER_GETS &lt; 0.8 ORDER BY 4 DESC; （17）用索引提高效率：索引是表的一个概念部分，用来提高检索数据的效率，Oracle使用了一个复杂的自平衡B-tree结构。通常,通过索引查询数据比全表扫描要快。当Oracle找出执行查询和Update语句的最佳路径时, Oracle优化器将使用索引。同样在联结多个表时使用索引也可以提高效率。另一个使用索引的好处是,它提供了主键(primary key)的唯一性验证。那些LONG或LONG RAW数据类型, 你可以索引几乎所有的列。通常, 在大型表中使用索引特别有效. 当然,你也会发现, 在扫描小表时，使用索引同样能提高效率。虽然使用索引能得到查询效率的提高,但是我们也必须注意到它的代价。索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时, 索引本身也会被修改。这意味着每条记录的INSERT, DELETE , UPDATE将为此多付出4, 5次的磁盘I/O 。因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢。定期的重构索引是有必要的： ALTER INDEX &lt;INDEXNAME&gt; REBUILD &lt;TABLESPACENAME&gt; （18）用EXISTS替换DISTINCT：当提交一个包含一对多表信息(比如部门表和雇员表)的查询时,避免在SELECT子句中使用DISTINCT。一般可以考虑用EXIST替换, EXISTS 使查询更为迅速,因为RDBMS核心模块将在子查询的条件一旦满足后,立刻返回结果。例子： 123456(低效): SELECT DISTINCT DEPT_NO,DEPT_NAME FROM DEPT D , EMP E WHERE D.DEPT_NO = E.DEPT_NO (高效): SELECT DEPT_NO,DEPT_NAME FROM DEPT D WHERE EXISTS ( SELECT ‘X' FROM EMP E WHERE E.DEPT_NO = D.DEPT_NO); （19）SQL语句用大写的；因为Oracle总是先解析SQL语句，把小写的字母转换成大写的再执行。 （20）在Java代码中尽量少用连接符“＋”连接字符串。 （21）避免在索引列上使用NOT通常，我们要避免在索引列上使用NOT, NOT会产生在和在索引列上使用函数相同的影响。当Oracle“遇到”NOT,他就会停止使用索引转而执行全表扫描。 （22）避免在索引列上使用计算。WHERE子句中，如果索引列是函数的一部分。优化器将不使用索引而使用全表扫描。 举例: 低效：SELECT … FROM DEPT WHERE SAL * 12 &gt; 25000;高效:SELECT … FROM DEPT WHERE SAL &gt; 25000/12; （23）用&gt;=替代&gt;： 高效:SELECT FROM EMP WHERE DEPTNO &gt;=4低效:SELECT FROM EMP WHERE DEPTNO &gt;3 两者的区别在于, 前者DBMS将直接跳到第一个DEPT等于4的记录而后者将首先定位到DEPTNO=3的记录并且向前扫描到第一个DEPT大于3的记录。 （24）用UNION替换OR (适用于索引列)： 通常情况下, 用UNION替换WHERE子句中的OR将会起到较好的效果。对索引列使用OR将造成全表扫描。注意, 以上规则只针对多个索引列有效. 如果有column没有被索引, 查询效率可能会因为你没有选择OR而降低。在下面的例子中, LOC_ID 和REGION上都建有索引。 高效:SELECT LOC_ID , LOC_DESC , REGIONFROM LOCATIONWHERE LOC_ID = 10UNIONSELECT LOC_ID , LOC_DESC , REGIONFROM LOCATIONWHERE REGION = “MELBOURNE”低效:SELECT LOC_ID , LOC_DESC , REGIONFROM LOCATIONWHERE LOC_ID = 10 OR REGION = “MELBOURNE” （25）用IN来替换OR： 这是一条简单易记的规则，但是实际的执行效果还须检验，在Oracle8i下，两者的执行路径似乎是相同的: 低效: SELECT…. FROM LOCATION WHERE LOC_ID = 10 OR LOC_ID = 20 OR LOC_ID = 30 高效： SELECT… FROM LOCATION WHERE LOC_IN IN (10,20,30); （26）避免在索引列上使用IS NULL和IS NOT NULL： 避免在索引中使用任何可以为空的列，Oracle将无法使用该索引。对于单列索引，如果列包含空值，索引中将不存在此记录。对于复合索引，如果每个列都为空，索引中同样不存在此记录. 如果至少有一个列不为空，则记录存在于索引中。举例: 如果唯一性索引建立在表的A列和B列上, 并且表中存在一条记录的A，B值为(123，null) , Oracle将不接受下一条具有相同A，B值（123,null）的记录(插入)。 然而如果所有的索引列都为空，Oracle将认为整个键值为空而空不等于空。因此你可以插入1000 条具有相同键值的记录,当然它们都是空! 因为空值不存在于索引列中,所以WHERE子句中对索引列进行空值比较将使ORACLE停用该索引。 低效: (索引失效) SELECT … FROM DEPARTMENT WHERE DEPT_CODE IS NOT NULL; 高效: (索引有效) SELECT … FROM DEPARTMENT WHERE DEPT_CODE &gt;=0; （27）总是使用索引的第一个列： 如果索引是建立在多个列上, 只有在它的第一个列(leading column)被where子句引用时,优化器才会选择使用该索引。这也是一条简单而重要的规则，当仅引用索引的第二个列时,优化器使用了全表扫描而忽略了索引。 （28）用UNION-ALL 替换UNION ( 如果有可能的话)： 当SQL语句需要UNION两个查询结果集合时,这两个结果集合会以UNION-ALL的方式被合并, 然后在输出最终结果前进行排序。如果用UNION ALL替代UNION, 这样排序就不是必要了。效率就会因此得到提高。需要注意的是，UNION ALL 将重复输出两个结果集合中相同记录。因此各位还是要从业务需求分析使用UNION ALL的可行性. UNION 将对结果集合排序,这个操作会使用到SORT_AREA_SIZE这块内存。对于这块内存的优化也是相当重要的。下面的SQL可以用来查询排序的消耗量： 低效：SELECT ACCT_NUM, BALANCE_AMTFROM DEBIT_TRANSACTIONSWHERE TRAN_DATE = ‘31-DEC-95’UNIONSELECT ACCT_NUM, BALANCE_AMTFROM DEBIT_TRANSACTIONSWHERE TRAN_DATE = ‘31-DEC-95’高效:SELECT ACCT_NUM, BALANCE_AMTFROM DEBIT_TRANSACTIONSWHERE TRAN_DATE = ‘31-DEC-95’UNION ALLSELECT ACCT_NUM, BALANCE_AMTFROM DEBIT_TRANSACTIONSWHERE TRAN_DATE = ‘31-DEC-95’ （29）用WHERE替代ORDER BY： ORDER BY 子句只在两种严格的条件下使用索引。 ORDER BY中所有的列必须包含在相同的索引中并保持在索引中的排列顺序。 ORDER BY中所有的列必须定义为非空。 WHERE子句使用的索引和ORDER BY子句中所使用的索引不能并列。 例如: 表DEPT包含以下列: DEPT_CODE PK NOT NULL DEPT_DESC NOT NULL DEPT_TYPE NULL 低效: (索引不被使用) SELECT DEPT_CODE FROM DEPT ORDER BY DEPT_TYPE 高效: (使用索引) SELECT DEPT_CODE FROM DEPT WHERE DEPT_TYPE &gt; 0 （30）避免改变索引列的类型: 当比较不同数据类型的数据时, ORACLE自动对列进行简单的类型转换。 假设 EMPNO是一个数值类型的索引列：SELECT … FROM EMP WHERE EMPNO = ‘123’。 实际上,经过Oracle类型转换, 语句转化为: SELECT … FROM EMP WHERE EMPNO = TO_NUMBER(‘123’) 。 幸运的是,类型转换没有发生在索引列上,索引的用途没有被改变。现在,假设EMP_TYPE是一个字符类型的索引列：SELECT … FROM EMP WHERE EMP_TYPE = 123 。 这个语句被Oracle转换为: SELECT … FROM EMP WHERETO_NUMBER(EMP_TYPE)=123。因为内部发生的类型转换, 这个索引将不会被用到! 为了避免Oracle对你的SQL进行隐式的类型转换, 最好把类型转换用显式表现出来。注意当字符和数值比较时, Oracle会优先转换数值类型到字符类型。 （31）需要当心的WHERE子句: 某些SELECT 语句中的WHERE子句不使用索引。这里有一些例子： (1)‘!=’ 将不使用索引。记住, 索引只能告诉你什么存在于表中, 而不能告诉你什么不存在于表中。 (2)‘||’是字符连接函数。就象其他函数那样, 停用了索引。 (3)‘+’是数学函数。就象其他数学函数那样, 停用了索引。 (4)相同的索引列不能互相比较,这将会启用全表扫描。 （32）a. 如果检索数据量超过30%的表中记录数.使用索引将没有显著的效率提高。b. 在特定情况下, 使用索引也许会比全表扫描慢, 但这是同一个数量级上的区别。而通常情况下,使用索引比全表扫描要块几倍乃至几千倍! （33）避免使用耗费资源的操作: 带有DISTINCT,UNION,MINUS,INTERSECT,ORDER BY的SQL语句会启动SQL引擎执行耗费资源的排序(SORT)功能。DISTINCT需要一次排序操作, 而其他的至少需要执行两次排序. 通常, 带有UNION, MINUS , INTERSECT的SQL语句都可以用其他方式重写. 如果你的数据库的SORT_AREA_SIZE调配得好, 使用UNION , MINUS, INTERSECT也是可以考虑的, 毕竟它们的可读性很强。 （34）优化GROUP BY: 提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉。下面两个查询返回相同结果但第二个明显就快了许多。 低效:SELECT JOB , AVG(SAL)FROM EMPGROUP JOBHAVING JOB = ‘PRESIDENT’OR JOB = ‘MANAGER’高效:SELECT JOB , AVG(SAL)FROM EMPWHERE JOB = ‘PRESIDENT’OR JOB = ‘MANAGER’GROUP JOB 选用适合的ORACLE优化器ORACLE的优化器共有3种:a. RULE (基于规则) b. COST (基于成本) c. CHOOSE (选择性)设置缺省的优化器,可以通过对init.ora文件中OPTIMIZER_MODE参数的各种声明,如RULE,COST,CHOOSE,ALL_ROWS,FIRST_ROWS . 你当然也在SQL句级或是会话(session)级对其进行覆盖.为了使用基于成本的优化器(CBO, Cost-Based Optimizer) , 你必须经常运行analyze 命令,以增加数据库中的对象统计信息(object statistics)的准确性.如果数据库的优化器模式设置为选择性(CHOOSE),那么实际的优化器模式将和是否运行过analyze命令有关. 如果table已经被analyze过, 优化器模式将自动成为CBO , 反之,数据库将采用RULE形式的优化器.在缺省情况下,ORACLE采用CHOOSE优化器, 为了避免那些不必要的全表扫描(full table scan) , 你必须尽量避免使用CHOOSE优化器,而直接采用基于规则或者基于成本的优化器.2.访问Table的方式ORACLE 采用两种访问表中记录的方式:a.全表扫描 全表扫描就是顺序地访问表中每条记录. ORACLE采用一次读入多个数据块(database block)的方式优化全表扫描.b.通过ROWID访问表你可以采用基于ROWID的访问方式情况,提高访问表的效率, , ROWID包含了表中记录的物理位置信息..ORACLE采用索引(INDEX)实现了数据和存放数据的物理位置(ROWID)之间的联系. 通常索引提供了快速访问ROWID的方法,因此那些基于索引列的查询就可以得到性能上的提高.3.共享SQL语句为了不重复解析相同的SQL语句,在第一次解析之后, ORACLE将SQL语句存放在内存中.这块位于系统全局区域SGA(system global area)的共享池(shared buffer pool)中的内存可以被所有的数据库用户共享. 因此,当你执行一个SQL语句(有时被称为一个游标)时,如果它和之前的执行过的语句完全相同, ORACLE就能很快获得已经被解析的语句以及最好的执行路径. ORACLE的这个功能大大地提高了SQL的执行性能并节省了内存的使用. 可惜的是ORACLE只对简单的表提供高速缓冲(cache buffering) ,这个功能并不适用于多表连接查询.数据库管理员必须在init.ora中为这个区域设置合适的参数,当这个内存区域越大,就可以保留更多的语句,当然被共享的可能性也就越大了.当你向ORACLE 提交一个SQL语句,ORACLE会首先在这块内存中查找相同的语句.这里需要注明的是,ORACLE对两者采取的是一种严格匹配,要达成共享,SQL语句必须完全相同(包括空格,换行等). 共享的语句必须满足三个条件:A.字符级的比较:当前被执行的语句和共享池中的语句必须完全相同. 例如:SELECT * FROM EMP; 和下列每一个都不同SELECT * from EMP; Select * From Emp; SELECT * FROM EMP; B. 两个语句所指的对象必须完全相同:例如:用户 对象名 如何访问Jack sal_limit private synonymWork_city public synonym Plant_detail public synonym Jill sal_limit private synonym Work_city public synonym Plant_detail table owner 考虑一下下列SQL语句能否在这两个用户之间共享. SQL 能否共享 原因select max(sal_cap) from sal_limit; 不能 每个用户都有一个private synonym - sal_limit , 它们是不同的对象select count(*0 from work_city where sdesc like ‘NEW%’; 能 两个用户访问相同的对象public synonym - work_cityselect a.sdesc,b.location from work_city a , plant_detail b where a.city_id = b.city_id 不能 用户jack 通过private synonym访问plant_detail 而jill 是表的所有者,对象不同.C. 两个SQL语句中必须使用相同的名字的绑定变量(bind variables)例如：第一组的两个SQL语句是相同的(可以共享),而第二组中的两个语句是不同的(即使在运行时,赋于不同的绑定变量相同的值)a.select pin , name from people where pin = :blk1.pin;select pin , name from people where pin = :blk1.pin;b.select pin , name from people where pin = :blk1.ot_ind;select pin , name from people where pin = :blk1.ov_ind; 选择最有效率的表名顺序(只在基于规则的优化器中有效)ORACLE的解析器按照从右到左的顺序处理FROM子句中的表名,因此FROM子句中写在最后的表(基础表 driving table)将被最先处理. 在FROM子句中包含多个表的情况下,你必须选择记录条数最少的表作为基础表.当ORACLE处理多个表时, 会运用排序及合并的方式连接它们.首先,扫描第一个表(FROM子句中最后的那个表)并对记录进行派序,然后扫描第二个表(FROM子句中最后第二个表),最后将所有从第二个表中检索出的记录与第一个表中合适记录进行合并.例如: 表 TAB1 16,384 条记录 表 TAB2 1 条记录 选择TAB2作为基础表 (最好的方法) select count() from tab1,tab2 执行时间0.96秒 选择TAB2作为基础表 (不佳的方法) select count() from tab2,tab1 执行时间26.09秒如果有3个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表.例如:EMP表描述了LOCATION表和CATEGORY表的交集.SELECT FROM LOCATION L , CATEGORY C, EMP EWHERE E.EMP_NO BETWEEN 1000 AND 2000AND E.CAT_NO = C.CAT_NOAND E.LOCN = L.LOCN将比下列SQL更有效率SELECT FROM EMP E ,LOCATION L , CATEGORY CWHERE E.CAT_NO = C.CAT_NOAND E.LOCN = L.LOCNAND E.EMP_NO BETWEEN 1000 AND 20005.WHERE子句中的连接顺序．ORACLE采用自下而上的顺序解析WHERE子句,根据这个原理,表之间的连接必须写在其他WHERE条件之前, 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾.例如:(低效,执行时间156.3秒)SELECT …FROM EMP EWHERE SAL &gt; 50000AND JOB = ‘MANAGER’AND 25 &lt; (SELECT COUNT(*) FROM EMPWHERE MGR=E.EMPNO); (高效,执行时间10.6秒)SELECT …FROM EMP EWHERE 25 &lt; (SELECT COUNT() FROM EMP WHERE MGR=E.EMPNO)AND SAL &gt; 50000AND JOB = ‘MANAGER’;6.SELECT子句中避免使用 ‘ ‘当你想在SELECT子句中列出所有的COLUMN时,使用动态SQL列引用 ‘’ 是一个方便的方法.不幸的是,这是一个非常低效的方法. 实际上,ORACLE在解析的过程中, 会将’’ 依次转换成所有的列名, 这个工作是通过查询数据字典完成的, 这意味着将耗费更多的时间.7.减少访问数据库的次数当执行每条SQL语句时, ORACLE在内部执行了许多工作: 解析SQL语句, 估算索引的利用率, 绑定变量 , 读数据块等等. 由此可见, 减少访问数据库的次数 , 就能实际上减少ORACLE的工作量.例如,以下有三种方法可以检索出雇员号等于0342或0291的职员.方法1 (最低效) SELECT EMP_NAME , SALARY , GRADE FROM EMP WHERE EMP_NO = 342; SELECT EMP_NAME , SALARY , GRADE FROM EMP WHERE EMP_NO = 291; 方法2 (次低效) DECLARE CURSOR C1 (E_NO NUMBER) IS SELECT EMP_NAME,SALARY,GRADE FROM EMP WHERE EMP_NO = E_NO; BEGIN OPEN C1(342); FETCH C1 INTO …,..,.. ; ….. OPEN C1(291); FETCH C1 INTO …,..,.. ; CLOSE C1; END;方法3 (高效) SELECT A.EMP_NAME , A.SALARY , A.GRADE, B.EMP_NAME , B.SALARY , B.GRADE FROM EMP A,EMP B WHERE A.EMP_NO = 342 AND B.EMP_NO = 291;注意: 在SQLPlus , SQLForms和ProC中重新设置ARRAYSIZE参数, 可以增加每次数据库访问的检索数据量 ,建议值为2008.使用DECODE函数来减少处理时间使用DECODE函数可以避免重复扫描相同记录或重复连接相同的表.例如: SELECT COUNT()，SUM(SAL) FROM EMP WHERE DEPT_NO = 0020 AND ENAME LIKE ‘SMITH%’; SELECT COUNT(*)，SUM(SAL) FROM EMP WHERE DEPT_NO = 0030 AND ENAME LIKE ‘SMITH%’; 你可以用DECODE函数高效地得到相同结果 SELECT COUNT(DECODE(DEPT_NO,0020,’X’,NULL)) D0020_COUNT, COUNT(DECODE(DEPT_NO,0030,’X’,NULL)) D0030_COUNT, SUM(DECODE(DEPT_NO,0020,SAL,NULL)) D0020_SAL, SUM(DECODE(DEPT_NO,0030,SAL,NULL)) D0030_SALFROM EMP WHERE ENAME LIKE ‘SMITH%’; 类似的,DECODE函数也可以运用于GROUP BY 和ORDER BY子句中. 9.整合简单,无关联的数据库访问如果你有几个简单的数据库查询语句,你可以把它们整合到一个查询中(即使它们之间没有关系)例如: SELECT NAMEFROM EMPWHERE EMP_NO = 1234; SELECT NAMEFROM DPTWHERE DPT_NO = 10 ; SELECT NAMEFROM CATWHERE CAT_TYPE = ‘RD’; 上面的3个查询可以被合并成一个: SELECT E.NAME , D.NAME , C.NAMEFROM CAT C , DPT D , EMP E,DUAL XWHERE NVL(‘X’,X.DUMMY) = NVL(‘X’,E.ROWID(+))AND NVL(‘X’,X.DUMMY) = NVL(‘X’,D.ROWID(+))AND NVL(‘X’,X.DUMMY) = NVL(‘X’,C.ROWID(+))AND E.EMP_NO(+) = 1234AND D.DEPT_NO(+) = 10AND C.CAT_TYPE(+) = ‘RD’;(译者按: 虽然采取这种方法,效率得到提高,但是程序的可读性大大降低,所以读者 还是要权衡之间的利弊)10.删除重复记录最高效的删除重复记录方法 ( 因为使用了ROWID)DELETE FROM EMP EWHERE E.ROWID &gt; (SELECT MIN(X.ROWID) FROM EMP X WHERE X.EMP_NO = E.EMP_NO);11.用TRUNCATE替代DELETE当删除表中的记录时,在通常情况下, 回滚段(rollback segments ) 用来存放可以被恢复的信息. 如果你没有COMMIT事务,ORACLE会将数据恢复到删除之前的状态(准确地说是恢复到执行删除命令之前的状况) 而当运用TRUNCATE时, 回滚段不再存放任何可被恢复的信息.当命令运行后,数据不能被恢复.因此很少的资源被调用,执行时间也会很短.(译者按: TRUNCATE只在删除全表适用,TRUNCATE是DDL不是DML)12.尽量多使用COMMIT只要有可能,在程序中尽量多使用COMMIT, 这样程序的性能得到提高,需求也会因为COMMIT所释放的资源而减少: COMMIT所释放的资源:a. 回滚段上用于恢复数据的信息.b. 被程序语句获得的锁c. redo log buffer 中的空间d. ORACLE为管理上述3种资源中的内部花费(译者按: 在使用COMMIT时必须要注意到事务的完整性,现实中效率和事务完整性往往是鱼和熊掌不可得兼)13.计算记录条数 和一般的观点相反, count() 比count(1)稍快 , 当然如果可以通过索引检索,对索引列的计数仍旧是最快的. 例如 COUNT(EMPNO)(译者按: 在CSDN论坛中,曾经对此有过相当热烈的讨论, 作者的观点并不十分准确,通过实际的测试,上述三种方法并没有显著的性能差别)14.用Where子句替换HAVING子句 避免使用HAVING子句, HAVING 只会在检索出所有记录之后才对结果集进行过滤. 这个处理需要排序,总计等操作. 如果能通过WHERE子句限制记录的数目,那就能减少这方面的开销.例如: 低效: SELECT REGION，AVG(LOG_SIZE) FROM LOCATION GROUP BY REGION HAVING REGION REGION != ‘SYDNEY’ AND REGION != ‘PERTH’ 高效 SELECT REGION，AVG(LOG_SIZE) FROM LOCATION WHERE REGION REGION != ‘SYDNEY’ AND REGION != ‘PERTH’ GROUP BY REGION(译者按: HAVING 中的条件一般用于对一些集合函数的比较,如COUNT() 等等. 除此而外,一般的条件应该写在WHERE子句中)15.减少对表的查询在含有子查询的SQL语句中,要特别注意减少对表的查询.例如: 低效 SELECT TAB_NAME FROM TABLES WHERE TAB_NAME = ( SELECT TAB_NAME FROM TAB_COLUMNS WHERE VERSION = 604) AND DB_VER= ( SELECT DB_VER FROM TAB_COLUMNS WHERE VERSION = 604) 高效 SELECT TAB_NAME FROM TABLES WHERE (TAB_NAME,DB_VER) = ( SELECT TAB_NAME,DB_VER) FROM TAB_COLUMNS WHERE VERSION = 604) Update 多个Column 例子: 低效: UPDATE EMP SET EMP_CAT = (SELECT MAX(CATEGORY) FROM EMP_CATEGORIES), SAL_RANGE = (SELECT MAX(SAL_RANGE) FROM EMP_CATEGORIES) WHERE EMP_DEPT = 0020; 高效: UPDATE EMP SET (EMP_CAT, SAL_RANGE) = (SELECT MAX(CATEGORY) , MAX(SAL_RANGE)FROM EMP_CATEGORIES) WHERE EMP_DEPT = 0020;16.通过内部函数提高SQL效率. SELECT H.EMPNO,E.ENAME,H.HIST_TYPE,T.TYPE_DESC,COUNT() FROM HISTORY_TYPE T,EMP E,EMP_HISTORY H WHERE H.EMPNO = E.EMPNOAND H.HIST_TYPE = T.HIST_TYPEGROUP BY H.EMPNO,E.ENAME,H.HIST_TYPE,T.TYPE_DESC; 通过调用下面的函数可以提高效率.FUNCTION LOOKUP_HIST_TYPE(TYP IN NUMBER) RETURN VARCHAR2AS TDESC VARCHAR2(30); CURSOR C1 IS SELECT TYPE_DESC FROM HISTORY_TYPE WHERE HIST_TYPE = TYP;BEGIN OPEN C1; FETCH C1 INTO TDESC; CLOSE C1; RETURN (NVL(TDESC,’?’));END; FUNCTION LOOKUP_EMP(EMP IN NUMBER) RETURN VARCHAR2AS ENAME VARCHAR2(30); CURSOR C1 IS SELECT ENAME FROM EMP WHERE EMPNO=EMP;BEGIN OPEN C1; FETCH C1 INTO ENAME; CLOSE C1; RETURN (NVL(ENAME,’?’));END; SELECT H.EMPNO,LOOKUP_EMP(H.EMPNO),H.HIST_TYPE,LOOKUP_HIST_TYPE(H.HIST_TYPE),COUNT(*)FROM EMP_HISTORY HGROUP BY H.EMPNO , H.HIST_TYPE;(译者按: 经常在论坛中看到如 ’能不能用一个SQL写出….’ 的贴子, 殊不知复杂的SQL往往牺牲了执行效率. 能够掌握上面的运用函数解决问题的方法在实际工作中是非常有意义的)17.使用表的别名(Alias)当在SQL语句中连接多个表时, 请使用表的别名并把别名前缀于每个Column上.这样一来,就可以减少解析的时间并减少那些由Column歧义引起的语法错误.(译者注: Column歧义指的是由于SQL中不同的表具有相同的Column名,当SQL语句中出现这个Column时,SQL解析器无法判断这个Column的归属)18.用EXISTS替代IN在许多基于基础表的查询中,为了满足一个条件,往往需要对另一个表进行联接.在这种情况下, 使用EXISTS(或NOT EXISTS)通常将提高查询的效率. 低效:SELECT *FROM EMP (基础表)WHERE EMPNO &gt; 0AND DEPTNO IN (SELECT DEPTNOFROM DEPTWHERE LOC = ‘MELB’) 高效:SELECT *FROM EMP (基础表)WHERE EMPNO &gt; 0AND EXISTS (SELECT ‘X’FROM DEPTWHERE DEPT.DEPTNO = EMP.DEPTNOAND LOC = ‘MELB’) (译者按: 相对来说,用NOT EXISTS替换NOT IN 将更显著地提高效率,下一节中将指出)19.用NOT EXISTS替代NOT IN在子查询中,NOT IN子句将执行一个内部的排序和合并. 无论在哪种情况下,NOT IN都是最低效的 (因为它对子查询中的表执行了一个全表遍历). 为了避免使用NOT IN ,我们可以把它改写成外连接(Outer Joins)或NOT EXISTS. 例如:SELECT …FROM EMPWHERE DEPT_NO NOT IN (SELECT DEPT_NO FROM DEPT WHERE DEPT_CAT=’A’); 为了提高效率.改写为: (方法一: 高效)SELECT ….FROM EMP A,DEPT BWHERE A.DEPT_NO = B.DEPT(+)AND B.DEPT_NO IS NULLAND B.DEPT_CAT(+) = ‘A’ (方法二: 最高效)SELECT ….FROM EMP EWHERE NOT EXISTS (SELECT ‘X’ FROM DEPT D WHERE D.DEPT_NO = E.DEPT_NO AND DEPT_CAT = ‘A’); 20.用表连接替换EXISTS 通常来说 , 采用表连接的方式比EXISTS更有效率 SELECT ENAME FROM EMP E WHERE EXISTS (SELECT ‘X’ FROM DEPT WHERE DEPT_NO = E.DEPT_NO AND DEPT_CAT = ‘A’); (更高效) SELECT ENAME FROM DEPT D,EMP E WHERE E.DEPT_NO = D.DEPT_NO AND DEPT_CAT = ‘A’ ; (译者按: 在RBO的情况下,前者的执行路径包括FILTER,后者使用NESTED LOOP)21.用EXISTS替换DISTINCT当提交一个包含一对多表信息(比如部门表和雇员表)的查询时,避免在SELECT子句中使用DISTINCT. 一般可以考虑用EXIST替换例如:低效: SELECT DISTINCT DEPT_NO,DEPT_NAME FROM DEPT D,EMP E WHERE D.DEPT_NO = E.DEPT_NO高效: SELECT DEPT_NO,DEPT_NAME FROM DEPT D WHERE EXISTS ( SELECT ‘X’ FROM EMP E WHERE E.DEPT_NO = D.DEPT_NO); EXISTS 使查询更为迅速,因为RDBMS核心模块将在子查询的条件一旦满足后,立刻返回结果.22.识别’低效执行’的SQL语句用下列SQL工具找出低效SQL:SELECT EXECUTIONS , DISK_READS, BUFFER_GETS, ROUND((BUFFER_GETS-DISK_READS)/BUFFER_GETS,2) Hit_radio, ROUND(DISK_READS/EXECUTIONS,2) Reads_per_run, SQL_TEXTFROM V$SQLAREAWHERE EXECUTIONS&gt;0AND BUFFER_GETS &gt; 0AND (BUFFER_GETS-DISK_READS)/BUFFER_GETS &lt; 0.8ORDER BY 4 DESC; (译者按: 虽然目前各种关于SQL优化的图形化工具层出不穷,但是写出自己的SQL工具来解决问题始终是一个最好的方法) 23.使用TKPROF 工具来查询SQL性能状态SQL trace 工具收集正在执行的SQL的性能状态数据并记录到一个跟踪文件中. 这个跟踪文件提供了许多有用的信息,例如解析次数.执行次数,CPU使用时间等.这些数据将可以用来优化你的系统.设置SQL TRACE在会话级别: 有效 ALTER SESSION SET SQL_TRACE TRUE设置SQL TRACE 在整个数据库有效仿, 你必须将SQL_TRACE参数在init.ora中设为TRUE, USER_DUMP_DEST参数说明了生成跟踪文件的目录 (译者按: 这一节中,作者并没有提到TKPROF的用法, 对SQL TRACE的用法也不够准确, 设置SQL TRACE首先要在init.ora中设定TIMED_STATISTICS, 这样才能得到那些重要的时间状态. 生成的trace文件是不可读的,所以要用TKPROF工具对其进行转换,TKPROF有许多执行参数. 大家可以参考ORACLE手册来了解具体的配置. ) 24.用EXPLAIN PLAN 分析SQL语句EXPLAIN PLAN 是一个很好的分析SQL语句的工具,它甚至可以在不执行SQL的情况下分析语句. 通过分析,我们就可以知道ORACLE是怎么样连接表,使用什么方式扫描表(索引扫描或全表扫描)以及使用到的索引名称.你需要按照从里到外,从上到下的次序解读分析的结果. EXPLAIN PLAN分析的结果是用缩进的格式排列的, 最内部的操作将被最先解读, 如果两个操作处于同一层中,带有最小操作号的将被首先执行.NESTED LOOP是少数不按照上述规则处理的操作, 正确的执行路径是检查对NESTED LOOP提供数据的操作,其中操作号最小的将被最先处理. 译者按: 通过实践, 感到还是用SQLPLUS中的SET TRACE 功能比较方便.举例: SQL&gt; list 1 SELECT 2 FROM dept, emp 3 WHERE emp.deptno = dept.deptnoSQL&gt; set autotrace traceonly /traceonly 可以不显示执行结果/SQL&gt; /14 rows selected. Execution Plan 0 SELECT STATEMENT Optimizer=CHOOSE 1 0 NESTED LOOPS 2 1 TABLE ACCESS (FULL) OF ‘EMP’ 3 1 TABLE ACCESS (BY INDEX ROWID) OF ‘DEPT’ 4 3 INDEX (UNIQUE SCAN) OF ‘PK_DEPT’ (UNIQUE) Statistics 0 recursive calls 2 db block gets 30 consistent gets 0 physical reads 0 redo size 2598 bytes sent via SQL*Net to client 503 bytes received via SQL*Net from client 2 SQL*Net roundtrips to/from client 0 sorts (memory) 0 sorts (disk) 14 rows processed 通过以上分析,可以得出实际的执行步骤是: TABLE ACCESS (FULL) OF ‘EMP’ INDEX (UNIQUE SCAN) OF ‘PK_DEPT’ (UNIQUE) TABLE ACCESS (BY INDEX ROWID) OF ‘DEPT’ NESTED LOOPS (JOINING 1 AND 3) 注: 目前许多第三方的工具如TOAD和ORACLE本身提供的工具如OMS的SQL Analyze都提供了极其方便的EXPLAIN PLAN工具.也许喜欢图形化界面的朋友们可以选用它们. 25.用索引提高效率索引是表的一个概念部分,用来提高检索数据的效率. 实际上,ORACLE使用了一个复杂的自平衡B-tree结构. 通常,通过索引查询数据比全表扫描要快. 当ORACLE找出执行查询和Update语句的最佳路径时, ORACLE优化器将使用索引. 同样在联结多个表时使用索引也可以提高效率. 另一个使用索引的好处是,它提供了主键(primary key)的唯一性验证.除了那些LONG或LONG RAW数据类型, 你可以索引几乎所有的列. 通常, 在大型表中使用索引特别有效. 当然,你也会发现, 在扫描小表时,使用索引同样能提高效率.虽然使用索引能得到查询效率的提高,但是我们也必须注意到它的代价. 索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时, 索引本身也会被修改. 这意味着每条记录的INSERT , DELETE , UPDATE将为此多付出4 , 5 次的磁盘I/O . 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢. 译者按: 定期的重构索引是有必要的. ALTER INDEX REBUILD 26.索引的操作ORACLE对索引有两种访问模式.索引唯一扫描 ( INDEX UNIQUE SCAN)大多数情况下, 优化器通过WHERE子句访问INDEX.例如:表LODGING有两个索引 : 建立在LODGING列上的唯一性索引LODGING_PK和建立在MANAGER列上的非唯一性索引LODGING$MANAGER. SELECT *FROM LODGINGWHERE LODGING = ‘ROSE HILL’;在内部 , 上述SQL将被分成两步执行, 首先 , LODGING_PK 索引将通过索引唯一扫描的方式被访问 , 获得相对应的ROWID, 通过ROWID访问表的方式 执行下一步检索.如果被检索返回的列包括在INDEX列中,ORACLE将不执行第二步的处理(通过ROWID访问表). 因为检索数据保存在索引中, 单单访问索引就可以完全满足查询结果. 下面SQL只需要INDEX UNIQUE SCAN 操作. SELECT LODGING FROM LODGINGWHERE LODGING = ‘ROSE HILL’; 索引范围查询(INDEX RANGE SCAN) 适用于两种情况: 基于一个范围的检索 基于非唯一性索引的检索 例1: SELECT LODGINGFROM LODGINGWHERE LODGING LIKE ‘M%’; WHERE子句条件包括一系列值, ORACLE将通过索引范围查询的方式查询LODGING_PK . 由于索引范围查询将返回一组值, 它的效率就要比索引唯一扫描低一些. 例2: SELECT LODGING FROM LODGING WHERE MANAGER = ‘BILL GATES’; 这个SQL的执行分两步, LODGING$MANAGER的索引范围查询(得到所有符合条件记录的ROWID) 和下一步同过ROWID访问表得到LODGING列的值. 由于LODGING$MANAGER是一个非唯一性的索引,数据库不能对它执行索引唯一扫描. 由于SQL返回LODGING列,而它并不存在于LODGING$MANAGER索引中, 所以在索引范围查询后会执行一个通过ROWID访问表的操作. WHERE子句中, 如果索引列所对应的值的第一个字符由通配符(WILDCARD)开始, 索引将不被采用. SELECT LODGING FROM LODGINGWHERE MANAGER LIKE ‘％HANMAN’; 在这种情况下，ORACLE将使用全表扫描. 27.基础表的选择基础表(Driving Table)是指被最先访问的表(通常以全表扫描的方式被访问). 根据优化器的不同, SQL语句中基础表的选择是不一样的.如果你使用的是CBO (COST BASED OPTIMIZER),优化器会检查SQL语句中的每个表的物理大小,索引的状态,然后选用花费最低的执行路径.如果你用RBO (RULE BASED OPTIMIZER) , 并且所有的连接条件都有索引对应, 在这种情况下, 基础表就是FROM 子句中列在最后的那个表.举例: SELECT A.NAME , B.MANAGER FROM WORKER A, LODGING B WHERE A.LODGING = B.LODING;由于LODGING表的LODING列上有一个索引, 而且WORKER表中没有相比较的索引, WORKER表将被作为查询中的基础表.28.多个平等的索引当SQL语句的执行路径可以使用分布在多个表上的多个索引时, ORACLE会同时使用多个索引并在运行时对它们的记录进行合并, 检索出仅对全部索引有效的记录.在ORACLE选择执行路径时,唯一性索引的等级高于非唯一性索引. 然而这个规则只有当WHERE子句中索引列和常量比较才有效.如果索引列和其他表的索引类相比较. 这种子句在优化器中的等级是非常低的.如果不同表中两个想同等级的索引将被引用, FROM子句中表的顺序将决定哪个会被率先使用. FROM子句中最后的表的索引将有最高的优先级.如果相同表中两个想同等级的索引将被引用, WHERE子句中最先被引用的索引将有最高的优先级.举例: DEPTNO上有一个非唯一性索引,EMP_CAT也有一个非唯一性索引. SELECT ENAME, FROM EMP WHERE DEPT_NO = 20 AND EMP_CAT = ‘A’;这里,DEPTNO索引将被最先检索,然后同EMP_CAT索引检索出的记录进行合并. 执行路径如下: TABLE ACCESS BY ROWID ON EMP AND-EQUAL INDEX RANGE SCAN ON DEPT_IDX INDEX RANGE SCAN ON CAT_IDX 等式比较和范围比较 当WHERE子句中有索引列, ORACLE不能合并它们,ORACLE将用范围比较. 举例: DEPTNO上有一个非唯一性索引,EMP_CAT也有一个非唯一性索引. SELECT ENAME FROM EMP WHERE DEPTNO &gt; 20 AND EMP_CAT = ‘A’; 这里只有EMP_CAT索引被用到,然后所有的记录将逐条与DEPTNO条件进行比较. 执行路径如下: TABLE ACCESS BY ROWID ON EMP INDEX RANGE SCAN ON CAT_IDX 30.不明确的索引等级当ORACLE无法判断索引的等级高低差别,优化器将只使用一个索引,它就是在WHERE子句中被列在最前面的.举例: DEPTNO上有一个非唯一性索引,EMP_CAT也有一个非唯一性索引. SELECT ENAME FROM EMP WHERE DEPTNO &gt; 20 AND EMP_CAT &gt; ‘A’; 这里, ORACLE只用到了DEPT_NO索引. 执行路径如下: TABLE ACCESS BY ROWID ON EMP INDEX RANGE SCAN ON DEPT_IDX 译者按:我们来试一下以下这种情况:SQL&gt; select index_name, uniqueness from user_indexes where table_name = ‘EMP’; INDEX_NAME UNIQUENES EMPNO UNIQUEEMPTYPE NONUNIQUE SQL&gt; select * from emp where empno &gt;= 2 and emp_type = ‘A’ ; no rows selected Execution Plan 0 SELECT STATEMENT Optimizer=CHOOSE 1 0 TABLE ACCESS (BY INDEX ROWID) OF ‘EMP’ 2 1 INDEX (RANGE SCAN) OF ‘EMPTYPE’ (NON-UNIQUE)虽然EMPNO是唯一性索引,但是由于它所做的是范围比较, 等级要比非唯一性索引的等式比较低!31.强制索引失效如果两个或以上索引具有相同的等级,你可以强制命令ORACLE优化器使用其中的一个(通过它,检索出的记录数量少) . 举例: SELECT ENAMEFROM EMPWHERE EMPNO = 7935AND DEPTNO + 0 = 10 /DEPTNO上的索引将失效/AND EMP_TYPE || ‘’ = ‘A’ /EMP_TYPE上的索引将失效/ 这是一种相当直接的提高查询效率的办法. 但是你必须谨慎考虑这种策略,一般来说,只有在你希望单独优化几个SQL时才能采用它. 这里有一个例子关于何时采用这种策略, 假设在EMP表的EMP_TYPE列上有一个非唯一性的索引而EMP_CLASS上没有索引. SELECT ENAMEFROM EMPWHERE EMP_TYPE = ‘A’AND EMP_CLASS = ‘X’; 优化器会注意到EMP_TYPE上的索引并使用它. 这是目前唯一的选择. 如果,一段时间以后, 另一个非唯一性建立在EMP_CLASS上,优化器必须对两个索引进行选择,在通常情况下,优化器将使用两个索引并在他们的结果集合上执行排序及合并. 然而,如果其中一个索引（EMP_TYPE）接近于唯一性而另一个索引（EMP_CLASS）上有几千个重复的值. 排序及合并就会成为一种不必要的负担. 在这种情况下,你希望使优化器屏蔽掉EMP_CLASS索引.用下面的方案就可以解决问题.SELECT ENAMEFROM EMPWHERE EMP_TYPE = ‘A’AND EMP_CLASS||’’ = ‘X’;32.避免在索引列上使用计算．WHERE子句中，如果索引列是函数的一部分．优化器将不使用索引而使用全表扫描． 举例: 低效：SELECT …FROM DEPTWHERE SAL * 12 &gt; 25000; 高效:SELECT …FROM DEPTWHERE SAL &gt; 25000/12;译者按:这是一个非常实用的规则，请务必牢记33.自动选择索引如果表中有两个以上（包括两个）索引，其中有一个唯一性索引，而其他是非唯一性．在这种情况下，ORACLE将使用唯一性索引而完全忽略非唯一性索引． 举例:SELECT ENAMEFROM EMPWHERE EMPNO = 2326AND DEPTNO = 20 ; 这里，只有EMPNO上的索引是唯一性的，所以EMPNO索引将用来检索记录．TABLE ACCESS BY ROWID ON EMP INDEX UNIQUE SCAN ON EMP_NO_IDX 避免在索引列上使用NOT通常， 我们要避免在索引列上使用NOT, NOT会产生在和在索引列上使用函数相同的影响. 当ORACLE”遇到”NOT,他就会停止使用索引转而执行全表扫描.举例: 低效: (这里,不使用索引) SELECT …FROM DEPTWHERE DEPT_CODE NOT = 0; 高效: (这里,使用了索引) SELECT …FROM DEPTWHERE DEPT_CODE &gt; 0; 需要注意的是,在某些时候, ORACLE优化器会自动将NOT转化成相对应的关系操作符.NOT &gt; to &lt;=NOT &gt;= to &lt;NOT &lt; to &gt;=NOT &lt;= to &gt; 译者按: 在这个例子中,作者犯了一些错误. 例子中的低效率SQL是不能被执行的.我做了一些测试: SQL&gt; select * from emp where NOT empno &gt; 1;no rows selected Execution Plan 0 SELECT STATEMENT Optimizer=CHOOSE 1 0 TABLE ACCESS (BY INDEX ROWID) OF ‘EMP’ 2 1 INDEX (RANGE SCAN) OF ‘EMPNO’ (UNIQUE) SQL&gt; select * from emp where empno &lt;= 1;no rows selected Execution Plan 0 SELECT STATEMENT Optimizer=CHOOSE 1 0 TABLE ACCESS (BY INDEX ROWID) OF ‘EMP’ 2 1 INDEX (RANGE SCAN) OF ‘EMPNO’ (UNIQUE) 两者的效率完全一样，也许这符合作者关于” 在某些时候, ORACLE优化器会自动将NOT转化成相对应的关系操作符” 的观点． 用&gt;=替代&gt; 如果DEPTNO上有一个索引, 高效: SELECT * FROM EMP WHERE DEPTNO &gt;=4 低效: SELECT * FROM EMP WHERE DEPTNO &gt;3 两者的区别在于, 前者DBMS将直接跳到第一个DEPT等于4的记录而后者将首先定位到DEPTNO=3的记录并且向前扫描到第一个DEPT大于3的记录. 用UNION替换OR (适用于索引列)通常情况下, 用UNION替换WHERE子句中的OR将会起到较好的效果. 对索引列使用OR将造成全表扫描. 注意, 以上规则只针对多个索引列有效. 如果有column没有被索引, 查询效率可能会因为你没有选择OR而降低.在下面的例子中, LOC_ID 和REGION上都建有索引.高效:SELECT LOC_ID , LOC_DESC , REGIONFROM LOCATIONWHERE LOC_ID = 10UNIONSELECT LOC_ID , LOC_DESC , REGIONFROM LOCATIONWHERE REGION = “MELBOURNE” 低效: SELECT LOC_ID , LOC_DESC , REGION FROM LOCATION WHERE LOC_ID = 10 OR REGION = “MELBOURNE” 如果你坚持要用OR, 那就需要返回记录最少的索引列写在最前面. 注意: WHERE KEY1 = 10 (返回最少记录)OR KEY2 = 20 (返回最多记录) ORACLE 内部将以上转换为WHERE KEY1 = 10 AND((NOT KEY1 = 10) AND KEY2 = 20) 译者按: 下面的测试数据仅供参考: (a = 1003 返回一条记录 , b = 1 返回1003条记录)SQL&gt; select from unionvsor /1st test*/ 2 where a = 1003 or b = 1;1003 rows selected. Execution Plan 0 SELECT STATEMENT Optimizer=CHOOSE 1 0 CONCATENATION 2 1 TABLE ACCESS (BY INDEX ROWID) OF ‘UNIONVSOR’ 3 2 INDEX (RANGE SCAN) OF ‘UB’ (NON-UNIQUE) 4 1 TABLE ACCESS (BY INDEX ROWID) OF ‘UNIONVSOR’ 5 4 INDEX (RANGE SCAN) OF ‘UA’ (NON-UNIQUE) Statistics 0 recursive calls 0 db block gets 144 consistent gets 0 physical reads 0 redo size 63749 bytes sent via SQL*Net to client 7751 bytes received via SQL*Net from client 68 SQL*Net roundtrips to/from client 0 sorts (memory) 0 sorts (disk) 1003 rows processed SQL&gt; select from unionvsor /2nd test*/ 2 where b = 1 or a = 1003 ;1003 rows selected. Execution Plan 0 SELECT STATEMENT Optimizer=CHOOSE 1 0 CONCATENATION 2 1 TABLE ACCESS (BY INDEX ROWID) OF ‘UNIONVSOR’ 3 2 INDEX (RANGE SCAN) OF ‘UA’ (NON-UNIQUE) 4 1 TABLE ACCESS (BY INDEX ROWID) OF ‘UNIONVSOR’ 5 4 INDEX (RANGE SCAN) OF ‘UB’ (NON-UNIQUE) Statistics 0 recursive calls 0 db block gets 143 consistent gets 0 physical reads 0 redo size 63749 bytes sent via SQL*Net to client 7751 bytes received via SQL*Net from client 68 SQL*Net roundtrips to/from client 0 sorts (memory) 0 sorts (disk) 1003 rows processed SQL&gt; select from unionvsor /3rd test/ 2 where a = 1003 3 union 4 select from unionvsor 5 where b = 1;1003 rows selected. Execution Plan 0 SELECT STATEMENT Optimizer=CHOOSE 1 0 SORT (UNIQUE) 2 1 UNION-ALL 3 2 TABLE ACCESS (BY INDEX ROWID) OF ‘UNIONVSOR’ 4 3 INDEX (RANGE SCAN) OF ‘UA’ (NON-UNIQUE) 5 2 TABLE ACCESS (BY INDEX ROWID) OF ‘UNIONVSOR’ 6 5 INDEX (RANGE SCAN) OF ‘UB’ (NON-UNIQUE) Statistics 0 recursive calls 0 db block gets 10 consistent gets 0 physical reads 0 redo size 63735 bytes sent via SQL*Net to client 7751 bytes received via SQL*Net from client 68 SQL*Net roundtrips to/from client 1 sorts (memory) 0 sorts (disk) 1003 rows processed 用UNION的效果可以从consistent gets和 SQL*NET的数据交换量的减少看出 用IN来替换OR 下面的查询可以被更有效率的语句替换: 低效: SELECT….FROM LOCATIONWHERE LOC_ID = 10OR LOC_ID = 20OR LOC_ID = 30 高效SELECT…FROM LOCATIONWHERE LOC_IN IN (10,20,30); 译者按:这是一条简单易记的规则，但是实际的执行效果还须检验，在ORACLE8i下，两者的执行路径似乎是相同的． 避免在索引列上使用IS NULL和IS NOT NULL避免在索引中使用任何可以为空的列，ORACLE将无法使用该索引 ．对于单列索引，如果列包含空值，索引中将不存在此记录. 对于复合索引，如果每个列都为空，索引中同样不存在此记录. 如果至少有一个列不为空，则记录存在于索引中．举例:如果唯一性索引建立在表的A列和B列上, 并且表中存在一条记录的A,B值为(123,null) , ORACLE将不接受下一条具有相同A,B值（123,null）的记录(插入). 然而如果所有的索引列都为空，ORACLE将认为整个键值为空而空不等于空. 因此你可以插入1000条具有相同键值的记录,当然它们都是空! 因为空值不存在于索引列中,所以WHERE子句中对索引列进行空值比较将使ORACLE停用该索引.举例: 低效: (索引失效)SELECT …FROM DEPARTMENTWHERE DEPT_CODE IS NOT NULL; 高效: (索引有效)SELECT …FROM DEPARTMENTWHERE DEPT_CODE &gt;=0; 总是使用索引的第一个列如果索引是建立在多个列上, 只有在它的第一个列(leading column)被where子句引用时,优化器才会选择使用该索引. 译者按:这也是一条简单而重要的规则. 见以下实例. SQL&gt; create table multiindexusage ( inda number , indb number , descr varchar2(10));Table created.SQL&gt; create index multindex on multiindexusage(inda,indb);Index created.SQL&gt; set autotrace traceonly SQL&gt; select * from multiindexusage where inda = 1; Execution Plan 0 SELECT STATEMENT Optimizer=CHOOSE 1 0 TABLE ACCESS (BY INDEX ROWID) OF ‘MULTIINDEXUSAGE’ 2 1 INDEX (RANGE SCAN) OF ‘MULTINDEX’ (NON-UNIQUE) SQL&gt; select * from multiindexusage where indb = 1; Execution Plan 0 SELECT STATEMENT Optimizer=CHOOSE 1 0 TABLE ACCESS (FULL) OF ‘MULTIINDEXUSAGE’ 很明显, 当仅引用索引的第二个列时,优化器使用了全表扫描而忽略了索引 ORACLE内部操作当执行查询时,ORACLE采用了内部的操作. 下表显示了几种重要的内部操作.ORACLE Clause 内部操作ORDER BY SORT ORDER BYUNION UNION-ALLMINUS MINUSINTERSECT INTERSECTDISTINCT,MINUS,INTERSECT,UNION SORT UNIQUEMIN,MAX,COUNT SORT AGGREGATEGROUP BY SORT GROUP BYROWNUM COUNT or COUNT STOPKEYQueries involving Joins SORT JOIN,MERGE JOIN,NESTED LOOPSCONNECT BY CONNECT BY 用UNION-ALL 替换UNION ( 如果有可能的话) 当SQL语句需要UNION两个查询结果集合时,这两个结果集合会以UNION-ALL的方式被合并, 然后在输出最终结果前进行排序.如果用UNION ALL替代UNION, 这样排序就不是必要了. 效率就会因此得到提高. 举例: 低效： SELECT ACCT_NUM, BALANCE_AMT FROM DEBIT_TRANSACTIONS WHERE TRAN_DATE = ’31-DEC-95’ UNION SELECT ACCT_NUM, BALANCE_AMT FROM DEBIT_TRANSACTIONS WHERE TRAN_DATE = ’31-DEC-95’高效: SELECT ACCT_NUM, BALANCE_AMT FROM DEBIT_TRANSACTIONS WHERE TRAN_DATE = ’31-DEC-95’ UNION ALL SELECT ACCT_NUM, BALANCE_AMT FROM DEBIT_TRANSACTIONS WHERE TRAN_DATE = ’31-DEC-95’ 译者按:需要注意的是，UNION ALL 将重复输出两个结果集合中相同记录. 因此各位还是要从业务需求分析使用UNION ALL的可行性.UNION 将对结果集合排序,这个操作会使用到SORT_AREA_SIZE这块内存. 对于这块内存的优化也是相当重要的. 下面的SQL可以用来查询排序的消耗量 Select substr(name,1,25) “Sort Area Name”, substr(value,1,15) “Value”from v$sysstatwhere name like ‘sort%’ 使用提示(Hints)对于表的访问,可以使用两种Hints.FULL 和 ROWID FULL hint 告诉ORACLE使用全表扫描的方式访问指定表.例如: SELECT /+ FULL(EMP) / * FROM EMP WHERE EMPNO = 7893; ROWID hint 告诉ORACLE使用TABLE ACCESS BY ROWID的操作访问表. 通常, 你需要采用TABLE ACCESS BY ROWID的方式特别是当访问大表的时候, 使用这种方式, 你需要知道ROIWD的值或者使用索引. 如果一个大表没有被设定为缓存(CACHED)表而你希望它的数据在查询结束是仍然停留在SGA中,你就可以使用CACHE hint 来告诉优化器把数据保留在SGA中. 通常CACHE hint 和 FULL hint 一起使用.例如:SELECT /+ FULL(WORKER) CACHE(WORKER)/ *FROM WORK; 索引hint 告诉ORACLE使用基于索引的扫描方式. 你不必说明具体的索引名称例如: SELECT /+ INDEX(LODGING) / LODGING FROM LODGING WHERE MANAGER = ‘BILL GATES’; 在不使用hint的情况下, 以上的查询应该也会使用索引,然而,如果该索引的重复值过多而你的优化器是CBO, 优化器就可能忽略索引. 在这种情况下, 你可以用INDEX hint强制ORACLE使用该索引. ORACLE hints 还包括ALL_ROWS, FIRST_ROWS, RULE,USE_NL, USE_MERGE, USE_HASH 等等. 译者按: 使用hint , 表示我们对ORACLE优化器缺省的执行路径不满意,需要手工修改.这是一个很有技巧性的工作. 我建议只针对特定的,少数的SQL进行hint的优化.对ORACLE的优化器还是要有信心(特别是CBO) 用WHERE替代ORDER BYORDER BY 子句只在两种严格的条件下使用索引. ORDER BY中所有的列必须包含在相同的索引中并保持在索引中的排列顺序.ORDER BY中所有的列必须定义为非空. WHERE子句使用的索引和ORDER BY子句中所使用的索引不能并列. 例如: 表DEPT包含以下列: DEPT_CODE PK NOT NULL DEPT_DESC NOT NULL DEPT_TYPE NULL 非唯一性的索引(DEPT_TYPE) 低效: (索引不被使用) SELECT DEPT_CODE FROM DEPT ORDER BY DEPT_TYPE EXPLAIN PLAN: SORT ORDER BY TABLE ACCESS FULL 高效: (使用索引) SELECT DEPT_CODE FROM DEPT WHERE DEPT_TYPE &gt; 0 EXPLAIN PLAN: TABLE ACCESS BY ROWID ON EMP INDEX RANGE SCAN ON DEPT_IDX译者按: ORDER BY 也能使用索引! 这的确是个容易被忽视的知识点. 我们来验证一下:SQL&gt; select * from emp order by empno; Execution Plan 0 SELECT STATEMENT Optimizer=CHOOSE 1 0 TABLE ACCESS (BY INDEX ROWID) OF ‘EMP’ 2 1 INDEX (FULL SCAN) OF ‘EMPNO’ (UNIQUE) 避免改变索引列的类型.当比较不同数据类型的数据时, ORACLE自动对列进行简单的类型转换. 假设 EMPNO是一个数值类型的索引列. SELECT …FROM EMPWHERE EMPNO = ‘123’ 实际上,经过ORACLE类型转换, 语句转化为:SELECT …FROM EMPWHERE EMPNO = TO_NUMBER(‘123’) 幸运的是,类型转换没有发生在索引列上,索引的用途没有被改变. 现在,假设EMP_TYPE是一个字符类型的索引列.SELECT …FROM EMPWHERE EMP_TYPE = 123 这个语句被ORACLE转换为:SELECT …FROM EMPWHERE TO_NUMBER(EMP_TYPE)=123 因为内部发生的类型转换, 这个索引将不会被用到!译者按:为了避免ORACLE对你的SQL进行隐式的类型转换, 最好把类型转换用显式表现出来. 注意当字符和数值比较时, ORACLE会优先转换数值类型到字符类型. 需要当心的WHERE子句某些SELECT 语句中的WHERE子句不使用索引. 这里有一些例子.在下面的例子里, ‘!=’ 将不使用索引. 记住, 索引只能告诉你什么存在于表中, 而不能告诉你什么不存在于表中.不使用索引:SELECT ACCOUNT_NAMEFROM TRANSACTIONWHERE AMOUNT !=0;使用索引:SELECT ACCOUNT_NAMEFROM TRANSACTIONWHERE AMOUNT &gt;0; 下面的例子中, ‘||’是字符连接函数. 就象其他函数那样, 停用了索引.不使用索引:SELECT ACCOUNT_NAME,AMOUNTFROM TRANSACTIONWHERE ACCOUNT_NAME||ACCOUNT_TYPE=’AMEXA’;使用索引:SELECT ACCOUNT_NAME,AMOUNTFROM TRANSACTIONWHERE ACCOUNT_NAME = ‘AMEX’AND ACCOUNT_TYPE=’ A’; 下面的例子中, ‘+’是数学函数. 就象其他数学函数那样, 停用了索引.不使用索引:SELECT ACCOUNT_NAME, AMOUNTFROM TRANSACTIONWHERE AMOUNT + 3000 &gt;5000;使用索引:SELECT ACCOUNT_NAME, AMOUNTFROM TRANSACTIONWHERE AMOUNT &gt; 2000 ;下面的例子中,相同的索引列不能互相比较,这将会启用全表扫描.不使用索引:SELECT ACCOUNT_NAME, AMOUNTFROM TRANSACTIONWHERE ACCOUNT_NAME = NVL(:ACC_NAME,ACCOUNT_NAME);使用索引:SELECT ACCOUNT_NAME, AMOUNTFROM TRANSACTIONWHERE ACCOUNT_NAME LIKE NVL(:ACC_NAME,’%’); 译者按:如果一定要对使用函数的列启用索引, ORACLE新的功能: 基于函数的索引(Function-Based Index) 也许是一个较好的方案. CREATE INDEX EMP_I ON EMP (UPPER(ename)); /建立基于函数的索引/ SELECT FROM emp WHERE UPPER(ename) = ‘BLACKSNAIL’; /将使用索引*/ 连接多个扫描如果你对一个列和一组有限的值进行比较, 优化器可能执行多次扫描并对结果进行合并连接.举例:SELECT *FROM LODGINGWHERE MANAGER IN (‘BILL GATES’,’KEN MULLER’); 优化器可能将它转换成以下形式SELECT *FROM LODGINGWHERE MANAGER = ‘BILL GATES’OR MANAGER = ’KEN MULLER’; 当选择执行路径时, 优化器可能对每个条件采用LODGING$MANAGER上的索引范围扫描. 返回的ROWID用来访问LODGING表的记录 (通过TABLE ACCESS BY ROWID 的方式). 最后两组记录以连接(CONCATENATION)的形式被组合成一个单一的集合. Explain Plan : SELECT STATEMENT Optimizer=CHOOSE CONCATENATION TABLE ACCESS (BY INDEX ROWID) OF LODGING INDEX (RANGE SCAN ) OF LODGING$MANAGER (NON-UNIQUE) TABLE ACCESS (BY INDEX ROWID) OF LODGING INDEX (RANGE SCAN ) OF LODGING$MANAGER (NON-UNIQUE)译者按:本节和第37节似乎有矛盾之处. CBO下使用更具选择性的索引基于成本的优化器(CBO, Cost-Based Optimizer)对索引的选择性进行判断来决定索引的使用是否能提高效率.如果索引有很高的选择性, 那就是说对于每个不重复的索引键值,只对应数量很少的记录.比如, 表中共有100条记录而其中有80个不重复的索引键值. 这个索引的选择性就是80/100 = 0.8 . 选择性越高, 通过索引键值检索出的记录就越少.如果索引的选择性很低, 检索数据就需要大量的索引范围查询操作和ROWID 访问表的操作. 也许会比全表扫描的效率更低. 译者按:下列经验请参阅:a. 如果检索数据量超过30%的表中记录数.使用索引将没有显著的效率提高.b. 在特定情况下, 使用索引也许会比全表扫描慢, 但这是同一个数量级上的区别. 而通常情况下,使用索引比全表扫描要块几倍乃至几千倍! 避免使用耗费资源的操作带有DISTINCT,UNION,MINUS,INTERSECT,ORDER BY的SQL语句会启动SQL引擎执行耗费资源的排序(SORT)功能. DISTINCT需要一次排序操作, 而其他的至少需要执行两次排序.例如,一个UNION查询,其中每个查询都带有GROUP BY子句, GROUP BY会触发嵌入排序(NESTED SORT) ; 这样, 每个查询需要执行一次排序, 然后在执行UNION时, 又一个唯一排序(SORT UNIQUE)操作被执行而且它只能在前面的嵌入排序结束后才能开始执行. 嵌入的排序的深度会大大影响查询的效率.通常, 带有UNION, MINUS , INTERSECT的SQL语句都可以用其他方式重写.译者按:如果你的数据库的SORT_AREA_SIZE调配得好, 使用UNION , MINUS, INTERSECT也是可以考虑的, 毕竟它们的可读性很强 优化GROUP BY提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉.下面两个查询返回相同结果但第二个明显就快了许多. 低效: SELECT JOB , AVG(SAL) FROM EMP GROUP JOB HAVING JOB = ‘PRESIDENT’ OR JOB = ‘MANAGER’ 高效: SELECT JOB , AVG(SAL) FROM EMP WHERE JOB = ‘PRESIDENT’ OR JOB = ‘MANAGER’ GROUP JOB 译者按: 本节和14节相同. 可略过. 使用日期当使用日期是,需要注意如果有超过5位小数加到日期上, 这个日期会进到下一天! 例如:1.SELECT TO_DATE(‘01-JAN-93’+.99999)FROM DUAL; Returns: ’01-JAN-93 23:59:59’2.SELECT TO_DATE(‘01-JAN-93’+.999999)FROM DUAL; Returns: ’02-JAN-93 00:00:00’ 译者按: 虽然本节和SQL性能优化没有关系, 但是作者的功力可见一斑 使用显式的游标(CURSORs)使用隐式的游标,将会执行两次操作. 第一次检索记录, 第二次检查TOO MANY ROWS 这个exception . 而显式游标不执行第二次操作. 优化EXPORT和IMPORT使用较大的BUFFER(比如10MB , 10,240,000)可以提高EXPORT和IMPORT的速度.ORACLE将尽可能地获取你所指定的内存大小,即使在内存不满足,也不会报错.这个值至少要和表中最大的列相当,否则列值会被截断.译者按:可以肯定的是, 增加BUFFER会大大提高EXPORT , IMPORT的效率. (曾经碰到过一个CASE, 增加BUFFER后,IMPORT/EXPORT快了10倍!)作者可能犯了一个错误: “这个值至少要和表中最大的列相当,否则列值会被截断. “其中最大的列也许是指最大的记录大小.关于EXPORT/IMPORT的优化,CSDN论坛中有一些总结性的贴子,比如关于BUFFER参数, COMMIT参数等等, 详情请查. 分离表和索引总是将你的表和索引建立在不同的表空间内(TABLESPACES). 决不要将不属于ORACLE内部系统的对象存放到SYSTEM表空间里. 同时,确保数据表空间和索引表空间置于不同的硬盘上. 译者按:“同时,确保数据表空间和索引表空间置与不同的硬盘上.”可能改为如下更为准确 “同时,确保数据表空间和索引表空间置与不同的硬盘控制卡控制的硬盘上.”","categories":[{"name":"软件开发","slug":"软件开发","permalink":"http://yoursite.com/categories/软件开发/"},{"name":"系统架构","slug":"软件开发/系统架构","permalink":"http://yoursite.com/categories/软件开发/系统架构/"},{"name":"数据存储","slug":"软件开发/系统架构/数据存储","permalink":"http://yoursite.com/categories/软件开发/系统架构/数据存储/"},{"name":"Oracle","slug":"软件开发/系统架构/数据存储/Oracle","permalink":"http://yoursite.com/categories/软件开发/系统架构/数据存储/Oracle/"}],"tags":[]}]}